--- a/Makefile
+++ b/Makefile
@@ -5,9 +5,6 @@
 obj-m += qca-nss-drv.o
 
 #
-# Regular NSS path
-#
-#
 # List the files that belong to the driver in alphabetical order.
 #
 qca-nss-drv-objs := \
@@ -19,61 +16,86 @@ qca-nss-drv-objs := \
 			nss_dynamic_interface.o \
 			nss_dynamic_interface_log.o \
 			nss_dynamic_interface_stats.o \
+			nss_eth_rx.o \
+			nss_eth_rx_stats.o \
+			nss_eth_rx_strings.o \
+			nss_gmac_stats.o \
+			nss_if.o \
+			nss_if_log.o \
 			nss_init.o \
+			nss_ipv4.o \
+			nss_ipv4_stats.o \
+			nss_ipv4_strings.o \
+			nss_ipv4_log.o \
 			nss_log.o \
+			nss_lso_rx.o \
+			nss_lso_rx_stats.o \
+			nss_lso_rx_strings.o \
 			nss_meminfo.o \
 			nss_n2h.o \
 			nss_n2h_stats.o \
 			nss_n2h_strings.o \
+			nss_phys_if.o \
 			nss_pm.o \
 			nss_profiler.o \
 			nss_project.o \
 			nss_rps.o \
 			nss_stats.o \
 			nss_strings.o \
+			nss_tx_msg_sync.o \
 			nss_unaligned.o \
 			nss_unaligned_log.o \
 			nss_unaligned_stats.o
 
-# Base NSS HAL support
+# Base NSS data plane/HAL support
+qca-nss-drv-objs += nss_data_plane/nss_data_plane_common.o
 qca-nss-drv-objs += nss_hal/nss_hal.o
 
-ifneq "$(NSS_DRV_POINT_OFFLOAD)" "y"
+ifneq "$(NSS_DRV_PPPOE_ENABLE)" "n"
+ccflags-y += -DNSS_DRV_PPPOE_ENABLE
+qca-nss-drv-objs += \
+			nss_pppoe.o \
+			nss_pppoe_log.o \
+			nss_pppoe_stats.o \
+			nss_pppoe_strings.o
+endif
+
+ifneq "$(NSS_DRV_VIRT_IF_ENABLE)" "n"
+ccflags-y += -DNSS_DRV_VIRT_IF_ENABLE
 qca-nss-drv-objs += \
-			nss_gmac_stats.o \
-			nss_if.o \
-			nss_if_log.o \
-			nss_phys_if.o \
-			nss_tx_msg_sync.o \
 			nss_virt_if.o \
 			nss_virt_if_stats.o
-
-# Base NSS data plane support
-qca-nss-drv-objs += nss_data_plane/nss_data_plane_common.o
 endif
 
-ifneq "$(NSS_DRV_BRIDGE_ENABLE)" "n"
-ccflags-y += -DNSS_DRV_BRIDGE_ENABLE
+ifneq "$(NSS_DRV_VLAN_ENABLE)" "n"
+ccflags-y += -DNSS_DRV_VLAN_ENABLE
 qca-nss-drv-objs += \
-		    nss_bridge.o \
-		    nss_bridge_log.o
+			nss_vlan.o \
+			nss_vlan_log.o
 endif
 
-ifneq "$(NSS_DRV_WIFI_EXT_VDEV_ENABLE)" "n"
-ccflags-y += -DNSS_DRV_WIFI_EXT_VDEV_ENABLE
-qca-nss-drv-objs += \
-		    nss_wifi_ext_vdev.o \
-		    nss_wifi_ext_vdev_stats.o \
-		    nss_wifi_ext_vdev_log.o
+ifneq "$(NSS_DRV_WIFI_ENABLE)" "n"
+ccflags-y += -DNSS_DRV_WIFI_ENABLE
+qca-nss-drv-objs += nss_wifi.o \
+			nss_wifi_log.o \
+			nss_wifi_stats.o \
+			nss_wifi_vdev.o \
+			nss_wifi_if.o \
+			nss_wifi_if_stats.o \
+			nss_wifili.o \
+			nss_wifili_log.o \
+			nss_wifili_stats.o \
+			nss_wifili_strings.o
+ifeq ($(shell test $(TARGET_NSS_MINOR_VERSION) -gt 0; echo $$?),0)
+qca-nss-drv-objs += nss_wifi_mac_db.o
+endif
 endif
 
-ifneq "$(NSS_DRV_WIFI_MESH_ENABLE)" "n"
-ccflags-y += -DNSS_DRV_WIFI_MESH_ENABLE
+ifneq "$(NSS_DRV_BRIDGE_ENABLE)" "n"
+ccflags-y += -DNSS_DRV_BRIDGE_ENABLE
 qca-nss-drv-objs += \
-		    nss_wifi_mesh.o \
-		    nss_wifi_mesh_log.o \
-		    nss_wifi_mesh_stats.o \
-		    nss_wifi_mesh_strings.o
+		    nss_bridge.o \
+		    nss_bridge_log.o
 endif
 
 ifneq "$(NSS_DRV_IPV4_REASM_ENABLE)" "n"
@@ -136,8 +158,7 @@ ccflags-y += -DNSS_DRV_GRE_ENABLE
 qca-nss-drv-objs += \
 			 nss_gre.o \
 			 nss_gre_log.o \
-			 nss_gre_stats.o \
-			 nss_gre_strings.o
+			 nss_gre_stats.o
 endif
 
 ifneq "$(NSS_DRV_GRE_REDIR_ENABLE)" "n"
@@ -148,17 +169,13 @@ qca-nss-drv-objs += \
 			 nss_gre_redir_lag_ds.o \
 			 nss_gre_redir_lag_ds_log.o \
 			 nss_gre_redir_lag_ds_stats.o \
-			 nss_gre_redir_lag_ds_strings.o \
 			 nss_gre_redir_lag_us.o \
 			 nss_gre_redir_lag_us_log.o \
 			 nss_gre_redir_lag_us_stats.o \
-			 nss_gre_redir_lag_us_strings.o \
 			 nss_gre_redir_stats.o \
-			 nss_gre_redir_strings.o \
 			 nss_gre_redir_mark.o \
 			 nss_gre_redir_mark_log.o \
-			 nss_gre_redir_mark_stats.o \
-			 nss_gre_redir_mark_strings.o
+			 nss_gre_redir_mark_stats.o
 endif
 
 ifneq "$(NSS_DRV_GRE_TUNNEL_ENABLE)" "n"
@@ -166,8 +183,7 @@ ccflags-y += -DNSS_DRV_GRE_TUNNEL_ENABLE
 qca-nss-drv-objs += \
 			 nss_gre_tunnel.o \
 			 nss_gre_tunnel_log.o \
-			 nss_gre_tunnel_stats.o \
-			 nss_gre_tunnel_strings.o
+			 nss_gre_tunnel_stats.o
 endif
 
 ifneq "$(NSS_DRV_CAPWAP_ENABLE)" "n"
@@ -226,20 +242,11 @@ qca-nss-drv-objs += \
 			 nss_trustsec_tx_stats.o
 endif
 
-ifneq "$(NSS_DRV_TRUSTSEC_RX_ENABLE)" "n"
-ccflags-y += -DNSS_DRV_TRUSTSEC_RX_ENABLE
-qca-nss-drv-objs += \
-			 nss_trustsec_rx.o \
-			 nss_trustsec_rx_log.o \
-			 nss_trustsec_rx_stats.o
-endif
-
 ifneq "$(NSS_DRV_TUNIPIP6_ENABLE)" "n"
 ccflags-y += -DNSS_DRV_TUNIPIP6_ENABLE
 qca-nss-drv-objs += \
 			 nss_tunipip6.o \
-			 nss_tunipip6_log.o \
-			 nss_tunipip6_stats.o
+			 nss_tunipip6_log.o
 endif
 
 ifneq "$(NSS_DRV_QRFS_ENABLE)" "n"
@@ -284,8 +291,7 @@ ccflags-y += -DNSS_DRV_CLMAP_ENABLE
 qca-nss-drv-objs += \
 			 nss_clmap.o \
 			 nss_clmap_log.o \
-			 nss_clmap_stats.o \
-			 nss_clmap_strings.o
+			 nss_clmap_stats.o
 endif
 
 
@@ -302,8 +308,7 @@ ccflags-y += -DNSS_DRV_MATCH_ENABLE
 qca-nss-drv-objs += \
 			nss_match.o \
 			nss_match_log.o \
-			nss_match_stats.o \
-			nss_match_strings.o
+			nss_match_stats.o
 endif
 
 ifneq "$(NSS_DRV_MIRROR_ENABLE)" "n"
@@ -311,72 +316,7 @@ ccflags-y += -DNSS_DRV_MIRROR_ENABLE
 qca-nss-drv-objs += \
 			nss_mirror.o \
 			nss_mirror_log.o \
-			nss_mirror_stats.o \
-			nss_mirror_strings.o
-endif
-
-ifneq "$(NSS_DRV_UDP_ST_ENABLE)" "n"
-ccflags-y += -DNSS_DRV_UDP_ST_ENABLE
-qca-nss-drv-objs += \
-			nss_udp_st.o \
-			nss_udp_st_log.o \
-			nss_udp_st_stats.o \
-			nss_udp_st_strings.o
-endif
-
-ifneq "$(NSS_DRV_IPV4_ENABLE)" "n"
-ccflags-y += -DNSS_DRV_IPV4_ENABLE
-qca-nss-drv-objs += \
-			nss_ipv4.o \
-			nss_ipv4_stats.o \
-			nss_ipv4_strings.o \
-			nss_ipv4_log.o
-endif
-
-ifneq "$(NSS_DRV_ETH_RX_ENABLE)" "n"
-ccflags-y += -DNSS_DRV_ETH_RX_ENABLE
-qca-nss-drv-objs += \
-			nss_eth_rx.o \
-			nss_eth_rx_stats.o \
-			nss_eth_rx_strings.o
-endif
-
-ifneq "$(NSS_DRV_PPPOE_ENABLE)" "n"
-ccflags-y += -DNSS_DRV_PPPOE_ENABLE
-qca-nss-drv-objs += \
-			nss_pppoe.o \
-			nss_pppoe_log.o \
-			nss_pppoe_stats.o \
-			nss_pppoe_strings.o
-endif
-
-ifneq "$(NSS_DRV_WIFIOFFLOAD_ENABLE)" "n"
-ccflags-y += -DNSS_DRV_WIFIOFFLOAD_ENABLE
-qca-nss-drv-objs += \
-			nss_wifi.o \
-			nss_wifi_log.o \
-			nss_wifi_stats.o \
-			nss_wifi_vdev.o \
-			nss_wifili.o \
-			nss_wifili_log.o \
-			nss_wifili_stats.o \
-			nss_wifili_strings.o \
-			nss_wifi_mac_db.o
-endif
-
-ifneq "$(NSS_DRV_VLAN_ENABLE)" "n"
-ccflags-y += -DNSS_DRV_VLAN_ENABLE
-qca-nss-drv-objs += \
-			nss_vlan.o \
-			nss_vlan_log.o
-endif
-
-ifneq "$(NSS_DRV_LSO_RX_ENABLE)" "n"
-ccflags-y += -DNSS_DRV_LSO_RX_ENABLE
-qca-nss-drv-objs += \
-			nss_lso_rx.o \
-			nss_lso_rx_stats.o \
-			nss_lso_rx_strings.o
+			nss_mirror_stats.o
 endif
 
 ifeq ($(SoC),$(filter $(SoC),ipq806x))
@@ -420,16 +360,15 @@ endif
 
 ifeq ($(SoC),$(filter $(SoC),ipq60xx ipq60xx_64 ipq807x ipq807x_64))
 qca-nss-drv-objs += nss_data_plane/nss_data_plane.o \
-					nss_edma.o \
-					nss_edma_stats.o \
-					nss_edma_strings.o \
-					nss_ppe.o \
-					nss_ppe_log.o \
-					nss_ppe_stats.o \
-					nss_ppe_strings.o \
-					nss_ppe_vp.o \
-					nss_ppe_vp_log.o \
-					nss_ppe_vp_stats.o
+			nss_edma.o \
+			nss_edma_stats.o \
+			nss_edma_strings.o \
+			nss_ppe.o \
+			nss_ppe_log.o \
+			nss_ppe_stats.o \
+			nss_ppe_vp.o \
+			nss_ppe_vp_log.o \
+			nss_ppe_vp_stats.o
 
 ccflags-y += -DNSS_DRV_PPE_ENABLE
 ccflags-y += -DNSS_DRV_EDMA_ENABLE
@@ -438,9 +377,7 @@ ifneq "$(NSS_DRV_IPSEC_ENABLE)" "n"
 ccflags-y += -DNSS_DRV_IPSEC_ENABLE
 qca-nss-drv-objs += \
 		    nss_ipsec_cmn_log.o \
-		    nss_ipsec_cmn.o \
-		    nss_ipsec_cmn_stats.o \
-		    nss_ipsec_cmn_strings.o
+		    nss_ipsec_cmn.o
 endif
 
 ifneq "$(NSS_DRV_CRYPTO_ENABLE)" "n"
@@ -450,8 +387,6 @@ ccflags-y += -DNSS_DRV_DMA_ENABLE
 qca-nss-drv-objs += \
 		    nss_crypto_cmn.o \
 		    nss_crypto_cmn_log.o \
-		    nss_crypto_cmn_stats.o \
-		    nss_crypto_cmn_strings.o \
 		    nss_dma.o \
 		    nss_dma_log.o \
 		    nss_dma_stats.o \
@@ -462,9 +397,7 @@ ifneq "$(NSS_DRV_DTLS_ENABLE)" "n"
 ccflags-y += -DNSS_DRV_DTLS_ENABLE
 qca-nss-drv-objs += \
 		    nss_dtls_cmn.o \
-		    nss_dtls_cmn_log.o \
-		    nss_dtls_cmn_stats.o \
-		    nss_dtls_cmn_strings.o
+		    nss_dtls_cmn_log.o
 endif
 
 ifneq "$(NSS_DRV_QVPN_ENABLE)" "n"
@@ -472,62 +405,14 @@ ccflags-y += -DNSS_DRV_QVPN_ENABLE
 qca-nss-drv-objs += \
 	     nss_qvpn.o \
 	     nss_qvpn_log.o \
-	     nss_qvpn_stats.o \
-	     nss_qvpn_strings.o
+	     nss_qvpn_stats.o
 endif
 ifneq "$(NSS_DRV_TLS_ENABLE)" "n"
 ccflags-y += -DNSS_DRV_TLS_ENABLE
 qca-nss-drv-objs += \
 		     nss_tls.o \
-		     nss_tls_log.o \
-		     nss_tls_stats.o \
-		     nss_tls_strings.o
-endif
-endif
-
-ifeq ($(SoC),$(filter $(SoC),ipq95xx))
-qca-nss-drv-objs += nss_hal/ipq95xx/nss_hal_pvt.o
-qca-nss-drv-objs += nss_data_plane/nss_data_plane_lite.o
-qca-nss-drv-objs += nss_edma_lite.o \
-		    nss_edma_lite_stats.o \
-		    nss_edma_lite_strings.o
-
-ccflags-y += -DNSS_DATA_PLANE_LITE_SUPPORT
-ccflags-y += -DNSS_DRV_EDMA_LITE_ENABLE
-ccflags-y += -DNSS_DRV_POINT_OFFLOAD
-
-ifneq "$(NSS_DRV_CRYPTO_ENABLE)" "n"
-ccflags-y += -DNSS_DRV_CRYPTO_ENABLE
-ccflags-y += -DNSS_DRV_DMA_ENABLE
-
-qca-nss-drv-objs += \
-		    nss_crypto.o \
-		    nss_crypto_log.o \
-		    nss_crypto_cmn.o \
-		    nss_crypto_cmn_log.o \
-		    nss_crypto_cmn_stats.o \
-		    nss_crypto_cmn_strings.o \
-		    nss_dma.o \
-		    nss_dma_log.o \
-		    nss_dma_stats.o \
-		    nss_dma_strings.o
-endif
-
-ifneq "$(NSS_DRV_DTLS_ENABLE)" "n"
-ccflags-y += -DNSS_DRV_DTLS_ENABLE
-qca-nss-drv-objs += \
-		    nss_dtls.o \
-		    nss_dtls_log.o \
-		    nss_dtls_stats.o \
-		    nss_dtls_cmn.o \
-		    nss_dtls_cmn_log.o \
-		    nss_dtls_cmn_stats.o \
-		    nss_dtls_cmn_strings.o
+		     nss_tls_log.o
 endif
-
-ccflags-y += -I$(obj)/nss_hal/ipq95xx -DNSS_HAL_IPQ95XX_SUPPORT -DNSS_MULTI_H2N_DATA_RING_SUPPORT
-else
-ccflags-y += -DNSS_DATA_PLANE_GENERIC_SUPPORT
 endif
 
 ifeq ($(SoC),$(filter $(SoC),ipq807x ipq807x_64))
@@ -562,33 +447,26 @@ ifneq "$(NSS_DRV_IPSEC_ENABLE)" "n"
 ccflags-y += -DNSS_DRV_IPSEC_ENABLE
 qca-nss-drv-objs += \
 		    nss_ipsec_cmn_log.o \
-		    nss_ipsec_cmn.o \
-		    nss_ipsec_cmn_stats.o \
-		    nss_ipsec_cmn_strings.o
+		    nss_ipsec_cmn.o
 endif
 
 ifneq "$(NSS_DRV_CRYPTO_ENABLE)" "n"
 ccflags-y += -DNSS_DRV_CRYPTO_ENABLE
 qca-nss-drv-objs += \
 		    nss_crypto_cmn.o \
-		    nss_crypto_cmn_log.o \
-		    nss_crypto_cmn_stats.o \
-		    nss_crypto_cmn_strings.o
+		    nss_crypto_cmn_log.o
 endif
 
 ifneq "$(NSS_DRV_DTLS_ENABLE)" "n"
 ccflags-y += -DNSS_DRV_DTLS_ENABLE
 qca-nss-drv-objs += \
 		    nss_dtls_cmn.o \
-		    nss_dtls_cmn_log.o \
-		    nss_dtls_cmn_stats.o \
-		    nss_dtls_cmn_strings.o
+		    nss_dtls_cmn_log.o
 endif
 ccflags-y += -I$(obj)/nss_hal/ipq50xx -DNSS_HAL_IPQ50XX_SUPPORT -DNSS_MULTI_H2N_DATA_RING_SUPPORT
 endif
 
 ccflags-y += -I$(obj)/nss_hal/include -I$(obj)/nss_data_plane/include -I$(obj)/exports -DNSS_DEBUG_LEVEL=0 -DNSS_PKT_STATS_ENABLED=1
-
 ccflags-y += -I$(obj)/nss_data_plane/hal/include
 ccflags-y += -DNSS_PM_DEBUG_LEVEL=0 -DNSS_SKB_REUSE_SUPPORT=1
 ccflags-y += -Wall -Werror
@@ -603,14 +481,7 @@ NSS_CCFLAGS = -DNSS_DT_SUPPORT=1 -DNSS_F
 ccflags-y += -I$(obj)
 endif
 
-# Fabric scaling is supported in 3.14 and 4.4 only
-ifneq ($(findstring 3.14, $(KERNELVERSION)),)
-NSS_CCFLAGS += -DNSS_FABRIC_SCALING_SUPPORT=1
-else ifneq ($(findstring 4.4, $(KERNELVERSION)),)
-NSS_CCFLAGS += -DNSS_FABRIC_SCALING_SUPPORT=1
-else
 NSS_CCFLAGS += -DNSS_FABRIC_SCALING_SUPPORT=0
-endif
 
 # Disable Frequency scaling
 ifeq "$(NSS_FREQ_SCALE_DISABLE)" "y"
--- a/exports/nss_api_if.h
+++ b/exports/nss_api_if.h
@@ -1,12 +1,9 @@
 /*
  **************************************************************************
- * Copyright (c) 2013-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
- *
+ * Copyright (c) 2013-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
- *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -68,17 +65,16 @@
 #include "nss_wifi_vdev.h"
 #include "nss_n2h.h"
 #include "nss_rps.h"
+#include "nss_wifi_if.h"
 #include "nss_portid.h"
 #include "nss_oam.h"
 #include "nss_dtls.h"
 #include "nss_dtls_cmn.h"
 #include "nss_tls.h"
 #include "nss_edma.h"
-#include "nss_edma_lite.h"
 #include "nss_bridge.h"
 #include "nss_ppe.h"
 #include "nss_trustsec_tx.h"
-#include "nss_trustsec_rx.h"
 #include "nss_vlan.h"
 #include "nss_igs.h"
 #include "nss_mirror.h"
@@ -103,12 +99,6 @@
 #include "nss_ipv4_reasm.h"
 #include "nss_lso_rx.h"
 #include "nss_wifi_mac_db_if.h"
-#include "nss_wifi_ext_vdev_if.h"
-#include "nss_wifili_if.h"
-#include "nss_ppe_vp.h"
-#include "nss_wifi_mesh.h"
-#include "nss_udp_st.h"
-#include "nss_qrfs.h"
 #endif
 
 #endif /*__KERNEL__ */
@@ -129,7 +119,11 @@
 #define NSS_MAX_PHYSICAL_INTERFACES 8	/**< Maximum number of physical interfaces. */
 #define NSS_MAX_VIRTUAL_INTERFACES 16	/**< Maximum number of virtual interfaces. */
 #define NSS_MAX_TUNNEL_INTERFACES 4	/**< Maximum number of tunnel interfaces. */
-#define NSS_MAX_SPECIAL_INTERFACES 72	/**< Maximum number of special interfaces. */
+#if (NSS_FW_VERSION_CODE < NSS_FW_VERSION(11,1))
+#define NSS_MAX_SPECIAL_INTERFACES 55	/**< Maximum number of special interfaces. */
+#else
+#define NSS_MAX_SPECIAL_INTERFACES 67	/**< Maximum number of special interfaces. */
+#endif
 #define NSS_MAX_WIFI_RADIO_INTERFACES 3	/**< Maximum number of radio interfaces. */
 
 /*
@@ -263,6 +257,10 @@
 		/**< Special interface number for timestamp receive. */
 #define NSS_GRE_REDIR_MARK_INTERFACE (NSS_SPECIAL_IF_START + 56)
 		/**< Special interface number for GRE redirect mark. */
+#if (NSS_FW_VERSION_CODE < NSS_FW_VERSION(11,1))
+#define NSS_RMNET_RX_INTERFACE (NSS_SPECIAL_IF_START + 57)
+		/**< Special interface number for RMNET receive handler. */
+#else
 #define NSS_VXLAN_INTERFACE (NSS_SPECIAL_IF_START + 57)
 		/**< Special interface number for VxLAN handler. */
 #define NSS_RMNET_RX_INTERFACE (NSS_SPECIAL_IF_START + 58)
@@ -279,19 +277,510 @@
 		/**< Special interface number for the Wi-Fi MAC database. */
 #define NSS_DMA_INTERFACE (NSS_SPECIAL_IF_START + 66)
 		/**< Special interface number for the DMA interface. */
-#define NSS_WIFI_EXT_VDEV_INTERFACE (NSS_SPECIAL_IF_START + 67)
-		/**< Special interface number for the Wi-Fi extended virtual interface. */
-#define NSS_UDP_ST_INTERFACE (NSS_SPECIAL_IF_START + 68)
-		/**< Special interface number for the UDP speed test interface. */
-#define NSS_EDMA_LITE_INTERFACE (NSS_SPECIAL_IF_START + 69)
-		/**< Special interface number for the EDMA lite interface. */
-#define NSS_PPE_VP_IF_MAP_INTERFACE (NSS_SPECIAL_IF_START + 70)
-		/**< Special interface number for the virtual port map interface. */
-#define NSS_TRUSTSEC_RX_INTERFACE (NSS_SPECIAL_IF_START + 71)
-		/**< Special interface number for the TrustSec RX. */
+#endif
 
 #ifdef __KERNEL__ /* only kernel will use. */
 
+/**
+ * Wireless Multimedia Extention Access Category to TID. @hideinitializer
+ */
+#define NSS_WIFILI_WME_AC_TO_TID(_ac) (	\
+		((_ac) == NSS_WIFILI_WME_AC_VO) ? 6 : \
+		(((_ac) == NSS_WIFILI_WME_AC_VI) ? 5 : \
+		(((_ac) == NSS_WIFILI_WME_AC_BK) ? 1 : \
+		0)))
+
+/**
+ * Wireless TID to Wireless Extension Multimedia Access Category. @hideinitializer
+ */
+#define NSS_WIFILI_TID_TO_WME_AC(_tid) (	\
+		(((_tid) == 0) || ((_tid) == 3)) ? NSS_WIFILI_WME_AC_BE : \
+		((((_tid) == 1) || ((_tid) == 2)) ? NSS_WIFILI_WME_AC_BK : \
+		((((_tid) == 4) || ((_tid) == 5)) ? NSS_WIFILI_WME_AC_VI : \
+		NSS_WIFILI_WME_AC_VO)))
+
+/**
+ * Converts the format of an IPv6 address from Linux to NSS. @hideinitializer
+ */
+#define IN6_ADDR_TO_IPV6_ADDR(ipv6, in6) \
+	{ \
+		((uint32_t *)ipv6)[0] = in6.in6_u.u6_addr32[0]; \
+		((uint32_t *)ipv6)[1] = in6.in6_u.u6_addr32[1]; \
+		((uint32_t *)ipv6)[2] = in6.in6_u.u6_addr32[2]; \
+		((uint32_t *)ipv6)[3] = in6.in6_u.u6_addr32[3]; \
+	}
+
+/**
+ * Converts the format of an IPv6 address from NSS to Linux. @hideinitializer
+ */
+#define IPV6_ADDR_TO_IN6_ADDR(in6, ipv6) \
+	{ \
+		in6.in6_u.u6_addr32[0] = ((uint32_t *)ipv6)[0]; \
+		in6.in6_u.u6_addr32[1] = ((uint32_t *)ipv6)[1]; \
+		in6.in6_u.u6_addr32[2] = ((uint32_t *)ipv6)[2]; \
+		in6.in6_u.u6_addr32[3] = ((uint32_t *)ipv6)[3]; \
+	}
+
+/**
+ * Format of an IPv6 address (16 * 8 bits).
+ */
+#define IPV6_ADDR_OCTAL_FMT "%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x"
+
+/**
+ * Prints an IPv6 address (16 * 8 bits).
+ */
+#define IPV6_ADDR_TO_OCTAL(ipv6) ((uint16_t *)ipv6)[0], ((uint16_t *)ipv6)[1], ((uint16_t *)ipv6)[2], ((uint16_t *)ipv6)[3], ((uint16_t *)ipv6)[4], ((uint16_t *)ipv6)[5], ((uint16_t *)ipv6)[6], ((uint16_t *)ipv6)[7]
+
+/*
+ * IPv4 rule sync reasons.
+ */
+#define NSS_IPV4_SYNC_REASON_STATS 0	/**< Rule for synchronizing statistics. */
+#define NSS_IPV4_SYNC_REASON_FLUSH 1	/**< Rule for flushing a cache entry. */
+#define NSS_IPV4_SYNC_REASON_EVICT 2	/**< Rule for evicting a cache entry. */
+#define NSS_IPV4_SYNC_REASON_DESTROY 3
+		/**< Rule for destroying a cache entry (requested by the host OS). */
+#define NSS_IPV4_SYNC_REASON_PPPOE_DESTROY 4
+		/**< Rule for destroying a cache entry that belongs to a PPPoE session. */
+
+/**
+ * nss_ipv4_create
+ *	Information for an IPv4 flow or connection create rule.
+ *
+ * All fields must be passed in host-endian order.
+ */
+struct nss_ipv4_create {
+	int32_t src_interface_num;
+				/**< Source interface number (virtual or physical). */
+	int32_t dest_interface_num;
+				/**< Destination interface number (virtual or physical). */
+	int32_t protocol;	/**< L4 protocol (e.g., TCP or UDP). */
+	uint32_t flags;		/**< Flags (if any) associated with this rule. */
+	uint32_t from_mtu;	/**< MTU of the incoming interface. */
+	uint32_t to_mtu;	/**< MTU of the outgoing interface. */
+	uint32_t src_ip;	/**< Source IP address. */
+	int32_t src_port;	/**< Source L4 port (e.g., TCP or UDP port). */
+	uint32_t src_ip_xlate;	/**< Translated source IP address (used with SNAT). */
+	int32_t src_port_xlate;	/**< Translated source L4 port (used with SNAT). */
+	uint32_t dest_ip;	/**< Destination IP address. */
+	int32_t dest_port;	/**< Destination L4 port (e.g., TCP or UDP port). */
+	uint32_t dest_ip_xlate;
+			/**< Translated destination IP address (used with DNAT). */
+	int32_t dest_port_xlate;
+			/**< Translated destination L4 port (used with DNAT). */
+	uint8_t src_mac[ETH_ALEN];
+			/**< Source MAC address. */
+	uint8_t dest_mac[ETH_ALEN];
+			/**< Destination MAC address. */
+	uint8_t src_mac_xlate[ETH_ALEN];
+			/**< Translated source MAC address (post-routing). */
+	uint8_t dest_mac_xlate[ETH_ALEN];
+			/**< Translated destination MAC address (post-routing). */
+	uint8_t flow_window_scale;	/**< Window scaling factor (TCP). */
+	uint32_t flow_max_window;	/**< Maximum window size (TCP). */
+	uint32_t flow_end;		/**< TCP window end. */
+	uint32_t flow_max_end;		/**< TCP window maximum end. */
+	uint32_t flow_pppoe_if_exist;
+			/**< Flow direction: PPPoE interface exist flag. */
+	int32_t flow_pppoe_if_num;
+			/**< Flow direction: PPPoE interface number. */
+	uint16_t ingress_vlan_tag;	/**< Ingress VLAN tag expected for this flow. */
+	uint8_t return_window_scale;
+			/**< Window scaling factor of the return direction (TCP). */
+	uint32_t return_max_window;
+			/**< Maximum window size of the return direction. */
+	uint32_t return_end;
+			/**< Flow end for the return direction. */
+	uint32_t return_max_end;
+			/**< Flow maximum end for the return direction. */
+	uint32_t return_pppoe_if_exist;
+			/**< Return direction: PPPoE interface existence flag. */
+	int32_t return_pppoe_if_num;
+			/**< Return direction: PPPoE interface number. */
+	uint16_t egress_vlan_tag;	/**< Egress VLAN tag expected for this flow. */
+	uint8_t spo_needed;		/**< Indicates whether SPO is required. */
+	uint32_t param_a0;		/**< Custom parameter 0. */
+	uint32_t param_a1;		/**< Custom parameter 1. */
+	uint32_t param_a2;		/**< Custom parameter 2. */
+	uint32_t param_a3;		/**< Custom parameter 3. */
+	uint32_t param_a4;		/**< Custom parameter 4. */
+	uint32_t qos_tag;		/**< Deprecated, will be removed soon. */
+	uint32_t flow_qos_tag;		/**< QoS tag value for the flow direction. */
+	uint32_t return_qos_tag;	/**< QoS tag value for the return direction. */
+	uint8_t dscp_itag;		/**< DSCP marking tag. */
+	uint8_t dscp_imask;		/**< DSCP marking input mask. */
+	uint8_t dscp_omask;		/**< DSCP marking output mask. */
+	uint8_t dscp_oval;		/**< DSCP marking output value. */
+	uint16_t vlan_itag;		/**< VLAN marking tag. */
+	uint16_t vlan_imask;		/**< VLAN marking input mask. */
+	uint16_t vlan_omask;		/**< VLAN marking output mask. */
+	uint16_t vlan_oval;		/**< VLAN marking output value. */
+	uint32_t in_vlan_tag[MAX_VLAN_DEPTH];
+			/**< Ingress VLAN tag expected for this flow. */
+	uint32_t out_vlan_tag[MAX_VLAN_DEPTH];
+			/**< Egress VLAN tag expected for this flow. */
+	uint8_t flow_dscp;		/**< IP DSCP value for the flow direction. */
+	uint8_t return_dscp;		/**< IP DSCP value for the return direction. */
+};
+
+/*
+ * IPv4 connection flags (to be used with nss_ipv4_create::flags).
+ */
+#define NSS_IPV4_CREATE_FLAG_NO_SEQ_CHECK 0x01
+		/**< Rule for not checking sequence numbers. */
+#define NSS_IPV4_CREATE_FLAG_BRIDGE_FLOW 0x02
+		/**< Rule that indicates pure bridge flow (no routing is involved). */
+#define NSS_IPV4_CREATE_FLAG_ROUTED 0x04	/**< Rule for a routed connection. */
+
+#define NSS_IPV4_CREATE_FLAG_DSCP_MARKING 0x08	/**< Rule for DSCP marking. */
+#define NSS_IPV4_CREATE_FLAG_VLAN_MARKING 0x10	/**< Rule for VLAN marking. */
+#define NSS_IPV4_CREATE_FLAG_QOS_VALID 0x20	/**< Rule for QoS is valid. */
+
+/**
+ * nss_ipv4_destroy
+ *	Information for an IPv4 flow or connection destroy rule.
+ */
+struct nss_ipv4_destroy {
+	int32_t protocol;	/**< L4 protocol ID. */
+	uint32_t src_ip;	/**< Source IP address. */
+	int32_t src_port;	/**< Source L4 port (e.g., TCP or UDP port). */
+	uint32_t dest_ip;	/**< Destination IP address. */
+	int32_t dest_port;	/**< Destination L4 port (e.g., TCP or UDP port). */
+};
+
+/*
+ * IPv6 rule sync reasons.
+ */
+#define NSS_IPV6_SYNC_REASON_STATS 0	/**< Rule for synchronizing statistics. */
+#define NSS_IPV6_SYNC_REASON_FLUSH 1	/**< Rule for flushing a cache entry. */
+#define NSS_IPV6_SYNC_REASON_EVICT 2	/**< Rule for evicting a cache entry. */
+#define NSS_IPV6_SYNC_REASON_DESTROY 3
+		/**< Rule for destroying a cache entry (requested by the host OS). */
+#define NSS_IPV6_SYNC_REASON_PPPOE_DESTROY 4
+		/**< Rule for destroying a cache entry that belongs to a PPPoE session. */
+
+/**
+ * nss_ipv6_create
+ *	Information for an IPv6 flow or connection create rule.
+ *
+ * All fields must be passed in host-endian order.
+ */
+struct nss_ipv6_create {
+	int32_t src_interface_num;
+			/**< Source interface number (virtual or physical). */
+	int32_t dest_interface_num;
+			/**< Destination interface number (virtual or physical). */
+	int32_t protocol;	/**< L4 protocol (e.g., TCP or UDP). */
+	uint32_t flags;		/**< Flags (if any) associated with this rule. */
+	uint32_t from_mtu;	/**< MTU of the incoming interface. */
+	uint32_t to_mtu;	/**< MTU of the outgoing interface. */
+	uint32_t src_ip[4];	/**< Source IP address. */
+	int32_t src_port;	/**< Source L4 port (e.g., TCP or UDP port). */
+	uint32_t dest_ip[4];	/**< Destination IP address. */
+	int32_t dest_port;	/**< Destination L4 port (e.g., TCP or UDP port). */
+	uint8_t src_mac[ETH_ALEN];	/**< Source MAC address. */
+	uint8_t dest_mac[ETH_ALEN];	/**< Destination MAC address. */
+	uint8_t flow_window_scale;	/**< Window scaling factor (TCP). */
+	uint32_t flow_max_window;	/**< Maximum window size (TCP). */
+	uint32_t flow_end;		/**< TCP window end. */
+	uint32_t flow_max_end;		/**< TCP window maximum end. */
+	uint32_t flow_pppoe_if_exist;
+			/**< Flow direction: PPPoE interface existence flag. */
+	int32_t flow_pppoe_if_num;
+			/**< Flow direction: PPPoE interface number. */
+	uint16_t ingress_vlan_tag;
+			/**< Ingress VLAN tag expected for this flow. */
+	uint8_t return_window_scale;
+			/**< Window scaling factor (TCP) for the return direction. */
+	uint32_t return_max_window;
+			/**< Maximum window size (TCP) for the return direction. */
+	uint32_t return_end;
+			/**< End for the return direction. */
+	uint32_t return_max_end;
+			/**< Maximum end for the return direction. */
+	uint32_t return_pppoe_if_exist;
+			/**< Return direction: PPPoE interface exist flag. */
+	int32_t return_pppoe_if_num;
+			/**< Return direction: PPPoE interface number. */
+	uint16_t egress_vlan_tag;	/**< Egress VLAN tag expected for this flow. */
+	uint32_t qos_tag;		/**< Deprecated; will be removed soon. */
+	uint32_t flow_qos_tag;		/**< QoS tag value for flow direction. */
+	uint32_t return_qos_tag;	/**< QoS tag value for the return direction. */
+	uint8_t dscp_itag;		/**< DSCP marking tag. */
+	uint8_t dscp_imask;		/**< DSCP marking input mask. */
+	uint8_t dscp_omask;		/**< DSCP marking output mask. */
+	uint8_t dscp_oval;		/**< DSCP marking output value. */
+	uint16_t vlan_itag;		/**< VLAN marking tag. */
+	uint16_t vlan_imask;		/**< VLAN marking input mask. */
+	uint16_t vlan_omask;		/**< VLAN marking output mask. */
+	uint16_t vlan_oval;		/**< VLAN marking output value. */
+	uint32_t in_vlan_tag[MAX_VLAN_DEPTH];
+					/**< Ingress VLAN tag expected for this flow. */
+	uint32_t out_vlan_tag[MAX_VLAN_DEPTH];
+					/**< Egress VLAN tag expected for this flow. */
+	uint8_t flow_dscp;		/**< IP DSCP value for flow direction. */
+	uint8_t return_dscp;		/**< IP DSCP value for the return direction. */
+};
+
+/*
+ * IPv6 connection flags (to be used with nss_ipv6_create::flags.
+ */
+#define NSS_IPV6_CREATE_FLAG_NO_SEQ_CHECK 0x1
+		/**< Indicates that sequence numbers are not to be checked. */
+#define NSS_IPV6_CREATE_FLAG_BRIDGE_FLOW 0x02
+		/**< Indicates that this is a pure bridge flow (no routing is involved). */
+#define NSS_IPV6_CREATE_FLAG_ROUTED 0x04	/**< Rule is for a routed connection. */
+#define NSS_IPV6_CREATE_FLAG_DSCP_MARKING 0x08	/**< Rule for DSCP marking. */
+#define NSS_IPV6_CREATE_FLAG_VLAN_MARKING 0x10	/**< Rule for VLAN marking. */
+#define NSS_IPV6_CREATE_FLAG_QOS_VALID 0x20	/**< Rule for Valid QoS. */
+
+/**
+ * nss_ipv6_destroy
+ *	Information for an IPv6 flow or connection destroy rule.
+ */
+struct nss_ipv6_destroy {
+	int32_t protocol;	/**< L4 protocol (e.g., TCP or UDP). */
+	uint32_t src_ip[4];	/**< Source IP address. */
+	int32_t src_port;	/**< Source L4 port (e.g., TCP or UDP port). */
+	uint32_t dest_ip[4];	/**< Destination IP address. */
+	int32_t dest_port;	/**< Destination L4 port (e.g., TCP or UDP port). */
+};
+
+/**
+ * nss_ipv4_sync
+ *	Defines packet statistics for IPv4 and also keeps the connection entry alive.
+ *
+ * Statistics are bytes and packets seen over a connection.
+ *
+ * The addresses are NON-NAT addresses (i.e., true endpoint
+ * addressing).
+ *
+ * The source (src) creates the connection.
+ */
+struct nss_ipv4_sync {
+	uint32_t index;		/**< Slot ID for cache statistics to host OS. */
+			/*TODO: use an opaque information as host and NSS
+			  may be using a different mechanism to store rules. */
+	int32_t protocol;	/**< L4 protocol (e.g., TCP or UDP). */
+	uint32_t src_ip;	/**< Source IP address. */
+	int32_t src_port;	/**< Source L4 port (e.g., TCP or UDP port). */
+	uint32_t src_ip_xlate;	/**< Translated source IP address (used with SNAT). */
+	int32_t src_port_xlate;	/**< Translated source L4 port (used with SNAT). */
+	uint32_t dest_ip;	/**< Destination IP address. */
+	int32_t dest_port;	/**< Destination L4 port (e.g., TCP or UDP port). */
+	uint32_t dest_ip_xlate;
+			/**< Translated destination IP address (used with DNAT). */
+	int32_t dest_port_xlate;
+			/**< Translated destination L4 port (used with DNAT). */
+	uint32_t flow_max_window;	/**< Maximum window size (TCP). */
+	uint32_t flow_end;		/**< TCP window end. */
+	uint32_t flow_max_end;		/**< TCP window maximum end. */
+	uint32_t flow_rx_packet_count;	/**< Rx packet count for the flow interface. */
+	uint32_t flow_rx_byte_count;	/**< Rx byte count for the flow interface. */
+	uint32_t flow_tx_packet_count;	/**< Tx packet count for the flow interface. */
+	uint32_t flow_tx_byte_count;	/**< Tx byte count for the flow interface. */
+	uint32_t return_max_window;
+			/**< Maximum window size (TCP) for the return direction. */
+	uint32_t return_end;
+			/**< End for the return direction. */
+	uint32_t return_max_end;
+			/**< Maximum end for the return direction. */
+	uint32_t return_rx_packet_count;
+			/**< Rx packet count for the return direction. */
+	uint32_t return_rx_byte_count;
+			/**< Rx byte count for the return direction. */
+	uint32_t return_tx_packet_count;
+			/**< Tx packet count for the return direction. */
+	uint32_t return_tx_byte_count;
+			/**< Tx byte count for the return direction. */
+
+	/**
+	 * Time in Linux jiffies to be added to the current timeout to keep the
+	 * connection alive.
+	 */
+	unsigned long int delta_jiffies;
+
+	uint8_t reason;		/**< Reason for synchronization. */
+	uint32_t param_a0;	/**< Custom parameter 0. */
+	uint32_t param_a1;	/**< Custom parameter 1. */
+	uint32_t param_a2;	/**< Custom parameter 2. */
+	uint32_t param_a3;	/**< Custom parameter 3. */
+	uint32_t param_a4;	/**< Custom parameter 4. */
+
+	uint8_t flags;		/**< Flags indicating the status of the flow. */
+	uint32_t qos_tag;	/**< QoS value of the flow. */
+};
+
+/**
+ * nss_ipv4_establish
+ *	Defines connection-established message parameters for IPv4.
+ */
+struct nss_ipv4_establish {
+	uint32_t index;			/**< Slot ID for cache statistics to host OS. */
+			/*TODO: use an opaque information as host and NSS
+			  may be using a different mechanism to store rules. */
+	uint8_t protocol;		/**< Protocol number. */
+	uint8_t reserved[3];		/**< Padding for word alignment. */
+	int32_t flow_interface;		/**< Flow interface number. */
+	uint32_t flow_mtu;		/**< MTU for the flow interface. */
+	uint32_t flow_ip;		/**< Flow IP address. */
+	uint32_t flow_ip_xlate;		/**< Translated flow IP address. */
+	uint32_t flow_ident;		/**< Flow identifier (e.g., port). */
+	uint32_t flow_ident_xlate;	/**< Translated flow identifier (e.g., port). */
+	uint16_t flow_mac[3];		/**< Source MAC address for the flow direction. */
+	uint32_t flow_pppoe_if_exist;	/**< Flow direction: PPPoE interface existence flag. */
+	int32_t flow_pppoe_if_num;	/**< Flow direction: PPPoE interface number. */
+	uint16_t ingress_vlan_tag;	/**< Ingress VLAN tag. */
+	int32_t return_interface;	/**< Return interface number. */
+	uint32_t return_mtu;		/**< MTU for the return interface. */
+	uint32_t return_ip;		/**< Return IP address. */
+	uint32_t return_ip_xlate;	/**< Translated return IP address. */
+	uint32_t return_ident;		/**< Return identier (e.g., port). */
+	uint32_t return_ident_xlate;	/**< Translated return identifier (e.g., port). */
+	uint16_t return_mac[3];		/**< Source MAC address for the return direction. */
+	uint32_t return_pppoe_if_exist;	/**< Return direction: PPPoE interface existence flag. */
+	int32_t return_pppoe_if_num;	/**< Return direction: PPPoE interface number. */
+	uint16_t egress_vlan_tag;	/**< Egress VLAN tag. */
+	uint8_t flags;			/**< Flags indicating the status of the flow. */
+	uint32_t qos_tag;		/**< QoS value of the flow. */
+};
+
+/**
+ * nss_ipv4_cb_reason
+ *	Reasons for an IPv4 callback.
+ */
+enum nss_ipv4_cb_reason {
+	NSS_IPV4_CB_REASON_ESTABLISH = 0,
+	NSS_IPV4_CB_REASON_SYNC,
+	NSS_IPV4_CB_REASON_ESTABLISH_FAIL,
+};
+
+/**
+ * nss_ipv4_cb_params
+ *	Message parameters for an IPv4 callback.
+ */
+struct nss_ipv4_cb_params {
+	enum nss_ipv4_cb_reason reason;		/**< Reason for the callback. */
+
+	/**
+	 * Message parameters for an IPv4 callback.
+	 */
+	union {
+		struct nss_ipv4_sync sync;
+				/**< Parameters for synchronization. */
+		struct nss_ipv4_establish establish;
+				/**< Parameters for establishing a connection. */
+	} params;		/**< Payload of parameters. */
+};
+
+/**
+ * nss_ipv6_sync
+ *	Update packet statistics (bytes and packets seen over a connection) and also keep the connection entry alive.
+ *
+ * The addresses are NON-NAT addresses (i.e., true endpoint addressing).
+ *
+ * The source (src) creates the connection.
+ */
+struct nss_ipv6_sync {
+	uint32_t index;		/**< Slot ID for cache statistics to the host OS. */
+	int32_t protocol;	/**< L4 protocol (e.g., TCP or UDP). */
+	uint32_t src_ip[4];	/**< Source IP address. */
+	int32_t src_port;	/**< Source L4 port (e.g., TCP or UDP port). */
+	uint32_t dest_ip[4];	/**< Destination IP address. */
+	int32_t dest_port;	/**< Destination L4 port (e.g., TCP or UDP port). */
+	uint32_t flow_max_window;	/**< Maximum window size (TCP). */
+	uint32_t flow_end;		/**< TCP window end. */
+	uint32_t flow_max_end;		/**< TCP window maximum end. */
+	uint32_t flow_rx_packet_count;	/**< Rx packet count for the flow interface. */
+	uint32_t flow_rx_byte_count;	/**< Rx byte count for the flow interface. */
+	uint32_t flow_tx_packet_count;	/**< Tx packet count for the flow interface. */
+	uint32_t flow_tx_byte_count;	/**< Tx byte count for the flow interface. */
+	uint32_t return_max_window;
+			/**< Maximum window size (TCP) for the return direction. */
+	uint32_t return_end;
+			/**< End for the return direction. */
+	uint32_t return_max_end;
+			/**< Maximum end for the return direction. */
+	uint32_t return_rx_packet_count;
+			/**< Rx packet count for the return direction. */
+	uint32_t return_rx_byte_count;
+			/**< Rx byte count for the return direction. */
+	uint32_t return_tx_packet_count;
+			/**< Tx packet count for the return direction. */
+	uint32_t return_tx_byte_count;
+			/**< Tx byte count for the return direction. */
+
+	/**
+	 * Time in Linux jiffies to be added to the current timeout to keep the
+	 * connection alive.
+	 */
+	unsigned long int delta_jiffies;
+
+	/**
+	 * Non-zero when the NA has ceased to accelerate the given connection.
+	 */
+	uint8_t final_sync;
+
+	uint8_t evicted;	/**< Non-zero if the connection is evicted. */
+
+	uint8_t flags;		/**< Flags indicating the status of the flow. */
+	uint32_t qos_tag;	/**< QoS value of the flow. */
+};
+
+/**
+ * nss_ipv6_establish
+ *	Defines connection-established message parameters for IPv6.
+ */
+struct nss_ipv6_establish {
+	uint32_t index;		/**< Slot ID for cache statistics to the host OS. */
+	uint8_t protocol;	/**< Protocol number. */
+	int32_t flow_interface;	/**< Flow interface number. */
+	uint32_t flow_mtu;	/**< MTU for the flow interface. */
+	uint32_t flow_ip[4];	/**< Flow IP address. */
+	uint32_t flow_ident;	/**< Flow identifier (e.g., port). */
+	uint16_t flow_mac[3];	/**< Source MAC address for the flow direction. */
+	uint32_t flow_pppoe_if_exist;	/**< Flow direction: PPPoE interface existence flag. */
+	int32_t flow_pppoe_if_num;	/**< Flow direction: PPPoE interface number. */
+	uint16_t ingress_vlan_tag;	/**< Ingress VLAN tag. */
+	int32_t return_interface;	/**< Return interface number. */
+	uint32_t return_mtu;		/**< MTU for the return interface. */
+	uint32_t return_ip[4];		/**< Return IP address. */
+	uint32_t return_ident;		/**< Return identier (e.g., port). */
+	uint16_t return_mac[3];		/**< Source MAC address for the return direction. */
+	uint32_t return_pppoe_if_exist;	/**< Return direction: PPPoE interface existence flag. */
+	int32_t return_pppoe_if_num;	/**< Return direction: PPPoE interface number. */
+	uint16_t egress_vlan_tag;	/**< VLAN tag to be inserted for egress direction. */
+	uint8_t flags;			/**< Flags indicating the status of the flow. */
+	uint32_t qos_tag;		/**< QoS value of the flow. */
+};
+
+/**
+ * nss_ipv6_cb_reason
+ *	Reasons for an IPv6 callback.
+ */
+enum nss_ipv6_cb_reason {
+	NSS_IPV6_CB_REASON_ESTABLISH = 0,
+	NSS_IPV6_CB_REASON_SYNC,
+	NSS_IPV6_CB_REASON_ESTABLISH_FAIL,
+};
+
+/**
+ * nss_ipv6_cb_params
+ *	Message parameters for an IPv6 callback.
+ */
+struct nss_ipv6_cb_params {
+	enum nss_ipv6_cb_reason reason;		/**< Reason for the callback. */
+
+	/**
+	 * Message parameters for an IPv6 callback.
+	 */
+	union {
+		struct nss_ipv6_sync sync;
+				/**< Parameters for synchronization. */
+		struct nss_ipv6_establish establish;
+				/**< Parameters for establishing a connection. */
+	} params;		/**< Callback parameters. */
+};
+
 /*
  * General utilities
  */
@@ -308,6 +797,16 @@
 typedef void (*nss_if_rx_msg_callback_t)(void *app_data, struct nss_cmn_msg *msg);
 
 /**
+ * Callback function for IPv4 connection synchronization messages.
+ *
+ * @datatypes
+ * nss_ipv4_cb_params
+ *
+ * @param[in] nicb  Pointer to the parameter structure for an NSS IPv4 callback.
+ */
+typedef void (*nss_ipv4_callback_t)(struct nss_ipv4_cb_params *nicb);
+
+/**
  * nss_get_state
  *	Gets the NSS state.
  *
--- a/exports/nss_c2c_rx.h
+++ b/exports/nss_c2c_rx.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -36,7 +36,7 @@ enum nss_c2c_rx_stats_types {
 						/**< Number of received simple pbufs. */
 	NSS_C2C_RX_STATS_PBUF_SG,		/**< Number of scatter-gather pbufs received. */
 	NSS_C2C_RX_STATS_PBUF_RETURNING,	/**< Number of returning scatter-gather pbufs. */
-	NSS_C2C_RX_STATS_INVAL_DEST,		/**< Number of pbuf enqueue failures because destination is invalid. */
+	NSS_C2C_RX_STATS_INVAL_DEST,		/**< Number of pbuf enqueue failures because of destination is invalid. */
 	NSS_C2C_RX_STATS_MAX,			/**< Maximum message type. */
 };
 
--- a/exports/nss_c2c_tx.h
+++ b/exports/nss_c2c_tx.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -72,9 +72,9 @@ enum nss_c2c_tx_test_type {
  */
 enum nss_c2c_tx_stats_types {
 	NSS_C2C_TX_STATS_PBUF_SIMPLE = NSS_STATS_NODE_MAX,
-						/**< Number of received simple pbufs. */
-	NSS_C2C_TX_STATS_PBUF_SG,		/**< Number of scatter-gather pbufs received. */
-	NSS_C2C_TX_STATS_PBUF_RETURNING,	/**< Number of returning scatter-gather pbufs. */
+						/**< Number of received simple pbuf. */
+	NSS_C2C_TX_STATS_PBUF_SG,		/**< Number of scatter-gather pbuf received. */
+	NSS_C2C_TX_STATS_PBUF_RETURNING,	/**< Number of returning scatter-gather pbuf. */
 	NSS_C2C_TX_STATS_MAX,			/**< Maximum message type. */
 };
 
--- a/exports/nss_capwap.h
+++ b/exports/nss_capwap.h
@@ -1,12 +1,9 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022-2023 Qualcomm Innovation Center, Inc. All rights reserved.
- *
+ * Copyright (c) 2014-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
- *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -94,7 +91,6 @@ typedef enum nss_capwap_msg_type {
 	NSS_CAPWAP_MSG_TYPE_DTLS,
 	NSS_CAPWAP_MSG_TYPE_FLOW_RULE_ADD,
 	NSS_CAPWAP_MSG_TYPE_FLOW_RULE_DEL,
-	NSS_CAPWAP_MSG_TYPE_UPDATE_VP_NUM,
 	NSS_CAPWAP_MSG_TYPE_MAX,
 } nss_capwap_msg_type_t;
 
@@ -119,10 +115,6 @@ typedef enum nss_capwap_msg_response {
 	NSS_CAPWAP_ERROR_MSG_FLOW_TABLE_FULL,
 	NSS_CAPWAP_ERROR_MSG_FLOW_EXIST,
 	NSS_CAPWAP_ERROR_MSG_FLOW_NOT_EXIST,
-	NSS_CAPWAP_ERROR_MSG_INVALID_INTERFACE,
-	NSS_CAPWAP_ERROR_MSG_UPDATE_VP_NUM_FAILED,
-	NSS_CAPWAP_ERROR_MSG_DELETE_VP_NUM_FAILED,
-	NSS_CAPWAP_ERROR_MSG_INVALID_NEXT_NODE,
 	NSS_CAPWAP_ERROR_MSG_MAX,
 } nss_capwap_msg_response_t;
 
@@ -147,8 +139,8 @@ struct nss_capwap_stats_msg {
 
 	uint32_t rx_frag_timeout_drops;
 			/**< Packets dropped because of a reassembly timeout. */
-	uint32_t rx_n2h_drops;
-			/**< Packets dropped because of error in packet processing. */
+	uint32_t rx_queue_full_drops;
+			/**< Packets dropped because the queue is full. */
 	uint32_t rx_n2h_queue_full_drops;
 			/**< Packets dropped because the NSS-to-host queue is full. */
 	uint32_t rx_csum_drops;
@@ -306,22 +298,6 @@ struct nss_capwap_flow_rule_msg {
 };
 
 /**
- * nss_capwap_enable_tunnel_msg
- *	Structure to update sibling interface number.
- */
-struct nss_capwap_enable_tunnel_msg {
-	uint32_t sibling_if_num; /**< Sibling interface number. */
-};
-
-/**
- * nss_capwap_update_vp_num_msg
- *	Structure to update the VP number associated with the tunnel.
- */
-struct nss_capwap_update_vp_num_msg {
-	 int16_t vp_num; /**< VP number associated with the tunnel. */
-};
-
-/**
  * nss_capwap_msg
  *	Data for sending and receiving CAPWAP messages.
  */
@@ -346,10 +322,6 @@ struct nss_capwap_msg {
 				/**< Flow rule add message. */
 		struct nss_capwap_flow_rule_msg flow_rule_del;
 				/**< Flow rule delete message. */
-		struct nss_capwap_enable_tunnel_msg enable_tunnel;
-				/**< Enable tunnel message. */
-		struct nss_capwap_update_vp_num_msg update_vp_num;
-				/**< Update VP number message. */
 	} msg;			/**< Message payload. */
 };
 
@@ -386,8 +358,8 @@ struct nss_capwap_tunnel_stats {
 
 	uint64_t rx_frag_timeout_drops;
 			/**< Packets dropped because of a reassembly timeout. */
-	uint64_t rx_n2h_drops;
-			/**< Packets dropped because of error in processing the packet. */
+	uint64_t rx_queue_full_drops;
+			/**< Packets dropped because the queue is full. */
 	uint64_t rx_n2h_queue_full_drops;
 			/**< Packets dropped because the NSS-to-host queue is full. */
 	uint64_t rx_csum_drops;
@@ -402,7 +374,6 @@ struct nss_capwap_tunnel_stats {
 	/*
 	 * Tx/encap stats
 	 */
-	uint64_t tx_dropped_inner;	/**<Packets dropped due to inflow queue full. */
 	uint64_t tx_segments;		/**< Number of segments or fragments. */
 	uint64_t tx_queue_full_drops;
 			/**< Packets dropped because the queue is full. */
--- a/exports/nss_clmap.h
+++ b/exports/nss_clmap.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -68,50 +68,6 @@ typedef enum nss_clmap_error_types {
 } nss_clmap_error_t;
 
 /**
- * nss_clmap_interface_type
- *	Client map NSS interface type.
- */
-enum nss_clmap_interface_type {
-	NSS_CLMAP_INTERFACE_TYPE_US,
-	NSS_CLMAP_INTERFACE_TYPE_DS,
-	NSS_CLMAP_INTERFACE_TYPE_MAX
-};
-
-/**
- * nss_clmap_stats_type
- *	Client map statistic counters.
- */
-enum nss_clmap_stats_type {
-	NSS_CLMAP_INTERFACE_STATS_RX_PKTS,			/**< Number of packets received. */
-	NSS_CLMAP_INTERFACE_STATS_RX_BYTES,			/**< Number of bytes received. */
-	NSS_CLMAP_INTERFACE_STATS_TX_PKTS,			/**< Number of packets transmitted. */
-	NSS_CLMAP_INTERFACE_STATS_TX_BYTES,			/**< Number of bytes transmitted. */
-	NSS_CLMAP_INTERFACE_STATS_RX_QUEUE_0_DROPPED,		/**< Dropped receive packets 0. */
-	NSS_CLMAP_INTERFACE_STATS_RX_QUEUE_1_DROPPED,		/**< Dropped receive packets 1. */
-	NSS_CLMAP_INTERFACE_STATS_RX_QUEUE_2_DROPPED,		/**< Dropped receive packets 2. */
-	NSS_CLMAP_INTERFACE_STATS_RX_QUEUE_3_DROPPED,		/**< Dropped receive packets 3. */
-	NSS_CLMAP_INTERFACE_STATS_DROPPED_MACDB_LOOKUP_FAILED,	/**< Dropped due to MAC database look up failed. */
-	NSS_CLMAP_INTERFACE_STATS_DROPPED_INVALID_PACKET_SIZE,	/**< Dropped due to invalid size packets. */
-	NSS_CLMAP_INTERFACE_STATS_DROPPED_LOW_HEADROOM,		/**< Dropped due to insufficent headroom. */
-	NSS_CLMAP_INTERFACE_STATS_DROPPED_NEXT_NODE_QUEUE_FULL,	/**< Dropped due to next node queue full. */
-	NSS_CLMAP_INTERFACE_STATS_DROPPED_PBUF_ALLOC_FAILED,	/**< Dropped due to buffer allocation failure. */
-	NSS_CLMAP_INTERFACE_STATS_DROPPED_LINEAR_FAILED,	/**< Dropped due to linear copy failure. */
-	NSS_CLMAP_INTERFACE_STATS_SHARED_PACKET_CNT,		/**< Shared packet count. */
-	NSS_CLMAP_INTERFACE_STATS_ETHERNET_FRAME_ERROR,		/**< Ethernet frame error count. */
-	NSS_CLMAP_INTERFACE_STATS_MACDB_CREATE_REQUESTS_CNT,	/**< MAC database create requests count. */
-	NSS_CLMAP_INTERFACE_STATS_MACDB_CREATE_MAC_EXISTS_CNT,	/**< MAC database create failures, MAC exist count. */
-	NSS_CLMAP_INTERFACE_STATS_MACDB_CREATE_MAC_TABLE_FULL_CNT,
-								/**< MAC database create failures, MAC database full count. */
-	NSS_CLMAP_INTERFACE_STATS_MACDB_DESTROY_REQUESTS_CNT,	/**< MAC database destroy requests count. */
-	NSS_CLMAP_INTERFACE_STATS_MACDB_DESTROY_MAC_NOT_FOUND_CNT,
-								/**< MAC database destroy failures, MAC not found count. */
-	NSS_CLMAP_INTERFACE_STATS_MACDB_DESTROY_MAC_UNHASHED_CNT,
-								/**< MAC database destroy failures, MAC unhashed count. */
-	NSS_CLMAP_INTERFACE_STATS_MACDB_FLUSH_REQUESTS_CNT,	/**< MAC database flush requests count. */
-	NSS_CLMAP_INTERFACE_STATS_MAX,				/**< Maximum statistics type. */
-};
-
-/**
  * nss_clmap_stats_msg
  *	Per-interface statistics messages from the NSS firmware.
  */
@@ -156,16 +112,6 @@ struct nss_clmap_flush_mac_msg {
 };
 
 /**
- * nss_clmap_stats_notification
- *	Client map transmission statistics structure.
- */
-struct nss_clmap_stats_notification {
-	uint64_t stats_ctx[NSS_CLMAP_INTERFACE_STATS_MAX];	/**< Context transmission statistics. */
-	uint32_t core_id;					/**< Core ID. */
-	uint32_t if_num;					/**< Interface number. */
-};
-
-/**
  * nss_clmap_msg
  *	Data for sending and receiving client map messages.
  */
@@ -356,34 +302,6 @@ extern void nss_clmap_msg_init(struct ns
 								nss_clmap_msg_callback_t cb, void *app_data);
 
 /**
- * nss_clmap_stats_unregister_notifier
- *	Deregisters a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_clmap_stats_unregister_notifier(struct notifier_block *nb);
-
-/**
- * nss_clmap_stats_register_notifier
- *	Registers a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_clmap_stats_register_notifier(struct notifier_block *nb);
-
-/**
  * @}
  */
 
--- a/exports/nss_cmn.h
+++ b/exports/nss_cmn.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014, 2016-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014, 2016-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -27,12 +27,10 @@
  * @{
  */
 
-/**
+/*
  * Interface Number 1 Valid 7 Core 8 Type 16 Index
  */
 typedef int32_t nss_if_num_t;
-#define NSS_IF_IS_TYPE_DYNAMIC(if_num)		(if_num != -1)
-#define NSS_IF_IS_VALID(if_num)		(if_num < NSS_MAX_NET_INTERFACES)
 
 /**
  * @struct nss_ctx_instance
--- a/exports/nss_dma.h
+++ b/exports/nss_dma.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
@@ -53,43 +53,6 @@ enum nss_dma_msg_error {
 };
 
 /**
- * nss_dma_stats_types
- *	DMA node statistics.
- */
-enum nss_dma_stats_types {
-	NSS_DMA_STATS_NO_REQ = NSS_STATS_NODE_MAX,
-					/**< Request descriptor not available. */
-	NSS_DMA_STATS_NO_DESC,		/**< DMA descriptors not available. */
-	NSS_DMA_STATS_NEXTHOP,		/**< Failed to retrive next hop. */
-	NSS_DMA_STATS_FAIL_NEXTHOP_QUEUE,
-					/**< Failed to queue next hop. */
-	NSS_DMA_STATS_FAIL_LINEAR_SZ,	/**< Failed to get memory for linearization. */
-	NSS_DMA_STATS_FAIL_LINEAR_ALLOC,/**< Failed to allocate buffer for linearization. */
-	NSS_DMA_STATS_FAIL_LINEAR_NO_SG,/**< Skip linearization due to non-SG packet. */
-	NSS_DMA_STATS_FAIL_SPLIT_SZ,	/**< Failed to spliting buffer into multiple buffers. */
-	NSS_DMA_STATS_FAIL_SPLIT_ALLOC,	/**< Failed to allocate buffer for split. */
-	NSS_DMA_STATS_FAIL_SYNC_ALLOC,	/**< Failed to allocate buffer for sending statistics. */
-	NSS_DMA_STATS_FAIL_CTX_ACTIVE,	/**< Failed to queue as the node is not active. */
-	NSS_DMA_STATS_FAIL_HW_E0,	/**< Failed to process in hardware, error code E0. */
-	NSS_DMA_STATS_FAIL_HW_E1,	/**< Failed to process in hardware, error code E1. */
-	NSS_DMA_STATS_FAIL_HW_E2,	/**< Failed to process in hardware, error code E2. */
-	NSS_DMA_STATS_FAIL_HW_E3,	/**< Failed to process in hardware, error code E3. */
-	NSS_DMA_STATS_FAIL_HW_E4,	/**< Failed to process in hardware, error code E4. */
-	NSS_DMA_STATS_FAIL_HW_E5,	/**< Failed to process in hardware, error code E5. */
-	NSS_DMA_STATS_FAIL_HW_E6,	/**< Failed to process in hardware, error code E6. */
-	NSS_DMA_STATS_FAIL_HW_E7,	/**< Failed to process in hardware, error code E7. */
-	NSS_DMA_STATS_FAIL_HW_E8,	/**< Failed to process in hardware, error code E8. */
-	NSS_DMA_STATS_FAIL_HW_E9,	/**< Failed to process in hardware, error code E9. */
-	NSS_DMA_STATS_FAIL_HW_E10,	/**< Failed to process in hardware, error code E10. */
-	NSS_DMA_STATS_FAIL_HW_E11,	/**< Failed to process in hardware, error code E11. */
-	NSS_DMA_STATS_FAIL_HW_E12,	/**< Failed to process in hardware, error code E12. */
-	NSS_DMA_STATS_FAIL_HW_E13,	/**< Failed to process in hardware, error code E13. */
-	NSS_DMA_STATS_FAIL_HW_E14,	/**< Failed to process in hardware, error code E14. */
-	NSS_DMA_STATS_FAIL_HW_E15,	/**< Failed to process in hardware, error code E15. */
-	NSS_DMA_STATS_MAX,		/**< Maximum message type. */
-};
-
-/**
  * nss_dma_test_type
  *	DMA Test types.
  */
@@ -101,15 +64,6 @@ enum nss_dma_test_type {
 	NSS_DMA_TEST_TYPE_MAX			/**< Maximum test type. */
 };
 
-/**
- * nss_dma_stats_notification
- *	DMA transmission statistics structure.
- */
-struct nss_dma_stats_notification {
-	uint64_t stats_ctx[NSS_DMA_STATS_MAX];		/**< Context transmission statistics. */
-	uint32_t core_id;				/**< Core ID. */
-};
-
 #ifdef __KERNEL__ /* only kernel will use. */
 /*
  * Maximum number of HW specific statistics
@@ -175,6 +129,11 @@ struct nss_dma_msg {
  * nss_dma_register_handler
  *	Registers the DMA message handler.
  *
+ * @datatypes
+ * nss_ctx_instance
+ *
+ * @param[in] nss_ctx  Pointer to the NSS context.
+ *
  * @return
  * None.
  */
@@ -296,34 +255,6 @@ void nss_dma_init(void);
  * Pointer to the NSS core context.
  */
 extern struct nss_ctx_instance *nss_dma_get_context(void);
-
-/**
- * nss_dma_stats_unregister_notifier
- *	Deregisters a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_dma_stats_unregister_notifier(struct notifier_block *nb);
-
-/**
- * nss_dma_stats_register_notifier
- *	Registers a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_dma_stats_register_notifier(struct notifier_block *nb);
 #endif /*__KERNEL__ */
 
 /**
--- a/exports/nss_dtls_cmn.h
+++ b/exports/nss_dtls_cmn.h
@@ -1,12 +1,9 @@
 /*
  **************************************************************************
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
- *
+ * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
- *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -52,7 +49,6 @@ enum nss_dtls_cmn_msg_type {
 	NSS_DTLS_CMN_MSG_TYPE_DECONFIGURE,	/**< Deconfigure context. */
 	NSS_DTLS_CMN_MSG_TYPE_SYNC_STATS,	/**< Synchronize statistics. */
 	NSS_DTLS_CMN_MSG_TYPE_NODE_STATS,	/**< Node statistics. */
-	NSS_DTLS_CMN_MSG_TYPE_UPDATE_VP,	/**< Update node to vp ifnum mapping. */
 	NSS_DTLS_CMN_MSG_MAX
 };
 
@@ -75,91 +71,10 @@ enum nss_dtls_cmn_error {
 	NSS_DTLS_CMN_ERROR_ALREADY_CONFIGURED,
 	NSS_DTLS_CMN_ERROR_FAIL_NOMEM,
 	NSS_DTLS_CMN_ERROR_FAIL_COPY_NONCE,
-	NSS_DTLS_CMN_ERROR_FAIL_UPDATE_VP,
-	NSS_DTLS_CMN_ERROR_FAIL_DESTROY_VP,
 	NSS_DTLS_CMN_ERROR_MAX,
 };
 
 /**
- * nss_dtls_cmn_ctx_stats_types
- *	DTLS common context statistics types.
- */
-enum nss_dtls_cmn_ctx_stats_types {
-	NSS_DTLS_CMN_STATS_RX_SINGLE_REC = NSS_STATS_NODE_MAX,
-						/**< Received single DTLS record datagrams. */
-	NSS_DTLS_CMN_STATS_RX_MULTI_REC,	/**< Received multiple DTLS record datagrams. */
-	NSS_DTLS_CMN_STATS_FAIL_CRYPTO_RESOURCE,/**< Failure in crypto resource allocation. */
-	NSS_DTLS_CMN_STATS_FAIL_CRYPTO_ENQUEUE,	/**< Failure due to full queue in crypto or hardware. */
-	NSS_DTLS_CMN_STATS_FAIL_HEADROOM,	/**< Failure in headroom check. */
-	NSS_DTLS_CMN_STATS_FAIL_TAILROOM,	/**< Failure in tailroom check. */
-	NSS_DTLS_CMN_STATS_FAIL_VER,		/**< Failure in DTLS version check. */
-	NSS_DTLS_CMN_STATS_FAIL_EPOCH,		/**< Failure in DTLS epoch check. */
-	NSS_DTLS_CMN_STATS_FAIL_DTLS_RECORD,	/**< Failure in reading DTLS record. */
-	NSS_DTLS_CMN_STATS_FAIL_CAPWAP,		/**< Failure in CAPWAP classification. */
-	NSS_DTLS_CMN_STATS_FAIL_REPLAY,		/**< Failure in anti-replay check. */
-	NSS_DTLS_CMN_STATS_FAIL_REPLAY_DUP,	/**< Failure in anti-replay; duplicate records. */
-	NSS_DTLS_CMN_STATS_FAIL_REPLAY_WIN,	/**< Failure in anti-replay; packet outside the window. */
-	NSS_DTLS_CMN_STATS_FAIL_QUEUE,		/**< Failure due to full queue in DTLS. */
-	NSS_DTLS_CMN_STATS_FAIL_QUEUE_NEXTHOP,	/**< Failure due to full queue in next hop. */
-	NSS_DTLS_CMN_STATS_FAIL_PBUF_ALLOC,	/**< Failure in pbuf allocation. */
-	NSS_DTLS_CMN_STATS_FAIL_PBUF_LINEAR,	/**< Failure in pbuf linearization. */
-	NSS_DTLS_CMN_STATS_FAIL_PBUF_STATS,	/**< Failure in pbuf allocation for statistics. */
-	NSS_DTLS_CMN_STATS_FAIL_PBUF_ALIGN,	/**< Failure in pbuf alignment. */
-	NSS_DTLS_CMN_STATS_FAIL_CTX_ACTIVE,	/**< Failure in enqueue due to inactive context. */
-	NSS_DTLS_CMN_STATS_FAIL_HWCTX_ACTIVE,	/**< Failure in enqueue due to inactive hardware context. */
-	NSS_DTLS_CMN_STATS_FAIL_CIPHER,		/**< Failure in decrypting the data. */
-	NSS_DTLS_CMN_STATS_FAIL_AUTH,		/**< Failure in authenticating the data. */
-	NSS_DTLS_CMN_STATS_FAIL_SEQ_OVF,	/**< Failure due to sequence number overflow. */
-	NSS_DTLS_CMN_STATS_FAIL_BLK_LEN,	/**< Failure in decapsulation due to bad cipher length. */
-	NSS_DTLS_CMN_STATS_FAIL_HASH_LEN,	/**< Failure in decapsulation due to bad hash length. */
-	NSS_DTLS_CMN_STATS_LEN_ERROR,		/**< Length error. */
-	NSS_DTLS_CMN_STATS_TOKEN_ERROR,		/**< Token error, unknown token command or instruction. */
-	NSS_DTLS_CMN_STATS_BYPASS_ERROR,	/**< Token contains too much bypass data. */
-	NSS_DTLS_CMN_STATS_CONFIG_ERROR,	/**< Invalid command, algorithm, or mode combination. */
-	NSS_DTLS_CMN_STATS_ALGO_ERROR,		/**< Unsupported algorithm. */
-	NSS_DTLS_CMN_STATS_HASH_OVF_ERROR,	/**< Hash input overflow. */
-	NSS_DTLS_CMN_STATS_TTL_ERROR,		/**< TTL or HOP-Limit underflow. */
-	NSS_DTLS_CMN_STATS_CSUM_ERROR,		/**< Checksum error. */
-	NSS_DTLS_CMN_STATS_TIMEOUT_ERROR,	/**< Data timed out. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_0,		/**< Classification failure 0. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_1,		/**< Classification failure 1. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_2,		/**< Classification failure 2. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_3,		/**< Classification failure 3. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_4,		/**< Classification failure 4. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_5,		/**< Classification failure 5. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_6,		/**< Classification failure 6. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_7,		/**< Classification failure 7. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_8,		/**< Classification failure 8. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_9,		/**< Classification failure 9. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_10,	/**< Classification failure 10. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_11,	/**< Classification failure 11. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_12,	/**< Classification failure 12. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_13,	/**< Classification failure 13. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_14,	/**< Classification failure 14. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_15,	/**< Classification failure 15. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_16,	/**< Classification failure 16. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_17,	/**< Classification failure 17. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_18,	/**< Classification failure 18. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_19,	/**< Classification failure 19. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_20,	/**< Classification failure 20. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_21,	/**< Classification failure 21. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_22,	/**< Classification failure 22. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_23,	/**< Classification failure 23. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_24,	/**< Classification failure 24. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_25,	/**< Classification failure 25. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_26,	/**< Classification failure 26. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_27,	/**< Classification failure 27. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_28,	/**< Classification failure 28. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_29,	/**< Classification failure 29. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_30,	/**< Classification failure 30. */
-	NSS_DTLS_CMN_STATS_CLE_ERROR_31,	/**< Classification failure 31. */
-	NSS_DTLS_CMN_STATS_SEQ_LOW,		/**< Lower 32 bits of current transmit sequence number. */
-	NSS_DTLS_CMN_STATS_SEQ_HIGH,		/**< Upper 16 bits of current transmit sequence number. */
-	NSS_DTLS_CMN_STATS_EPOCH,		/**< Current epoch value. */
-	NSS_DTLS_CMN_CTX_STATS_MAX,		/**< Maximum message type. */
-};
-
-/**
  * nss_dtls_cmn_node_stats
  * 	DTLS node statistics.
  */
@@ -269,24 +184,6 @@ struct nss_dtls_cmn_ctx_config_dtls {
 };
 
 /**
- * nss_dtls_cmn_stats_notification
- *	DTLS common transmission statistics structure.
- */
-struct nss_dtls_cmn_stats_notification {
-	uint64_t stats_ctx[NSS_DTLS_CMN_CTX_STATS_MAX];		/**< Context transmission statistics. */
-	uint32_t core_id;					/**< Core ID. */
-	uint32_t if_num;					/**< Interface number. */
-};
-
-/**
- * nss_dtls_cmn_update_vp_num_msg
- *	Update mapping between dtls node to vp number.
- */
-struct nss_dtls_cmn_update_vp_num {
-	int16_t vp_num;						/**< VP number associated with the tunnel. */
-};
-
-/**
  * nss_dtls_cmn_msg
  *	Data for sending and receiving DTLS messages.
  */
@@ -301,7 +198,6 @@ struct nss_dtls_cmn_msg {
 		struct nss_dtls_cmn_ctx_config_dtls dtls_cfg;	/**< Cipher update information. */
 		struct nss_dtls_cmn_ctx_stats stats;		/**< Session statistics. */
 		struct nss_dtls_cmn_node_stats node_stats;	/**< Node statistics. */
-		struct nss_dtls_cmn_update_vp_num update_vp;	/**< Update the VP number and Pnode mapping. */
 	} msg;			/**< Message payload for DTLS session messages exchanged with NSS core. */
 };
 
@@ -385,20 +281,6 @@ extern nss_tx_status_t nss_dtls_cmn_tx_m
 						struct nss_dtls_cmn_msg *ndcm, enum nss_dtls_cmn_error *resp);
 
 /**
- * nss_dtls_cmn_unregister_if
- *	Deregisters a DTLS session interface from the NSS.
- *
- * @param[in] if_num  NSS interface number.
- *
- * @return
- * None.
- *
- * @dependencies
- * The DTLS session interface must have been previously registered.
- */
-extern void nss_dtls_cmn_unregister_if(uint32_t if_num);
-
-/**
  * nss_dtls_cmn_register_if
  *	Registers a DTLS session interface with the NSS for sending and receiving
  *	messages.
@@ -427,19 +309,22 @@ extern struct nss_ctx_instance *nss_dtls
 							 void *app_ctx);
 
 /**
- * nss_dtls_cmn_notify_unregister
- *	Deregisters an event callback.
+ * nss_dtls_cmn_unregister_if
+ *	Deregisters a DTLS session interface from the NSS.
  *
- * @param[in] ifnum  NSS interface number.
+ * @param[in] if_num  NSS interface number.
  *
  * @return
  * None.
+ *
+ * @dependencies
+ * The DTLS session interface must have been previously registered.
  */
-extern void nss_dtls_cmn_notify_unregister(uint32_t ifnum);
+extern void nss_dtls_cmn_unregister_if(uint32_t if_num);
 
 /**
  * nss_dtls_cmn_notify_register
- *	Registers an event callback to handle notification from DTLS firmware package.
+ *	Register an event callback to handle notification from DTLS firmware package.
  *
  * @param[in] ifnum     NSS interface number.
  * @param[in] ev_cb     Callback for DTLS tunnel message.
@@ -452,6 +337,17 @@ extern struct nss_ctx_instance *nss_dtls
 							     void *app_data);
 
 /**
+ * nss_dtls_cmn_notify_unregister
+ *	Unregister an event callback.
+ *
+ * @param[in] ifnum  NSS interface number.
+ *
+ * @return
+ * None.
+ */
+extern void nss_dtls_cmn_notify_unregister(uint32_t ifnum);
+
+/**
  * nss_dtls_cmn_msg_init
  *	Initializes a DTLS message.
  *
@@ -492,34 +388,6 @@ extern struct nss_ctx_instance *nss_dtls
 extern int32_t nss_dtls_cmn_get_ifnum(int32_t if_num);
 
 /**
- * nss_dtls_cmn_stats_unregister_notifier
- *	Deregisters a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_dtls_cmn_stats_unregister_notifier(struct notifier_block *nb);
-
-/**
- * nss_dtls_cmn_stats_register_notifier
- *	Registers a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_dtls_cmn_stats_register_notifier(struct notifier_block *nb);
-
-/**
  * @}
  */
 
--- a/exports/nss_dynamic_interface.h
+++ b/exports/nss_dynamic_interface.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -22,6 +22,8 @@
 #ifndef __NSS_DYNAMIC_INTERFACE_H
 #define __NSS_DYNAMIC_INTERFACE_H
 
+#include "nss_fw_version.h"
+
 /**
  * @addtogroup nss_dynamic_interface_subsystem
  * @{
@@ -40,10 +42,10 @@
 enum nss_dynamic_interface_type {
 	NSS_DYNAMIC_INTERFACE_TYPE_NONE,
 	NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR,
-	NSS_DYNAMIC_INTERFACE_TYPE_RESERVED_5,
+	NSS_DYNAMIC_INTERFACE_TYPE_CAPWAP,
 	NSS_DYNAMIC_INTERFACE_TYPE_TUNIPIP6_INNER,
 	NSS_DYNAMIC_INTERFACE_TYPE_TUNIPIP6_OUTER,
-	NSS_DYNAMIC_INTERFACE_TYPE_RESERVED,
+	NSS_DYNAMIC_INTERFACE_TYPE_WIFI,
 	NSS_DYNAMIC_INTERFACE_TYPE_VAP,
 	NSS_DYNAMIC_INTERFACE_TYPE_RESERVED_0,
 	NSS_DYNAMIC_INTERFACE_TYPE_PPPOE,
@@ -57,7 +59,11 @@ enum nss_dynamic_interface_type {
 	NSS_DYNAMIC_INTERFACE_TYPE_BRIDGE,
 	NSS_DYNAMIC_INTERFACE_TYPE_VLAN,
 	NSS_DYNAMIC_INTERFACE_TYPE_RESERVED_3,
+#if (NSS_FW_VERSION_CODE <= NSS_FW_VERSION(11,0))
+	NSS_DYNAMIC_INTERFACE_TYPE_WIFILI,
+#else
 	NSS_DYNAMIC_INTERFACE_TYPE_WIFILI_INTERNAL,
+#endif
 	NSS_DYNAMIC_INTERFACE_TYPE_MAP_T_INNER,
 	NSS_DYNAMIC_INTERFACE_TYPE_MAP_T_OUTER,
 	NSS_DYNAMIC_INTERFACE_TYPE_GRE_TUNNEL_INNER,
@@ -94,22 +100,20 @@ enum nss_dynamic_interface_type {
 	NSS_DYNAMIC_INTERFACE_TYPE_IGS,
 	NSS_DYNAMIC_INTERFACE_TYPE_CLMAP_US,
 	NSS_DYNAMIC_INTERFACE_TYPE_CLMAP_DS,
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,0))
 	NSS_DYNAMIC_INTERFACE_TYPE_VXLAN_INNER,
 	NSS_DYNAMIC_INTERFACE_TYPE_VXLAN_OUTER,
 	NSS_DYNAMIC_INTERFACE_TYPE_MATCH,
+#endif
 	NSS_DYNAMIC_INTERFACE_TYPE_RMNET_RX_N2H,
 	NSS_DYNAMIC_INTERFACE_TYPE_RMNET_RX_H2N,
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,0))
 	NSS_DYNAMIC_INTERFACE_TYPE_WIFILI_EXTERNAL0,
 	NSS_DYNAMIC_INTERFACE_TYPE_WIFILI_EXTERNAL1,
 	NSS_DYNAMIC_INTERFACE_TYPE_TLS_INNER,
 	NSS_DYNAMIC_INTERFACE_TYPE_TLS_OUTER,
 	NSS_DYNAMIC_INTERFACE_TYPE_MIRROR,
-	NSS_DYNAMIC_INTERFACE_TYPE_WIFI_EXT_VDEV_WDS,
-	NSS_DYNAMIC_INTERFACE_TYPE_CAPWAP_HOST_INNER,
-	NSS_DYNAMIC_INTERFACE_TYPE_CAPWAP_OUTER,
-	NSS_DYNAMIC_INTERFACE_TYPE_WIFI_EXT_VDEV_VLAN,
-	NSS_DYNAMIC_INTERFACE_TYPE_WIFI_MESH_INNER,
-	NSS_DYNAMIC_INTERFACE_TYPE_WIFI_MESH_OUTER,
+#endif
 	NSS_DYNAMIC_INTERFACE_TYPE_MAX
 };
 
--- a/exports/nss_edma.h
+++ b/exports/nss_edma.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -84,7 +84,6 @@ enum nss_edma_stats_rx_t {
 	NSS_EDMA_STATS_RX_DESC,
 	NSS_EDMA_STATS_RX_QOS_ERR,
 	NSS_EDMA_STATS_RX_SRC_PORT_INVALID,
-	NSS_EDMA_STATS_RX_SRC_IF_INVALID,
 	NSS_EDMA_STATS_RX_MAX
 };
 
@@ -144,7 +143,6 @@ struct nss_edma_rx_ring_stats {
 	uint32_t desc_cnt;		/**< Number of descriptors processed. */
 	uint32_t qos_err;		/**< Number of QoS errors. */
 	uint32_t rx_src_port_invalid;	/**< Number of source port invalid errors. */
-	uint32_t rx_src_if_invalid;	/**< Number of source interface invalid errors. */
 };
 
 /**
@@ -330,7 +328,7 @@ extern void nss_edma_notify_unregister(v
  * nss_edma_get_stats
  *	Sends EDMA statistics to NSS clients.
  *
- * @param[in] stats	EDMA statistics to be sent to netlink.
+ * @param[in] stats	EDMA statistics to be sent to Netlink.
  * @param[in] port_id	EDMA port ID.
  *
  * @return
--- /dev/null
+++ b/exports/nss_fw_version.h
@@ -0,0 +1,11 @@
+#ifndef __NSS_FW_VERSION_H
+#define __NSS_FW_VERSION_H
+
+#define NSS_FW_VERSION_MAJOR 11
+#define NSS_FW_VERSION_MINOR 0
+
+#define NSS_FW_VERSION(a,b) (((a) << 8) + (b))
+
+#define NSS_FW_VERSION_CODE NSS_FW_VERSION(NSS_FW_VERSION_MAJOR, NSS_FW_VERSION_MINOR)
+
+#endif /* __NSS_FW_VERSION_H */
--- a/exports/nss_gre.h
+++ b/exports/nss_gre.h
@@ -1,9 +1,6 @@
 /*
- ****************************************************************************
- * Copyright (c) 2017-2019, 2021, The Linux Foundation. All rights reserved.
- *
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
- *
+ **************************************************************************
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -14,7 +11,7 @@
  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
  * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ****************************************************************************
+ **************************************************************************
  */
 
 /**
@@ -104,16 +101,16 @@ enum nss_gre_msg_types {
 };
 
 /**
- * GRE mode types.
+ * GRE Mode Types
  */
 enum nss_gre_mode {
-	NSS_GRE_MODE_TUN,	/**< GRE tunnel interface. */
-	NSS_GRE_MODE_TAP,	/**< GRE TAP interface. */
+	NSS_GRE_MODE_TUN,	/**< GRE Tunnel interface. */
+	NSS_GRE_MODE_TAP,	/**< GRE Tap interface. */
 	NSS_GRE_MODE_MAX	/**< Maxmum GRE mode. */
 };
 
 /**
- * GRE IP types.
+ * GRE IP Types
  */
 enum nss_gre_ip_types {
 	NSS_GRE_IP_IPV4,	/**<  Outer Tunnel is IPV4. */
@@ -122,60 +119,58 @@ enum nss_gre_ip_types {
 };
 
 /**
- * nss_gre_base_types
- *	GRE base debug statistics.
+ * GRE Base debug statistics
  */
-enum nss_gre_base_types {
-	NSS_GRE_BASE_RX_PACKETS,		/**< Receive packet count. */
-	NSS_GRE_BASE_RX_DROPPED,		/**< Number of packet dropped at receive. */
-	NSS_GRE_BASE_EXP_ETH_HDR_MISSING,	/**< Ethernet header missing. */
-	NSS_GRE_BASE_EXP_ETH_TYPE_NON_IP,	/**< Packet is not IPV4 or IPV6. */
-	NSS_GRE_BASE_EXP_IP_UNKNOWN_PROTOCOL,	/**< Packet protocol is unknown. */
-	NSS_GRE_BASE_EXP_IP_HEADER_INCOMPLETE,	/**< Bad IP header. */
-	NSS_GRE_BASE_EXP_IP_BAD_TOTAL_LENGTH,	/**< IP total length is invalid. */
-	NSS_GRE_BASE_EXP_IP_BAD_CHECKSUM,	/**< IP checksum is bad. */
-	NSS_GRE_BASE_EXP_IP_DATAGRAM_INCOMPLETE,/**< Bad packet. */
-	NSS_GRE_BASE_EXP_IP_FRAGMENT,		/**< IP packet is a fragment. */
-	NSS_GRE_BASE_EXP_IP_OPTIONS_INCOMPLETE,	/**< IP option is invalid. */
-	NSS_GRE_BASE_EXP_IP_WITH_OPTIONS,	/**< IP packet with options. */
-	NSS_GRE_BASE_EXP_IPV6_UNKNOWN_PROTOCOL,	/**< Protocol is unknown. */
-	NSS_GRE_BASE_EXP_IPV6_HEADER_INCOMPLETE,/**< Incomplete ipv6 header. */
-	NSS_GRE_BASE_EXP_GRE_UNKNOWN_SESSION,	/**< Unknown GRE session. */
-	NSS_GRE_BASE_EXP_GRE_NODE_INACTIVE,	/**< GRE node is inactive. */
-	NSS_GRE_BASE_DEBUG_MAX,			/**< GRE base debug maximum. */
+enum nss_gre_base_debug_types {
+	GRE_BASE_RX_PACKETS,			/**< Rx packet count. */
+	GRE_BASE_RX_DROPPED,			/**< Number of packet dropped at Rx. */
+	GRE_BASE_EXP_ETH_HDR_MISSING,		/**< Ethernet header missing. */
+	GRE_BASE_EXP_ETH_TYPE_NON_IP,		/**< Packet is not IPV4 or IPV6. */
+	GRE_BASE_EXP_IP_UNKNOWN_PROTOCOL,	/**< Packet protocol is unknown. */
+	GRE_BASE_EXP_IP_HEADER_INCOMPLETE,	/**< Bad IP header. */
+	GRE_BASE_EXP_IP_BAD_TOTAL_LENGTH,	/**< IP total lenghth is invalid. */
+	GRE_BASE_EXP_IP_BAD_CHECKSUM,		/**< IP checksum is bad. */
+	GRE_BASE_EXP_IP_DATAGRAM_INCOMPLETE,	/**< Bad packet. */
+	GRE_BASE_EXP_IP_FRAGMENT,		/**< IP packet is a fragment. */
+	GRE_BASE_EXP_IP_OPTIONS_INCOMPLETE,	/**< IP option is invalid. */
+	GRE_BASE_EXP_IP_WITH_OPTIONS,		/**< IP packet with options. */
+	GRE_BASE_EXP_IPV6_UNKNOWN_PROTOCOL,	/**< Protocol is unknown. */
+	GRE_BASE_EXP_IPV6_HEADER_INCOMPLETE,	/**< Incomplete ipv6 header. */
+	GRE_BASE_EXP_GRE_UNKNOWN_SESSION,	/**< Unknown GRE session. */
+	GRE_BASE_EXP_GRE_NODE_INACTIVE,		/**< GRE node is inactive. */
+	GRE_BASE_DEBUG_MAX,			/**< GRE base debug max. */
 };
 
-/**
- * nss_gre_session_types
- *	GRE session packet drop and exception events.
- */
-enum nss_gre_session_types {
-	NSS_GRE_SESSION_PBUF_ALLOC_FAIL,		/**< Pbuf allocation failure. */
-	NSS_GRE_SESSION_DECAP_FORWARD_ENQUEUE_FAIL,	/**< Receive forward enqueue failure. */
-	NSS_GRE_SESSION_ENCAP_FORWARD_ENQUEUE_FAIL,	/**< Transmit forward enqueue failure. */
-	NSS_GRE_SESSION_DECAP_TX_FORWARDED,		/**< Number of packets forwarded after decapsulation. */
-	NSS_GRE_SESSION_ENCAP_RX_RECEIVED,		/**< Number of packets received for encapsulation. */
-	NSS_GRE_SESSION_ENCAP_RX_DROPPED,		/**< Packets dropped while enqueuing for encapsulation. */
-	NSS_GRE_SESSION_ENCAP_RX_LINEAR_FAIL,		/**< Packets dropped during encapsulation linearization. */
-	NSS_GRE_SESSION_EXP_RX_KEY_ERROR,		/**< Receive key error. */
-	NSS_GRE_SESSION_EXP_RX_SEQ_ERROR,		/**< Receive Sequence number error. */
-	NSS_GRE_SESSION_EXP_RX_CS_ERROR,		/**< Receive checksum error */
-	NSS_GRE_SESSION_EXP_RX_FLAG_MISMATCH,		/**< Receive flag mismatch. */
-	NSS_GRE_SESSION_EXP_RX_MALFORMED,		/**< Receive packet is malformed. */
-	NSS_GRE_SESSION_EXP_RX_INVALID_PROTOCOL,	/**< Receive packet protocol is invalid. */
-	NSS_GRE_SESSION_EXP_RX_NO_HEADROOM,		/**< Packet does not have enough headroom. */
-	NSS_GRE_SESSION_DEBUG_MAX,			/**< Session debug maximum. */
+/*
+ * GRE session Packet drop and exception events.
+ */
+enum gre_session_debug_types {
+	GRE_SESSION_PBUF_ALLOC_FAIL,		/**< Pbuf allocation failure. */
+	GRE_SESSION_DECAP_FORWARD_ENQUEUE_FAIL,	/**< Rx forward enqueue failure. */
+	GRE_SESSION_ENCAP_FORWARD_ENQUEUE_FAIL,	/**< Tx forward enqueue failure. */
+	GRE_SESSION_DECAP_TX_FORWARDED,		/**< Number of packets forwarded after decap. */
+	GRE_SESSION_ENCAP_RX_RECEIVED,		/**< Number of packets received for encap. */
+	GRE_SESSION_ENCAP_RX_DROPPED,		/**< Packets dropped while enqueuing for encap. */
+	GRE_SESSION_ENCAP_RX_LINEAR_FAIL,	/**< Packets dropped during encap linearization. */
+	GRE_SESSION_EXP_RX_KEY_ERROR,		/**< Rx KEY error. */
+	GRE_SESSION_EXP_RX_SEQ_ERROR,		/**< Rx Sequence number error. */
+	GRE_SESSION_EXP_RX_CS_ERROR,		/**< Rx checksum error */
+	GRE_SESSION_EXP_RX_FLAG_MISMATCH,	/**< Rx flag mismatch. */
+	GRE_SESSION_EXP_RX_MALFORMED,		/**< Rx packet is malformed. */
+	GRE_SESSION_EXP_RX_INVALID_PROTOCOL,	/**< Rx packet protocol is invalid. */
+	GRE_SESSION_EXP_RX_NO_HEADROOM,		/**< Packet does not have enough headroom. */
+	GRE_SESSION_DEBUG_MAX,			/**< Session debug max. */
 };
 
 /**
  * GRE create message structure.
  */
 struct nss_gre_config_msg {
-	uint32_t src_ip[4];			/**< Source IPv4 or IPv6 address. */
-	uint32_t dest_ip[4];			/**< Destination IPv4 or IPv6 address. */
+	uint32_t src_ip[4];			/**< Source IPv4 or IPv6 Adddress. */
+	uint32_t dest_ip[4];			/**< Destination IPv4 or IPv6 Adddress. */
 	uint32_t flags;				/**< GRE Flags. */
-	uint32_t ikey;				/**< GRE Rx key.*/
-	uint32_t okey;				/**< GRE Tx key. */
+	uint32_t ikey;				/**< GRE rx KEY.*/
+	uint32_t okey;				/**< GRE tx KEY. */
 	uint32_t mode;				/**< GRE TUN or TAP. */
 	uint32_t ip_type;			/**< IPv4 or IPv6 type. */
 	uint32_t next_node_if_num;		/**< To whom to forward packets. */
@@ -188,7 +183,7 @@ struct nss_gre_config_msg {
 };
 
 /**
- * GRE link up message structure.
+ * GRE link up message structure
  */
 struct nss_gre_linkup_msg {
 	int if_number;			/**< Interface number. */
@@ -205,49 +200,30 @@ struct nss_gre_linkdown_msg {
  * GRE deconfig message structure
  */
 struct nss_gre_deconfig_msg {
-	int if_number;			/**< Interface number. */
+	int if_number;			/**< Interface number */
 };
 
 /**
- * GRE session statistics message.
+ * GRE session statistics message
  */
 struct nss_gre_session_stats_msg {
-	struct nss_cmn_node_stats node_stats;		/**< Common node statistics. */
-	uint32_t stats[NSS_GRE_SESSION_DEBUG_MAX];	/**< Session debug statistics. */
+	struct nss_cmn_node_stats node_stats;	/**< Common node statistics. */
+	uint32_t stats[GRE_SESSION_DEBUG_MAX];	/**< Session debug statistics. */
 };
 
 /**
- * GRE base statistics message.
+ * GRE base statistics message
  */
 struct nss_gre_base_stats_msg {
-	uint32_t stats[NSS_GRE_BASE_DEBUG_MAX];		/**< Base debug statistics. */
-};
-
-/**
- * nss_gre_base_stats_notification
- *	GRE transmission statistics structure.
- */
-struct nss_gre_base_stats_notification {
-	uint64_t stats_base_ctx[NSS_GRE_BASE_DEBUG_MAX];	/**< Base debug transmission statistics. */
-	uint32_t core_id;					/**< Core ID. */
-};
-
-/**
- * nss_gre_session_stats_notification
- *	GRE transmission statistics structure.
- */
-struct nss_gre_session_stats_notification {
-	uint64_t stats_session_ctx[NSS_GRE_SESSION_DEBUG_MAX];		/**< Session debug transmission statistics. */
-	uint32_t core_id;						/**< Core ID. */
-	uint32_t if_num;						/**< Interface number. */
+	uint32_t stats[GRE_BASE_DEBUG_MAX];	/**< Base debug statistics. */
 };
 
 /**
  * nss_gre_msg
- *	Message structure to send/receive GRE messages.
+ *	Message structure to send/receive GRE messages
  */
 struct nss_gre_msg {
-	struct nss_cmn_msg cm;					/**< Common message header. */
+	struct nss_cmn_msg cm;					/**< Common message header */
 
 	/**
 	 * Payload of a GRE message.
@@ -307,7 +283,7 @@ extern nss_tx_status_t nss_gre_tx_msg_sy
 
 /**
  * nss_gre_tx_buf
- *	Sends a packet to the NSS.
+ *	Sends packet to the NSS
  *
  * @datatypes
  * nss_ctx_instance \n
@@ -448,17 +424,7 @@ typedef void (*nss_gre_pkt_callback_t)(s
  * @return
  * None.
  */
-#ifdef NSS_DRV_GRE_ENABLE
 extern void nss_gre_register_pkt_callback(nss_gre_pkt_callback_t cb);
-#else
-static inline void nss_gre_register_pkt_callback(nss_gre_pkt_callback_t cb)
-{
-	/*
-	 * Dummy registration function for external modules when GRE
-	 * is disabled
-	 */
-}
-#endif
 
 /**
  * nss_gre_unregister_pkt_callback
@@ -470,45 +436,7 @@ static inline void nss_gre_register_pkt_
  * @return
  * None.
  */
-#ifdef NSS_DRV_GRE_ENABLE
 extern void nss_gre_unregister_pkt_callback(void);
-#else
-static inline void nss_gre_unregister_pkt_callback(void)
-{
-	/*
-	 * Dummy registration function for external modules when GRE
-	 * is disabled
-	 */
-}
-#endif
-
-/**
- * nss_gre_stats_unregister_notifier
- *	Deregisters a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_gre_stats_unregister_notifier(struct notifier_block *nb);
-
-/**
- * nss_gre_stats_register_notifier
- *	Registers a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_gre_stats_register_notifier(struct notifier_block *nb);
 
 /**
  * @}
--- a/exports/nss_gre_redir.h
+++ b/exports/nss_gre_redir.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2015, 2017-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2015, 2017-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -93,60 +93,6 @@ enum nss_gre_redir_tunnel_types {
 };
 
 /**
- * nss_gre_redir_stats_types
- *	GRE redirect statistics types.
- */
-enum nss_gre_redir_stats_types {
-	NSS_GRE_REDIR_STATS_TX_DROPS = NSS_STATS_NODE_MAX,
-						/**< Dropped transmit packets. */
-	NSS_GRE_REDIR_STATS_SJACK_RX_PKTS,	/**< SJACK receive packet counter. */
-	NSS_GRE_REDIR_STATS_SJACK_TX_PKTS,	/**< SJACK transmit packet counter. */
-	NSS_GRE_REDIR_STATS_OFFLOAD_RX_PKTS_0,	/**< Offload receive packet counter 0. */
-	NSS_GRE_REDIR_STATS_OFFLOAD_RX_PKTS_1,	/**< Offload receive packet counter 1. */
-	NSS_GRE_REDIR_STATS_OFFLOAD_RX_PKTS_2,	/**< Offload receive packet counter 2. */
-	NSS_GRE_REDIR_STATS_OFFLOAD_RX_PKTS_3,	/**< Offload receive packet counter 3. */
-	NSS_GRE_REDIR_STATS_OFFLOAD_RX_PKTS_4,	/**< Offload receive packet counter 4. */
-	NSS_GRE_REDIR_STATS_OFFLOAD_TX_PKTS_0,	/**< Offload transmit packet counter 0. */
-	NSS_GRE_REDIR_STATS_OFFLOAD_TX_PKTS_1,	/**< Offload transmit packet counter 1. */
-	NSS_GRE_REDIR_STATS_OFFLOAD_TX_PKTS_2,	/**< Offload transmit packet counter 2. */
-	NSS_GRE_REDIR_STATS_OFFLOAD_TX_PKTS_3,	/**< Offload transmit packet counter 3. */
-	NSS_GRE_REDIR_STATS_OFFLOAD_TX_PKTS_4,	/**< Offload transmit packet counter 4. */
-	NSS_GRE_REDIR_STATS_EXCEPTION_US_RX_PKTS,
-						/**< Upstream exception receive packet counter. */
-	NSS_GRE_REDIR_STATS_EXCEPTION_US_TX_PKTS,
-						/**< Upstream exception transmit packet counter. */
-	NSS_GRE_REDIR_STATS_EXCEPTION_DS_RX_PKTS,
-						/**< Downstream exception receive packet counter. */
-	NSS_GRE_REDIR_STATS_EXCEPTION_DS_TX_PKTS,
-						/**< Downstream exception transmit packet counter. */
-	NSS_GRE_REDIR_STATS_ENCAP_SG_ALLOC_DROP,
-						/**< Encapsulation drop counters due to scatter gather buffer allocation failure. */
-	NSS_GRE_REDIR_STATS_DECAP_FAIL_DROP,
-						/**< Decapsulation drop counters due to invalid IP header. */
-	NSS_GRE_REDIR_STATS_DECAP_SPLIT_DROP,
-						/**< Decapsulation drop counters due to split flow processing. */
-	NSS_GRE_REDIR_STATS_SPLIT_SG_ALLOC_FAIL,
-						/**< Split processing fail counter due to scatter gather buffer allocation failure. */
-	NSS_GRE_REDIR_STATS_SPLIT_LINEAR_COPY_FAIL,
-						/**< Split processing fail counter due to linear copy fail. */
-	NSS_GRE_REDIR_STATS_SPLIT_NOT_ENOUGH_TAILROOM,
-						/**< Split processing fail counter due to insufficient tailroom. */
-	NSS_GRE_REDIR_STATS_EXCEPTION_DS_INVALID_DST_DROP,
-						/**< Downstream exception handling fail counter due to invalid destination. */
-	NSS_GRE_REDIR_STATS_DECAP_EAPOL_FRAMES,
-						/**< Decapsulation EAPoL frame counters. */
-	NSS_GRE_REDIR_STATS_EXCEPTION_DS_INV_APPID,
-						/**< Invalid application ID for the transmit completion packets on exception downstream node. */
-	NSS_GRE_REDIR_STATS_HEADROOM_UNAVAILABLE,
-						/**< Packet headroom unavailable to write metadata. */
-	NSS_GRE_REDIR_STATS_TX_COMPLETION_SUCCESS,
-						/**< Host enqueue success count for the transmit completion packets. */
-	NSS_GRE_REDIR_STATS_TX_COMPLETION_DROP,
-						/**< Host enqueue drop count for the transmit completion packets. */
-	NSS_GRE_REDIR_STATS_MAX			/**< Maximum statistics type. */
-};
-
-/**
  * nss_gre_redir_inner_configure_msg
  *	Message information for configuring GRE inner node.
  */
@@ -301,63 +247,34 @@ struct nss_gre_redir_stats_sync_msg {
 };
 
 /**
- * nss_gre_redir_tun_stats
- *	GRE redirect statistics to accumulate all stats values.
- */
-struct nss_gre_redir_tun_stats {
-	uint64_t rx_packets;		/**< Number of packets received. */
-	uint64_t rx_bytes;		/**< Number of bytes received. */
-	uint64_t tx_packets;		/**< Number of packets transmitted. */
-	uint64_t tx_bytes;		/**< Number of bytes transmitted. */
-	uint64_t rx_dropped[NSS_MAX_NUM_PRI];
-					/**< Packets dropped on receive due to queue full. */
-	uint64_t tx_dropped;		/**< Dropped transmit packets. */
-	uint64_t sjack_rx_packets;	/**< SJACK receive packet counter. */
-	uint64_t sjack_tx_packets;	/**< SJACK transmit packet counter. */
-	uint64_t offl_rx_pkts[NSS_GRE_REDIR_MAX_RADIO];	/**< Offload receive packet counter per radio. */
-	uint64_t offl_tx_pkts[NSS_GRE_REDIR_MAX_RADIO];	/**< Offload transmit packet counter per radio. */
-	uint64_t exception_us_rx;	/**< Upstream exception receive packet counter. */
-	uint64_t exception_us_tx;	/**< Upstream exception transmit packet counter. */
-	uint64_t exception_ds_rx;	/**< Downstream exception receive packet counter. */
-	uint64_t exception_ds_tx;	/**< Downstream exception transmit packet counter. */
-	uint64_t encap_sg_alloc_drop;
-					/**< Encapsulation drop counters due to scatter gather buffer allocation failure. */
-	uint64_t decap_fail_drop;	/**< Decapsulation drop counters due to invalid IP header. */
-	uint64_t decap_split_drop;	/**< Decapsulation drop counters due to split flow processing. */
-	uint64_t split_sg_alloc_fail;
-					/**< Split processing fail counter due to scatter gather buffer allocation failure. */
-	uint64_t split_linear_copy_fail;
-					/**< Split processing fail counter due to linear copy fail. */
-	uint64_t split_not_enough_tailroom;
-					/**< Split processing fail counter due to insufficient tailroom. */
-	uint64_t exception_ds_invalid_dst_drop;
-					/**< Downstream exception handling fail counter due to invalid destination. */
-	uint64_t decap_eapol_frames;	/**< Decapsulation EAPoL frame counters. */
-	uint64_t exception_ds_inv_appid;
-					/**< Invalid application ID for the transmit completion packets on exception downstream node. */
-	uint64_t headroom_unavail;	/**< Packet headroom unavailable to write metadata. */
-	uint64_t tx_completion_success;	/**< Host enqueue success count for the transmit completion packets. */
-	uint64_t tx_completion_drop;	/**< Host enqueue drop count for the transmit completion packets. */
-};
-
-/**
  * nss_gre_redir_tunnel_stats
  *	GRE redirect statistics as seen by the HLOS.
  */
 struct nss_gre_redir_tunnel_stats {
-	struct net_device *dev;			/**< Net device. */
-	struct nss_gre_redir_tun_stats tstats;	/**< Structure to accumulate all the statistics. */
-	uint32_t ref_count;			/**< Reference count for statistics. */
-};
-
-/**
- * nss_gre_redir_stats_notification
- *	GRE redirect transmission statistics structure.
- */
-struct nss_gre_redir_stats_notification {
-	struct nss_gre_redir_tunnel_stats stats_ctx;	/**< Context transmission statistics. */
-	uint32_t core_id;				/**< Core ID. */
-	uint32_t if_num;				/**< Interface number. */
+	struct net_device *dev;				/**< Net device. */
+	struct nss_cmn_node_stats node_stats;		/**< Common node statistics. */
+	uint64_t tx_dropped;				/**< Dropped Tx packets. */
+	uint64_t sjack_rx_packets;			/**< SJACK Rx packet counter. */
+	uint64_t sjack_tx_packets;			/**< SJACK Tx packet counter. */
+	uint64_t offl_rx_pkts[NSS_GRE_REDIR_MAX_RADIO];	/**< Offload Rx packet counter per radio. */
+	uint64_t offl_tx_pkts[NSS_GRE_REDIR_MAX_RADIO];	/**< Offload Tx packet counter per radio. */
+	uint64_t exception_us_rx;			/**< Upstream exception Rx packet counter. */
+	uint64_t exception_us_tx;			/**< Upstream exception Tx packet counter. */
+	uint64_t exception_ds_rx;			/**< Downstream exception Rx packet counter. */
+	uint64_t exception_ds_tx;			/**< Downstream exception Tx packet counter. */
+	uint64_t encap_sg_alloc_drop;			/**< Encapsulation drop counters due to scatter gather buffer allocation failure. */
+	uint64_t decap_fail_drop;			/**< Decapsulation drop counters due to invalid IP header. */
+	uint64_t decap_split_drop;			/**< Decapsulation drop counters due to split flow processing. */
+	uint64_t split_sg_alloc_fail;			/**< Split processing fail counter due to scatter gather buffer allocation failure. */
+	uint64_t split_linear_copy_fail;		/**< Split processing fail counter due to linear copy fail. */
+	uint64_t split_not_enough_tailroom;		/**< Split processing fail counter due to insufficient tailroom. */
+	uint64_t exception_ds_invalid_dst_drop;		/**< Downstream exception handling fail counter due to invalid destination. */
+	uint64_t decap_eapol_frames;			/**< Decapsulation EAPoL frame counters. */
+	uint64_t exception_ds_inv_appid;		/**< Invalid application ID for the Tx completion packets on exception downstream node. */
+	uint64_t headroom_unavail;			/**< Packet headroom unavailable to write metadata. */
+	uint64_t tx_completion_success;			/**< Host enqueue success count for the Tx completion packets. */
+	uint64_t tx_completion_drop;			/**< Host enqueue drop count for the Tx completion packets. */
+	uint32_t ref_count;				/**< Reference count for statistics. */
 };
 
 /**
@@ -549,7 +466,7 @@ extern nss_tx_status_t nss_gre_redir_tx_
 			uint32_t if_num);
 
 /**
- * nss_gre_redir_stats_get
+ * nss_gre_redir_get_stats
  *	Gets GRE redirect tunnel statistics.
  *
  * @datatypes
@@ -561,7 +478,7 @@ extern nss_tx_status_t nss_gre_redir_tx_
  * @return
  * TRUE or FALSE.
  */
-extern bool nss_gre_redir_stats_get(int index, struct nss_gre_redir_tunnel_stats *stats);
+extern bool nss_gre_redir_get_stats(int index, struct nss_gre_redir_tunnel_stats *stats);
 
 /**
  * nss_gre_redir_alloc_and_register_node
@@ -678,34 +595,6 @@ extern struct dentry *nss_gre_redir_get_
 extern struct device *nss_gre_redir_get_device(void);
 
 /**
- * nss_gre_redir_stats_unregister_notifier
- *	Deregisters a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_gre_redir_stats_unregister_notifier(struct notifier_block *nb);
-
-/**
- * nss_gre_redir_stats_register_notifier
- *	Registers a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_gre_redir_stats_register_notifier(struct notifier_block *nb);
-
-/**
  * @}
  */
 
--- a/exports/nss_gre_redir_lag.h
+++ b/exports/nss_gre_redir_lag.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, 2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -73,39 +73,6 @@ enum nss_gre_redir_lag_ds_message_types
 };
 
 /**
- * nss_gre_redir_lag_ds_stats_types
- *	GRE redirect LAG downstream statistics.
- */
-enum nss_gre_redir_lag_ds_stats_types {
-	NSS_GRE_REDIR_LAG_DS_STATS_DST_INVALID = NSS_STATS_NODE_MAX,
-							/**< Packets that do not have a valid destination. */
-	NSS_GRE_REDIR_LAG_DS_STATS_EXCEPTION_PKT,	/**< Packets that are exceptioned to host. */
-	NSS_GRE_REDIR_LAG_DS_STATS_MAX,			/**< Maximum statistics type. */
-};
-
-/**
- * nss_gre_redir_lag_us_stats_types
- *	GRE redirect LAG upstream statistics.
- */
-enum nss_gre_redir_lag_us_stats_types {
-	NSS_GRE_REDIR_LAG_US_STATS_AMSDU_PKTS = NSS_STATS_NODE_MAX,
-							/**< Number of AMSDU packets seen. */
-	NSS_GRE_REDIR_LAG_US_STATS_AMSDU_PKTS_ENQUEUED,	/**< Number of AMSDU packets enqueued. */
-	NSS_GRE_REDIR_LAG_US_STATS_AMSDU_PKTS_EXCEPTIONED,
-							/**< Number of AMSDU packets exceptioned. */
-	NSS_GRE_REDIR_LAG_US_STATS_EXCEPTIONED,		/**< Number of exceptioned packets. */
-	NSS_GRE_REDIR_LAG_US_STATS_FREED,		/**< Freed packets when equeue to NSS to host fails. */
-	NSS_GRE_REDIR_LAG_US_STATS_ADD_ATTEMPT,		/**< Add hash attempts. */
-	NSS_GRE_REDIR_LAG_US_STATS_ADD_SUCCESS,		/**< Add hash success. */
-	NSS_GRE_REDIR_LAG_US_STATS_ADD_FAIL_TABLE_FULL,	/**< Add hash failed due to full table. */
-	NSS_GRE_REDIR_LAG_US_STATS_ADD_FAIL_EXISTS,	/**< Add hash failed as entry already exists. */
-	NSS_GRE_REDIR_LAG_US_STATS_DEL_ATTEMPT,		/**< Delete hash attempts. */
-	NSS_GRE_REDIR_LAG_US_STATS_DEL_SUCCESS,		/**< Delete hash success. */
-	NSS_GRE_REDIR_LAG_US_STATS_DEL_FAIL_NOT_FOUND,	/**< Delete hash failed as entry not found in hash table. */
-	NSS_GRE_REDIR_LAG_US_STATS_MAX,			/**< Maximum statistics type. */
-};
-
-/**
  * nss_gre_redir_lag_us_hash_mode
  *	GRE redirect LAG upstream hash modes.
  */
@@ -287,16 +254,6 @@ struct nss_gre_redir_lag_us_tunnel_stats
 };
 
 /**
- * nss_gre_redir_lag_us_stats_notification
- *	GRE redirect LAG upstream transmission statistics structure.
- */
-struct nss_gre_redir_lag_us_stats_notification {
-	struct nss_gre_redir_lag_us_tunnel_stats stats_ctx;	/**< Context transmission statistics. */
-	uint32_t core_id;					/**< Core ID. */
-	uint32_t if_num;					/**< Interface number. */
-};
-
-/**
  * nss_gre_redir_lag_ds_add_sta_msg
  *	Message to add station in LAG deployment.
  */
@@ -363,26 +320,15 @@ struct nss_gre_redir_lag_ds_msg {
  *	Downstream statistics.
  */
 struct nss_gre_redir_lag_ds_tun_stats {
-	uint64_t rx_packets;		/**< Received packets. */
-	uint64_t rx_bytes;		/**< Received bytes. */
-	uint64_t tx_packets;		/**< Transmit packets. */
-	uint64_t tx_bytes;		/**< Transmit bytes. */
-	uint64_t rx_dropped[NSS_MAX_NUM_PRI];
-					/**< Packets dropped on receive due to queue full. */
-	uint64_t dst_invalid;		/**< Packets that do not have a valid destination. */
-	uint64_t exception_cnt;		/**< Packets that are exceptioned to host. */
-	uint32_t ifnum;			/**< NSS interface number. */
-	bool valid;			/**< Valid flag. */
-};
-
-/**
- * nss_gre_redir_lag_ds_stats_notification
- *	GRE redirect LAG downstream transmission statistics structure.
- */
-struct nss_gre_redir_lag_ds_stats_notification {
-	struct nss_gre_redir_lag_ds_tun_stats stats_ctx;	/**< Context transmission statistics. */
-	uint32_t core_id;					/**< Core ID. */
-	uint32_t if_num;					/**< Interface number. */
+	uint64_t rx_packets;					/**< Received packets. */
+	uint64_t rx_bytes;					/**< Received bytes. */
+	uint64_t tx_packets;					/**< Transmit packets. */
+	uint64_t tx_bytes;					/**< Transmit bytes. */
+	uint64_t rx_dropped[NSS_MAX_NUM_PRI];			/**< Packets dropped on receive due to queue full. */
+	uint64_t dst_invalid;					/**< Packets that do not have a valid destination. */
+	uint64_t exception_cnt;					/**< Packets that are exceptioned to host. */
+	uint32_t ifnum;						/**< NSS interface number. */
+	bool valid;						/**< Valid flag. */
 };
 
 /**
@@ -622,7 +568,7 @@ extern nss_tx_status_t nss_gre_redir_lag
 extern nss_tx_status_t nss_gre_redir_lag_ds_tx_msg_sync(struct nss_ctx_instance *nss_ctx, struct nss_gre_redir_lag_ds_msg *ngrm);
 
 /**
- * nss_gre_redir_lag_us_stats_get
+ * nss_gre_redir_lag_us_get_cmn_stats
  *	Fetches common node statistics for upstream GRE Redir LAG.
  *
  * @datatypes
@@ -634,10 +580,10 @@ extern nss_tx_status_t nss_gre_redir_lag
  * @return
  * True if successful, else false.
  */
-extern bool nss_gre_redir_lag_us_stats_get(struct nss_gre_redir_lag_us_tunnel_stats *cmn_stats, uint32_t index);
+extern bool nss_gre_redir_lag_us_get_cmn_stats(struct nss_gre_redir_lag_us_tunnel_stats *cmn_stats, uint32_t index);
 
 /**
- * nss_gre_redir_lag_ds_stats_get
+ * nss_gre_redir_lag_ds_get_stats
  *	Fetches common node statistics for downstream GRE Redir LAG.
  *
  * @datatypes
@@ -649,7 +595,7 @@ extern bool nss_gre_redir_lag_us_stats_g
  * @return
  * True if successful, else false.
  */
-extern bool nss_gre_redir_lag_ds_stats_get(struct nss_gre_redir_lag_ds_tun_stats *cmn_stats, uint32_t index);
+extern bool nss_gre_redir_lag_ds_get_cmn_stats(struct nss_gre_redir_lag_ds_tun_stats *cmn_stats, uint32_t index);
 
 /**
  * nss_gre_redir_lag_us_get_context
@@ -670,62 +616,6 @@ extern struct nss_ctx_instance *nss_gre_
 extern struct nss_ctx_instance *nss_gre_redir_lag_ds_get_context(void);
 
 /**
- * nss_gre_redir_lag_ds_stats_unregister_notifier
- *	Deregisters a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_gre_redir_lag_ds_stats_unregister_notifier(struct notifier_block *nb);
-
-/**
- * nss_gre_redir_lag_ds_stats_register_notifier
- *	Registers a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_gre_redir_lag_ds_stats_register_notifier(struct notifier_block *nb);
-
-/**
- * nss_gre_redir_lag_us_stats_unregister_notifier
- *	Deregisters a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_gre_redir_lag_us_stats_unregister_notifier(struct notifier_block *nb);
-
-/**
- * nss_gre_redir_lag_us_stats_register_notifier
- *	Registers a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_gre_redir_lag_us_stats_register_notifier(struct notifier_block *nb);
-
-/**
  * @}
  */
 
--- a/exports/nss_gre_redir_mark.h
+++ b/exports/nss_gre_redir_mark.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, 2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -25,8 +25,6 @@
 #define NSS_GRE_REDIR_MARK_HLOS_MAGIC 0xaade	/**< Metadata magic set by HLOS. */
 #define NSS_GRE_REDIR_MARK_NSS_MAGIC 0xaadf	/**< Metadata magic set by NSS. */
 
-extern struct nss_gre_redir_mark_stats gre_mark_stats;
-
 /**
  * nss_gre_redir_mark messages
  *	Message types for GRE redirect mark requests and responses.
@@ -49,23 +47,6 @@ enum nss_gre_redir_mark_error_types {
 };
 
 /**
- * nss_gre_redir_mark_stats_types
- *	GRE redirect mark statistics types.
- */
-enum nss_gre_redir_mark_stats_types {
-	NSS_GRE_REDIR_MARK_STATS_HLOS_MAGIC_FAILED = NSS_STATS_NODE_MAX,
-							/**< HLOS magic fail count. */
-	NSS_GRE_REDIR_MARK_STATS_INV_DST_IF_DROPS,	/**< Invalid transmit interface drop count. */
-	NSS_GRE_REDIR_MARK_STATS_DST_IF_ENQUEUE,	/**< Next egress interface enqueue success count. */
-	NSS_GRE_REDIR_MARK_STATS_DST_IF_ENQUEUE_DROPS,	/**< Next egress interface enqueue drop count. */
-	NSS_GRE_REDIR_MARK_STATS_INV_APPID,		/**< Invalid application ID for the transmit completion packets. */
-	NSS_GRE_REDIR_MARK_STATS_HEADROOM_UNAVAILABLE,	/**< Packet headroom unavailable to write metadata. */
-	NSS_GRE_REDIR_MARK_STATS_TX_COMPLETION_SUCCESS,	/**< Transmit completion host enqueue success count. */
-	NSS_GRE_REDIR_MARK_STATS_TX_COMPLETION_DROPS,	/**< Transmit completion host enqueue drop count. */
-	NSS_GRE_REDIR_MARK_STATS_MAX			/**< Maximum statistics type. */
-};
-
-/**
  * nss_gre_redir_mark_metadata
  *	HLOS to NSS per packet downstream metadata.
  */
@@ -74,7 +55,7 @@ struct nss_gre_redir_mark_metadata {
 	uint8_t wifi_tid;		/**< TID value. */
 	uint8_t app_id;			/**< Application ID. */
 	uint16_t hw_hash_idx;		/**< Hardware AST hash index value. */
-	uint32_t tx_status;		/**< Transmit status. */
+	uint32_t tx_status;		/**< Tx status. */
 	uint16_t offset;		/**< Buffer offset from the metadata. */
 	uint16_t magic;			/**< Metadata magic. */
 };
@@ -86,31 +67,21 @@ struct nss_gre_redir_mark_metadata {
 struct nss_gre_redir_mark_stats_sync_msg {
 	struct nss_cmn_node_stats node_stats;	/**< Common node statistics. */
 	uint32_t hlos_magic_fail;               /**< HLOS magic fail count. */
-	uint32_t invalid_dst_drop;		/**< Invalid transmit interface drop count. */
+	uint32_t invalid_dst_drop;		/**< Invalid Tx interface drop count. */
 	uint32_t dst_enqueue_success;		/**< Next egress interface enqueue success count. */
 	uint32_t dst_enqueue_drop;		/**< Next egress interface enqueue drop count. */
-	uint32_t inv_appid;			/**< Invalid application ID for the transmit completion packets. */
+	uint32_t inv_appid;			/**< Invalid application ID for the Tx completion packets. */
 	uint32_t headroom_unavail;		/**< Packet headroom unavailable to write metadata. */
-	uint32_t tx_completion_success;		/**< Transmit completion host enqueue success count. */
-	uint32_t tx_completion_drop;		/**< Transmit completion host enqueue drop count. */
+	uint32_t tx_completion_success;		/**< Tx completion host enqueue success count. */
+	uint32_t tx_completion_drop;		/**< Tx completion host enqueue drop count. */
 };
 
 /**
  * nss_gre_redir_mark_register_cb_msg
- *	Transmit completion function register configuration message.
+ *	Tx completion function register configuration message.
  */
 struct nss_gre_redir_mark_register_cb_msg {
-	uint32_t nss_if_num;	/**< NSS transmit interface number on which callback needs to be registered. */
-};
-
-/**
- * nss_gre_redir_mark_stats_notification
- *	GRE redirect mark transmission statistics structure.
- */
-struct nss_gre_redir_mark_stats_notification {
-	uint64_t stats_ctx[NSS_GRE_REDIR_MARK_STATS_MAX];	/**< Context transmission statistics. */
-	uint32_t core_id;					/**< Core ID. */
-	uint32_t if_num;					/**< Interface number. */
+	uint32_t nss_if_num;			/**< NSS Tx interface number on which callback needs to be registered. */
 };
 
 /**
@@ -240,7 +211,7 @@ extern nss_tx_status_t nss_gre_redir_mar
 extern nss_tx_status_t nss_gre_redir_mark_tx_msg_sync(struct nss_ctx_instance *nss_ctx, struct nss_gre_redir_mark_msg *ngrm);
 
 /**
- * nss_gre_redir_mark_stats_get
+ * nss_gre_redir_mark_get_stats
  *      Gets GRE redirect mark statistics.
  *
  * @datatypes
@@ -252,7 +223,7 @@ extern nss_tx_status_t nss_gre_redir_mar
  * @return
  * TRUE or FALSE.
  */
-extern bool nss_gre_redir_mark_stats_get(struct nss_gre_redir_mark_stats *stats);
+extern bool nss_gre_redir_mark_get_stats(void *stats);
 
 /**
  * nss_gre_redir_alloc_and_register_node
@@ -304,34 +275,6 @@ extern struct dentry *nss_gre_redir_mark
 extern struct device *nss_gre_redir_mark_get_device(void);
 
 /**
- * nss_gre_redir_mark_stats_unregister_notifier
- *	Deregisters a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_gre_redir_mark_stats_unregister_notifier(struct notifier_block *nb);
-
-/**
- * nss_gre_redir_mark_stats_register_notifier
- *	Registers a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_gre_redir_mark_stats_register_notifier(struct notifier_block *nb);
-
-/**
  * @}
  */
 
--- a/exports/nss_gre_tunnel.h
+++ b/exports/nss_gre_tunnel.h
@@ -1,6 +1,6 @@
 /*
- ****************************************************************************
- * Copyright (c) 2016-2018, 2020-2021, The Linux Foundation. All rights reserved.
+ **************************************************************************
+ * Copyright (c) 2016-2018,2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -11,7 +11,7 @@
  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
  * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ****************************************************************************
+ **************************************************************************
  */
 
 /**
@@ -98,41 +98,6 @@ enum nss_gre_tunnel_error_types {
 };
 
 /**
- *  nss_gre_tunnel_stats_type
- *	GRE tunnel session debug statistic counters.
- */
-enum nss_gre_tunnel_stats_type {
-	NSS_GRE_TUNNEL_STATS_SESSION_RX_PKTS,			/**< Number of packets received. */
-	NSS_GRE_TUNNEL_STATS_SESSION_TX_PKTS,			/**< Number of packets transmitted. */
-	NSS_GRE_TUNNEL_STATS_SESSION_RX_QUEUE_0_DROPPED,	/**< Dropped receive packets 0. */
-	NSS_GRE_TUNNEL_STATS_SESSION_RX_QUEUE_1_DROPPED,	/**< Dropped receive packets 1. */
-	NSS_GRE_TUNNEL_STATS_SESSION_RX_QUEUE_2_DROPPED,	/**< Dropped receive packets 2. */
-	NSS_GRE_TUNNEL_STATS_SESSION_RX_QUEUE_3_DROPPED,	/**< Dropped receive packets 3. */
-	NSS_GRE_TUNNEL_STATS_SESSION_RX_MALFORMED,		/**< Malformed packet was received. */
-	NSS_GRE_TUNNEL_STATS_SESSION_RX_INVALID_PROT,		/**< Invalid protocol was received. */
-	NSS_GRE_TUNNEL_STATS_SESSION_DECAP_QUEUE_FULL,		/**< Decapsulation queue is full. */
-	NSS_GRE_TUNNEL_STATS_SESSION_RX_SINGLE_REC_DGRAM,	/**< Single fragment was received. */
-	NSS_GRE_TUNNEL_STATS_SESSION_RX_INVALID_REC_DGRAM,	/**< Invalid fragment was received. */
-	NSS_GRE_TUNNEL_STATS_SESSION_BUFFER_ALLOC_FAIL,		/**< Buffer memory allocation failed. */
-	NSS_GRE_TUNNEL_STATS_SESSION_BUFFER_COPY_FAIL,		/**< Buffer memory copy failed. */
-	NSS_GRE_TUNNEL_STATS_SESSION_OUTFLOW_QUEUE_FULL,	/**< Outflow queue is full. */
-	NSS_GRE_TUNNEL_STATS_SESSION_RX_DROPPED_HROOM,	/**< Packets dropped because of insufficent headroom. */
-	NSS_GRE_TUNNEL_STATS_SESSION_RX_CBUFFER_ALLOC_FAIL,	/**< Receive crypto buffer allocation failed. */
-	NSS_GRE_TUNNEL_STATS_SESSION_RX_CENQUEUE_FAIL,		/**< Receive enqueue-to-crypto failed. */
-	NSS_GRE_TUNNEL_STATS_SESSION_RX_DECRYPT_DONE,		/**< Receive decryption is complete. */
-	NSS_GRE_TUNNEL_STATS_SESSION_RX_FORWARD_ENQUEUE_FAIL,	/**< Receive forward enqueue failed. */
-	NSS_GRE_TUNNEL_STATS_SESSION_TX_CBUFFER_ALLOC_FAIL,	/**< Receive crypto buffer allocation failed. */
-	NSS_GRE_TUNNEL_STATS_SESSION_TX_CENQUEUE_FAIL,		/**< Transmit enqueue-to-crypto failed. */
-	NSS_GRE_TUNNEL_STATS_SESSION_RX_DROPPED_TROOM,	/**< Packets dropped because of insufficent tailroom. */
-	NSS_GRE_TUNNEL_STATS_SESSION_TX_FORWARD_ENQUEUE_FAIL,	/**< Transmit forward enqueue failed. */
-	NSS_GRE_TUNNEL_STATS_SESSION_TX_CIPHER_DONE,		/**< Transmit cipher is complete. */
-	NSS_GRE_TUNNEL_STATS_SESSION_CRYPTO_NOSUPP,		/**< Error count for non-supported crypto packets. */
-	NSS_GRE_TUNNEL_STATS_SESSION_RX_DROPPED_MH_VERSION,	/**< Receive drop: bad meta header. */
-	NSS_GRE_TUNNEL_STATS_SESSION_RX_UNALIGNED_PKT,		/**< Counter for unaligned packets. */
-	NSS_GRE_TUNNEL_STATS_SESSION_MAX,			/**< Maximum statistics type. */
-};
-
-/**
  * nss_gre_tunnel_di_to_wlan_id
  *	Dynamic interface to WLAN ID message structure.
  */
@@ -186,20 +151,20 @@ struct nss_gre_tunnel_stats {
 	uint32_t rx_dropped_hroom;
 				/**< Packets dropped because of insufficent headroom. */
 	uint32_t rx_cbuf_alloc_fail;
-				/**< Receive crypto buffer allocation failed. */
-	uint32_t rx_cenqueue_fail;		/**< Receive enqueue-to-crypto failed. */
-	uint32_t rx_decrypt_done;		/**< Receive decryption is complete. */
-	uint32_t rx_forward_enqueue_fail;	/**< Receive forward enqueue failed. */
+				/**< Rx crypto buffer allocation failed. */
+	uint32_t rx_cenqueue_fail;		/**< Rx enqueue-to-crypto failed. */
+	uint32_t rx_decrypt_done;		/**< Rx decryption is complete. */
+	uint32_t rx_forward_enqueue_fail;	/**< Rx forward enqueue failed. */
 	uint32_t tx_cbuf_alloc_fail;
-				/**< Receive crypto buffer allocation failed. */
-	uint32_t tx_cenqueue_fail;		/**< Transmit enqueue-to-crypto failed. */
+				/**< Rx crypto buffer allocation failed. */
+	uint32_t tx_cenqueue_fail;		/**< Tx enqueue-to-crypto failed. */
 	uint32_t rx_dropped_troom;
 				/**< Packets dropped because of insufficent tailroom. */
-	uint32_t tx_forward_enqueue_fail;	/**< Transmit forward enqueue failed. */
-	uint32_t tx_cipher_done;		/**< Transmit cipher is complete. */
+	uint32_t tx_forward_enqueue_fail;	/**< Tx forward enqueue failed. */
+	uint32_t tx_cipher_done;		/**< Tx cipher is complete. */
 	uint32_t crypto_nosupp;
 				/**< Error count for non-supported crypto packets. */
-	uint32_t rx_dropped_mh_ver;		/**< Receive drop: bad meta header. */
+	uint32_t rx_dropped_mh_ver;		/**< Rx drop: bad meta header. */
 	uint32_t rx_unaligned_pkt;		/**< Counter for unaligned packets. */
 #if defined(NSS_HAL_IPQ807x_SUPPORT)
 	uint32_t crypto_resp_error[NSS_CRYPTO_CMN_RESP_ERROR_MAX];
@@ -208,17 +173,6 @@ struct nss_gre_tunnel_stats {
 };
 
 /**
- * nss_gre_tunnel_stats_notification
- *	GRE tunnel transmission statistics structure.
- */
-struct nss_gre_tunnel_stats_notification {
-	uint64_t stats_ctx[NSS_GRE_TUNNEL_STATS_SESSION_MAX + NSS_CRYPTO_CMN_RESP_ERROR_MAX];
-							/**< Context transmission statistics. */
-	uint32_t core_id;				/**< Core ID. */
-	uint32_t if_num;				/**< Interface number. */
-};
-
-/**
  * nss_gre_tunnel_msg
  *	Data for sending and receiving GRE tunnel messages.
  */
@@ -394,34 +348,6 @@ extern nss_tx_status_t nss_gre_tunnel_in
 		nss_gre_tunnel_msg_callback_t cb, void *app_data);
 
 /**
- * nss_gre_tunnel_stats_unregister_notifier
- *	Deregisters a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_gre_tunnel_stats_unregister_notifier(struct notifier_block *nb);
-
-/**
- * nss_gre_tunnel_stats_register_notifier
- *	Registers a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_gre_tunnel_stats_register_notifier(struct notifier_block *nb);
-
-/**
  * @}
  */
 
--- a/exports/nss_if.h
+++ b/exports/nss_if.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -53,8 +53,6 @@ enum nss_if_message_types {
 	NSS_IF_SET_IGS_NODE,
 	NSS_IF_CLEAR_IGS_NODE,
 	NSS_IF_RESET_NEXTHOP,
-	NSS_IF_PPE_PORT_CREATE,
-	NSS_IF_PPE_PORT_DESTROY,
 	NSS_IF_MAX_MSG_TYPES = 9999,
 };
 
@@ -200,14 +198,6 @@ struct nss_if_igs_config {
 };
 
 /**
- * nss_if_ppe_port_create
- *	Message to create PPE port.
- */
-struct nss_if_ppe_port_create {
-	int32_t ppe_port_num;	/**< PPE port number returned by NSS. */
-};
-
-/**
  * nss_if_msgs
  *	Information for physical NSS interface command messages.
  */
@@ -240,8 +230,6 @@ union nss_if_msgs {
 			/**< Set nexthop of interface. */
 	struct nss_if_igs_config config_igs;
 			/**< Configure an ingress shaper interface. */
-	struct nss_if_ppe_port_create ppe_port_create;
-			/**< Create a PPE port. */
 };
 
 /**
@@ -321,23 +309,6 @@ extern struct nss_ctx_instance *nss_if_r
 extern nss_tx_status_t nss_if_tx_buf(struct nss_ctx_instance *nss_ctx, struct sk_buff *os_buf, uint32_t if_num);
 
 /**
- * nss_if_tx_msg_with_size
- *	Sends a message to the NSS interface.
- *
- * @datatypes
- * nss_ctx_instance \n
- * nss_if_msg
- *
- * @param[in,out] nss_ctx  Pointer to the NSS context.
- * @param[in]     nim      Pointer to the NSS interface message.
- * @param[in]     size     Total message buffer size.
- *
- * @return
- * Status of the Tx operation.
- */
-nss_tx_status_t nss_if_tx_msg_with_size(struct nss_ctx_instance *nss_ctx, struct nss_if_msg *nim, uint32_t size);
-
-/**
  * nss_if_tx_msg
  *	Sends a message to the NSS interface.
  *
@@ -355,7 +326,7 @@ nss_tx_status_t nss_if_tx_msg(struct nss
 
 /**
  * nss_if_msg_sync
- *	Sends a message to the NSS interface and waits for the response.
+ *	Sends a message to the NSS interface and wait for the response.
  *
  * @datatypes
  * nss_ctx_instance \n
@@ -401,70 +372,6 @@ nss_tx_status_t nss_if_set_nexthop(struc
 nss_tx_status_t nss_if_reset_nexthop(struct nss_ctx_instance *nss_ctx, uint32_t if_num);
 
 /**
- * nss_if_change_mtu
- *	Changes the MTU of the interface.
- *
- * @datatypes
- * nss_ctx_instance
- *
- * @param[in] nss_ctx  Pointer to the NSS context.
- * @param[in] if_num   NSS interface number.
- * @param[in] mtu      New MTU.
- *
- * @return
- * Status of the transmit operation.
- */
-nss_tx_status_t nss_if_change_mtu(struct nss_ctx_instance *nss_ctx, nss_if_num_t if_num, uint16_t mtu);
-
-/**
- * nss_if_change_mac_addr
- *	Changes the MAC address of the interface.
- *
- * @datatypes
- * nss_ctx_instance
- *
- * @param[in] nss_ctx  Pointer to the NSS context.
- * @param[in] if_num   NSS interface number.
- * @param[in] mac_addr New MAC address.
- *
- * @return
- * Status of the transmit operation.
- */
-nss_tx_status_t nss_if_change_mac_addr(struct nss_ctx_instance *nss_ctx, nss_if_num_t if_num, uint8_t *mac_addr);
-
-/**
- * nss_if_vsi_unassign
- *	Detaches the VSI ID from the given interface.
- *
- * @datatypes
- * nss_ctx_instance
- *
- * @param[in] nss_ctx  Pointer to the NSS context.
- * @param[in] if_num   NSS interface number.
- * @param[in] vsi      VSI ID.
- *
- * @return
- * Status of the transmit operation.
- */
-nss_tx_status_t nss_if_vsi_unassign(struct nss_ctx_instance *nss_ctx, nss_if_num_t if_num, uint32_t vsi);
-
-/**
- * nss_if_vsi_assign
- *	Attaches the VSI ID to the given interface.
- *
- * @datatypes
- * nss_ctx_instance
- *
- * @param[in] nss_ctx  Pointer to the NSS context.
- * @param[in] if_num   NSS interface number.
- * @param[in] vsi      VSI ID.
- *
- * @return
- * Status of the transmit operation.
- */
-nss_tx_status_t nss_if_vsi_assign(struct nss_ctx_instance *nss_ctx, nss_if_num_t if_num, uint32_t vsi);
-
-/**
  * @}
  */
 
--- a/exports/nss_ipsec_cmn.h
+++ b/exports/nss_ipsec_cmn.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -107,37 +107,6 @@ enum nss_ipsec_cmn_ctx_type {
 };
 
 /**
- * nss_ipsec_cmn_stats_types
- *	IPsec common statistics types.
- */
-enum nss_ipsec_cmn_stats_types {
-	NSS_IPSEC_CMN_STATS_FAIL_HEADROOM = NSS_STATS_NODE_MAX,
-						/**< Failure in headroom check. */
-	NSS_IPSEC_CMN_STATS_FAIL_TAILROOM,	/**< Failure in tailroom check. */
-	NSS_IPSEC_CMN_STATS_FAIL_REPLAY,	/**< Failure in anti-replay check. */
-	NSS_IPSEC_CMN_STATS_FAIL_REPLAY_DUP,	/**< Failure in anti-replay; duplicate records. */
-	NSS_IPSEC_CMN_STATS_FAIL_REPLAY_WIN,	/**< Failure in anti-replay; packet outside the window. */
-	NSS_IPSEC_CMN_STATS_FAIL_PBUF_CRYPTO,	/**< Failure in crypto pbuf allocation. */
-	NSS_IPSEC_CMN_STATS_FAIL_QUEUE,		/**< Failure due to queue full in IPsec. */
-	NSS_IPSEC_CMN_STATS_FAIL_QUEUE_CRYPTO,	/**< Failure due to queue full in crypto. */
-	NSS_IPSEC_CMN_STATS_FAIL_QUEUE_NEXTHOP,	/**< Failure due to queue full in next hop. */
-	NSS_IPSEC_CMN_STATS_FAIL_PBUF_ALLOC,	/**< Failure in pbuf allocation. */
-	NSS_IPSEC_CMN_STATS_FAIL_PBUF_LINEAR,	/**< Failure in pbuf linearization. */
-	NSS_IPSEC_CMN_STATS_FAIL_PBUF_STATS,	/**< Failure in pbuf allocation for statistics. */
-	NSS_IPSEC_CMN_STATS_FAIL_PBUF_ALIGN,	/**< Failure in pbuf access due to non-word alignmnt */
-	NSS_IPSEC_CMN_STATS_FAIL_CIPHER,	/**< Failure in decrypting the data. */
-	NSS_IPSEC_CMN_STATS_FAIL_AUTH,		/**< Failure in authenticating the data. */
-	NSS_IPSEC_CMN_STATS_FAIL_SEQ_OVF,	/**< Failure due to sequence number rollover. */
-	NSS_IPSEC_CMN_STATS_FAIL_BLK_LEN,	/**< Failure in decapsulation due to bad cipher block length. */
-	NSS_IPSEC_CMN_STATS_FAIL_HASH_LEN,	/**< Failure in decapsulation due to bad hash block length. */
-	NSS_IPSEC_CMN_STATS_FAIL_TRANSFORM,	/**< Failure in transformation; general error. */
-	NSS_IPSEC_CMN_STATS_FAIL_CRYPTO,	/**< Failure in crypto transformation. */
-	NSS_IPSEC_CMN_STATS_FAIL_CLE,		/**< Failure in classification; general failure. */
-	NSS_IPSEC_CMN_STATS_IS_STOPPED,		/**< Indicates if SA is stopped; for example: sequence overflow. */
-	NSS_IPSEC_CMN_STATS_MAX,		/**< Maximum statistics type. */
-};
-
-/**
  * nss_ipsec_cmn_flow_tuple
  *	IPsec tuple for creating flow entries.
  *
@@ -227,7 +196,6 @@ struct nss_ipsec_cmn_sa {
 struct nss_ipsec_cmn_ctx {
 	enum nss_ipsec_cmn_ctx_type type;	/**< Node type. */
 	uint32_t except_ifnum;			/**< Exception interface for egress. */
-	uint32_t sibling_ifnum;			/**< Sibling interface. */
 };
 
 /**
@@ -269,7 +237,7 @@ struct nss_ipsec_cmn_sa_stats {
 	uint32_t fail_pbuf_alloc;		/**< Failure in pbuf allocation. */
 	uint32_t fail_pbuf_linear;		/**< Failure in pbuf linearization. */
 	uint32_t fail_pbuf_stats;		/**< Failure in pbuf allocation for statistics. */
-	uint32_t fail_pbuf_align;		/**< Failure in pbuf access due to non-word alignment. */
+	uint32_t fail_pbuf_align;		/**< Failure in pbuf access due non-word alignment. */
 	uint32_t fail_cipher;			/**< Failure in decrypting the data. */
 	uint32_t fail_auth;			/**< Failure in authenticating the data. */
 	uint32_t fail_seq_ovf;			/**< Failure due to sequence number rollover. */
@@ -278,7 +246,6 @@ struct nss_ipsec_cmn_sa_stats {
 	uint32_t fail_transform;		/**< Failure in transformation; general error. */
 	uint32_t fail_crypto;			/**< Failure in crypto transformation. */
 	uint32_t fail_cle;			/**< Failure in classification; general failure. */
-	uint32_t is_stopped;			/**< Indicates if SA is stopped; for example, sequence overflow. */
 };
 
 /**
@@ -301,7 +268,6 @@ struct nss_ipsec_cmn_ctx_stats {
 	uint32_t exceptioned;		/**< Exceptioned to host. */
 	uint32_t linearized;		/**< Linearized packets. */
 	uint32_t redirected;		/**< Redirected from inline. */
-	uint32_t dropped;		/**< Total dropped packets. */
 	uint32_t fail_sa;		/**< Failed to find SA. */
 	uint32_t fail_flow;		/**< Failed to find flow. */
 	uint32_t fail_stats;		/**< Failed to send statistics. */
@@ -309,9 +275,6 @@ struct nss_ipsec_cmn_ctx_stats {
 	uint32_t fail_transform;	/**< Failed to produce output. */
 	uint32_t fail_linearized;	/**< Failed to linearize. */
 	uint32_t fail_mdata_ver;	/**< Invalid metadata version. */
-	uint32_t fail_ctx_active;	/**< Failed to queue as context is not active. */
-	uint32_t fail_pbuf_crypto;	/**< Failed to allocate pbuf for crypto operation. */
-	uint32_t fail_queue_crypto;	/**< Failed to queue pbuf to crypto pnode. */
 };
 
 /**
@@ -368,16 +331,6 @@ struct nss_ipsec_cmn_mdata {
 };
 
 /**
- * nss_ipsec_cmn_stats_notification
- *	IPsec common transmission statistics structure.
- */
-struct nss_ipsec_cmn_stats_notification {
-	uint64_t stats_ctx[NSS_IPSEC_CMN_STATS_MAX];	/**< Context transmission statistics. */
-	uint32_t core_id;				/**< Core ID. */
-	uint32_t if_num;				/**< Interface number. */
-};
-
-/**
  * nss_ipsec_cmn_msg
  *	Message structure for NSS IPsec messages.
  */
@@ -466,23 +419,6 @@ extern struct nss_ctx_instance *nss_ipse
 extern uint32_t nss_ipsec_cmn_get_ifnum_with_coreid(int32_t ifnum);
 
 /**
- * nss_ipsec_cmn_unregister_if
- *	Deregisters an IPSEC tunnel interface from the NSS.
- *
- * @param[in] if_num  NSS interface number.
- *
- * @return
- * None.
- *
- * @dependencies
- * The tunnel interface must have been previously registered.
- *
- * @return
- * True if successful, else false.
- */
-extern bool nss_ipsec_cmn_unregister_if(uint32_t if_num);
-
-/**
  * nss_ipsec_cmn_register_if
  *	Registers the IPsec interface with the NSS for sending and
  *	receiving messages.
@@ -510,26 +446,25 @@ extern struct nss_ctx_instance *nss_ipse
 						uint32_t features, enum nss_dynamic_interface_type type, void *app_data);
 
 /**
- * nss_ipsec_cmn_notify_unregister
- *	Deregisters the message notifier from the HLOS driver.
- *
- * @datatypes
- * nss_ctx_instance
- *
- * @param[in,out] ctx     Pointer to the context of the HLOS driver.
- * @param[in]     if_num  NSS interface number.
+ * nss_ipsec_cmn_unregister_if
+ *	Deregisters a IPSEC tunnel interface from the NSS.
  *
+ * @param[in] if_num  NSS interface number.
+. *
  * @return
  * None.
  *
  * @dependencies
- * The message notifier must have been previously registered.
+ * The tunnel interface must have been previously registered.
+ *
+ * @return
+ * True if successful, else false.
  */
-extern void nss_ipsec_cmn_notify_unregister(struct nss_ctx_instance *ctx, uint32_t if_num);
+extern bool nss_ipsec_cmn_unregister_if(uint32_t if_num);
 
 /**
  * nss_ipsec_cmn_notify_register
- *	Registers an event callback to handle notifications from the IPsec firmware package.
+ *	Register an event callback to handle notification from IPsec firmware package.
  *
  * @datatypes
  * nss_ipsec_cmn_msg_callback_t \n
@@ -539,11 +474,29 @@ extern void nss_ipsec_cmn_notify_unregis
  * @param[in] app_data  Pointer to the application context.
  *
  * @return
- * Pointer to the NSS core context.
+ * Pointer to NSS core context.
  */
 extern struct nss_ctx_instance *nss_ipsec_cmn_notify_register(uint32_t ifnum, nss_ipsec_cmn_msg_callback_t cb, void *app_data);
 
 /**
+ * nss_ipsec_cmn_notify_unregister
+ *	Deregisters the message notifier from the HLOS driver.
+ *
+ * @datatypes
+ * nss_ctx_instance
+ *
+ * @param[in,out] ctx     Pointer to the context of the HLOS driver.
+ * @param[in]     if_num  NSS interface number.
+ *
+ * @return
+ * None.
+ *
+ * @dependencies
+ * The message notifier must have been previously registered.
+ */
+extern void nss_ipsec_cmn_notify_unregister(struct nss_ctx_instance *ctx, uint32_t if_num);
+
+/**
  * nss_ipsec_cmn_msg_init
  *	Initializes an IPsec message.
  *
@@ -657,34 +610,6 @@ extern bool nss_ipsec_cmn_ppe_port_confi
 bool nss_ipsec_cmn_ppe_mtu_update(struct nss_ctx_instance *ctx, uint32_t if_num, uint16_t mtu, uint16_t mru);
 
 /**
- * nss_ipsec_cmn_stats_unregister_notifier
- *	Deregisters a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_ipsec_cmn_stats_unregister_notifier(struct notifier_block *nb);
-
-/**
- * nss_ipsec_cmn_stats_register_notifier
- *	Registers a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_ipsec_cmn_stats_register_notifier(struct notifier_block *nb);
-
-/**
  * @}
  */
 
--- a/exports/nss_ipv4.h
+++ b/exports/nss_ipv4.h
@@ -1,12 +1,9 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
- *
+ * Copyright (c) 2014-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
- *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -29,116 +26,13 @@
 #include "nss_stats_public.h"
 #endif
 
+#include "nss_fw_version.h"
+
 /**
  * @addtogroup nss_ipv4_subsystem
  * @{
  */
 
-/*
- * IPv4 connection flags (to be used with nss_ipv4_create::flags).
- */
-#define NSS_IPV4_CREATE_FLAG_NO_SEQ_CHECK 0x01
-		/**< Rule for not checking sequence numbers. */
-#define NSS_IPV4_CREATE_FLAG_BRIDGE_FLOW 0x02
-		/**< Rule that indicates pure bridge flow (no routing is involved). */
-#define NSS_IPV4_CREATE_FLAG_ROUTED 0x04	/**< Rule for a routed connection. */
-
-#define NSS_IPV4_CREATE_FLAG_DSCP_MARKING 0x08	/**< Rule for DSCP marking. */
-#define NSS_IPV4_CREATE_FLAG_VLAN_MARKING 0x10	/**< Rule for VLAN marking. */
-#define NSS_IPV4_CREATE_FLAG_QOS_VALID 0x20	/**< Rule for QoS is valid. */
-
-/**
- * nss_ipv4_create
- *	Information for an IPv4 flow or connection create rule.
- *
- * All fields must be passed in host-endian order.
- */
-struct nss_ipv4_create {
-	int32_t src_interface_num;
-				/**< Source interface number (virtual or physical). */
-	int32_t dest_interface_num;
-				/**< Destination interface number (virtual or physical). */
-	int32_t protocol;	/**< L4 protocol, e.g., TCP or UDP. */
-	uint32_t flags;		/**< Flags associated with this rule. */
-	uint32_t from_mtu;	/**< MTU of the incoming interface. */
-	uint32_t to_mtu;	/**< MTU of the outgoing interface. */
-	uint32_t src_ip;	/**< Source IP address. */
-	int32_t src_port;	/**< Source L4 port, e.g., TCP or UDP port. */
-	uint32_t src_ip_xlate;	/**< Translated source IP address (used with SNAT). */
-	int32_t src_port_xlate;	/**< Translated source L4 port (used with SNAT). */
-	uint32_t dest_ip;	/**< Destination IP address. */
-	int32_t dest_port;	/**< Destination L4 port, e.g., TCP or UDP port. */
-	uint32_t dest_ip_xlate;
-			/**< Translated destination IP address (used with DNAT). */
-	int32_t dest_port_xlate;
-			/**< Translated destination L4 port (used with DNAT). */
-	uint8_t src_mac[ETH_ALEN];
-			/**< Source MAC address. */
-	uint8_t dest_mac[ETH_ALEN];
-			/**< Destination MAC address. */
-	uint8_t src_mac_xlate[ETH_ALEN];
-			/**< Translated source MAC address (post-routing). */
-	uint8_t dest_mac_xlate[ETH_ALEN];
-			/**< Translated destination MAC address (post-routing). */
-	uint8_t flow_window_scale;	/**< Window scaling factor (TCP). */
-	uint32_t flow_max_window;	/**< Maximum window size (TCP). */
-	uint32_t flow_end;		/**< TCP window end. */
-	uint32_t flow_max_end;		/**< TCP window maximum end. */
-	uint32_t flow_pppoe_if_exist;
-			/**< Flow direction: PPPoE interface existence flag. */
-	int32_t flow_pppoe_if_num;
-			/**< Flow direction: PPPoE interface number. */
-	uint16_t ingress_vlan_tag;	/**< Ingress VLAN tag expected for this flow. */
-	uint8_t return_window_scale;
-			/**< Window scaling factor of the return direction (TCP). */
-	uint32_t return_max_window;
-			/**< Maximum window size of the return direction. */
-	uint32_t return_end;
-			/**< Flow end for the return direction. */
-	uint32_t return_max_end;
-			/**< Flow maximum end for the return direction. */
-	uint32_t return_pppoe_if_exist;
-			/**< Return direction: PPPoE interface existence flag. */
-	int32_t return_pppoe_if_num;
-			/**< Return direction: PPPoE interface number. */
-	uint16_t egress_vlan_tag;	/**< Egress VLAN tag expected for this flow. */
-	uint8_t spo_needed;		/**< Indicates whether SPO is required. */
-	struct net_device *top_ndev;	/**< Netdevice associated with the top interface. */
-	uint32_t param_a1;		/**< Custom parameter 1. */
-	uint32_t param_a2;		/**< Custom parameter 2. */
-	uint32_t param_a3;		/**< Custom parameter 3. */
-	uint32_t param_a4;		/**< Custom parameter 4. */
-	uint32_t qos_tag;		/**< Deprecated, will be removed soon. */
-	uint32_t flow_qos_tag;		/**< QoS tag value for the flow direction. */
-	uint32_t return_qos_tag;	/**< QoS tag value for the return direction. */
-	uint8_t dscp_itag;		/**< DSCP marking tag. */
-	uint8_t dscp_imask;		/**< DSCP marking input mask. */
-	uint8_t dscp_omask;		/**< DSCP marking output mask. */
-	uint8_t dscp_oval;		/**< DSCP marking output value. */
-	uint16_t vlan_itag;		/**< VLAN marking tag. */
-	uint16_t vlan_imask;		/**< VLAN marking input mask. */
-	uint16_t vlan_omask;		/**< VLAN marking output mask. */
-	uint16_t vlan_oval;		/**< VLAN marking output value. */
-	uint32_t in_vlan_tag[MAX_VLAN_DEPTH];
-			/**< Ingress VLAN tag expected for this flow. */
-	uint32_t out_vlan_tag[MAX_VLAN_DEPTH];
-			/**< Egress VLAN tag expected for this flow. */
-	uint8_t flow_dscp;		/**< IP DSCP value for the flow direction. */
-	uint8_t return_dscp;		/**< IP DSCP value for the return direction. */
-};
-
-/**
- * nss_ipv4_destroy
- *	Information for an IPv4 flow or connection destroy rule.
- */
-struct nss_ipv4_destroy {
-	int32_t protocol;	/**< L4 protocol ID. */
-	uint32_t src_ip;	/**< Source IP address. */
-	int32_t src_port;	/**< Source L4 port, e.g., TCP or UDP port. */
-	uint32_t dest_ip;	/**< Destination IP address. */
-	int32_t dest_port;	/**< Destination L4 port, e.g., TCP or UDP port. */
-};
-
 /**
  * nss_ipv4_message_types
  *	IPv4 bridge and routing rule message types.
@@ -219,12 +113,6 @@ enum nss_ipv4_stats_types {
 		/**< Number of IPv4 multicast connection destroy requests that missed the cache. */
 	NSS_IPV4_STATS_MC_CONNECTION_FLUSHES,
 		/**< Number of IPv4 multicast connection flushes. */
-	NSS_IPV4_STATS_CONNECTION_CREATE_INVALID_MIRROR_IFNUM,
-		/**< Number of IPv4 mirror connection requests with an invalid interface number. */
-	NSS_IPV4_STATS_CONNECTION_CREATE_INVALID_MIRROR_IFTYPE,
-		/**< Number of IPv4 mirror connection requests with an invalid interface type. */
-	NSS_IPV4_STATS_MIRROR_FAILURES,
-		/**< Number of IPv4 mirror failures. */
 	NSS_IPV4_STATS_MAX,
 		/**< Maximum message type. */
 };
@@ -252,18 +140,17 @@ enum nss_ipv4_stats_types {
  * carries an IPv4 payload within it.
  */
 #define NSS_IPV4_RULE_CREATE_FLAG_L2_ENCAP 0x80
+
 #define NSS_IPV4_RULE_CREATE_FLAG_DROP 0x100
 		/**< Rule to drop packets. */
 #define NSS_IPV4_RULE_CREATE_FLAG_EXCEPTION 0x200
 		/**< Rule to except packets. */
+
 #define NSS_IPV4_RULE_CREATE_FLAG_SRC_INTERFACE_CHECK 0x400
 		/**< Check the source interface for the rule. */
+
 #define NSS_IPV4_RULE_CREATE_FLAG_NO_SRC_IDENT 0x800
 		/**< Zero out the source identifier for the rule. */
-#define NSS_IPV4_RULE_CREATE_FLAG_NO_MAC 0x1000
-		/**< Flag to bypass writing MAC addresses. */
-#define NSS_IPV4_RULE_CREATE_FLAG_EMESH_SP 0x2000
-		/**< Mark rule as E-MESH Service Prioritization valid. */
 
 /*
  * Validity flags for rule creation.
@@ -287,16 +174,11 @@ enum nss_ipv4_stats_types {
 		/**< Destination MAC address fields are valid. */
 #define NSS_IPV4_RULE_CREATE_IGS_VALID 0x800
 		/**< Ingress shaping fields are valid. */
-#define NSS_IPV4_RULE_CREATE_IDENTIFIER_VALID 0x1000
-		/**< Identifier is valid. */
-#define NSS_IPV4_RULE_CREATE_MIRROR_VALID 0x2000	/**< Mirror fields are valid. */
 
 /*
  * Multicast command rule flags
  */
 #define NSS_IPV4_MC_RULE_CREATE_FLAG_MC_UPDATE 0x01	/**< Multicast rule update. */
-#define NSS_IPV4_MC_RULE_CREATE_FLAG_MC_EMESH_SP  0x02
-		/**< Mark multicast rule as E-MESH Service Prioritization valid. */
 
 /*
  * Multicast command validity flags
@@ -344,23 +226,6 @@ enum nss_ipv4_stats_types {
 #define NSS_IPV4_SRC_MAC_RETURN_VALID 0x02
 		/**< MAC address for the return interface is valid. */
 
-/*
- * Identifier valid flags (to be used with identifier_valid_flags field of nss_ipv4_identifier_rule structure)
- */
-#define NSS_IPV4_FLOW_IDENTIFIER_VALID 0x01
-		/**< Identifier for flow direction is valid. */
-#define NSS_IPV4_RETURN_IDENTIFIER_VALID 0x02
-		/**< Identifier for return direction is valid. */
-
-/*
- * Mirror valid flags (to be used with the valid field of nss_ipv4_mirror_rule structure)
- */
-#define NSS_IPV4_MIRROR_FLOW_VALID 0x01
-		/**< Mirror interface number for the flow direction is valid. */
-#define NSS_IPV4_MIRROR_RETURN_VALID 0x02
-		/**< Mirror interface number for the return direction is valid. */
-
-
 /**
  * nss_ipv4_5tuple
  *	Common 5-tuple information.
@@ -522,29 +387,6 @@ struct nss_ipv4_rps_rule {
 };
 
 /**
- * nss_ipv4_identifier_rule
- *	Identifier rule structure.
- */
-struct nss_ipv4_identifier_rule {
-	uint32_t identifier_valid_flags;
-		/**< Identifier validity flags. */
-	uint32_t flow_identifier;
-		/**< Identifier for flow direction. */
-	uint32_t return_identifier;
-		/**< Identifier for return direction. */
-};
-
-/**
- * nss_ipv4_mirror_rule
- *	Mirror rule structure.
- */
-struct nss_ipv4_mirror_rule {
-	uint32_t valid;			/**< Mirror validity flags. */
-	nss_if_num_t flow_ifnum;	/**< Flow mirror interface number. */
-	nss_if_num_t return_ifnum;	/**< Return mirror interface number. */
-};
-
-/**
  * nss_ipv4_error_response_types
  *	Error types for IPv4 messages.
  */
@@ -569,8 +411,6 @@ enum nss_ipv4_error_response_types {
 	NSS_IPV4_CR_HASH_BITMAP_INVALID,
 	NSS_IPV4_DR_HW_DECEL_FAIL_ERROR,
 	NSS_IPV4_CR_RETURN_EXIST_ERROR,
-	NSS_IPV4_CR_INVALID_IDENTIFIER,
-	NSS_IPV4_CR_EMESH_SP_CONFIG_INVALID,
 	NSS_IPV4_LAST
 };
 
@@ -610,10 +450,6 @@ struct nss_ipv4_rule_create_msg {
 			/**< RPS parameter. */
 	struct nss_ipv4_igs_rule igs_rule;
 			/**< Ingress shaping related accleration parameters. */
-	struct nss_ipv4_identifier_rule identifier;
-			/**< Rule for adding identifier. */
-	struct nss_ipv4_mirror_rule mirror_rule;
-			/**< Mirror rule parameter. */
 };
 
 /**
@@ -900,10 +736,10 @@ enum nss_ipv4_exception_events {
 	NSS_IPV4_EXCEPTION_EVENT_MC_PBUF_ALLOC_FAILURE,
 	NSS_IPV4_EXCEPTION_EVENT_PPPOE_BRIDGE_NO_ICME,
 	NSS_IPV4_EXCEPTION_EVENT_PPPOE_NO_SESSION,
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,0))
 	NSS_IPV4_EXCEPTION_EVENT_ICMP_IPV4_GRE_HEADER_INCOMPLETE,
 	NSS_IPV4_EXCEPTION_EVENT_ICMP_IPV4_ESP_HEADER_INCOMPLETE,
-	NSS_IPV4_EXCEPTION_EVENT_EMESH_PRIO_MISMATCH,
-	NSS_IPV4_EXCEPTION_EVENT_MC_UCAST_DMAC,
+#endif
 	NSS_IPV4_EXCEPTION_EVENT_MAX
 };
 
@@ -958,16 +794,6 @@ struct nss_ipv4_node_sync {
 
 	uint32_t ipv4_mc_connection_flushes;
 			/**< Number of multicast connection flushes. */
-
-	uint32_t ipv4_connection_create_invalid_mirror_ifnum;
-			/**< Number of failed create requests with an invalid mirror interface number. */
-
-	uint32_t ipv4_connection_create_invalid_mirror_iftype;
-			/**< Number of failed create requests with an invalid mirror interface type. */
-
-	uint32_t ipv4_mirror_failures;
-			/**< Mirror packet failed. */
-
 	uint32_t exception_events[NSS_IPV4_EXCEPTION_EVENT_MAX];
 			/**< Number of exception events. */
 };
--- a/exports/nss_ipv6.h
+++ b/exports/nss_ipv6.h
@@ -1,12 +1,9 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
- *
+ * Copyright (c) 2014-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
- *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -31,126 +28,6 @@
  */
 
 /**
- * Converts the format of an IPv6 address from Linux to NSS. @hideinitializer
- */
-#define IN6_ADDR_TO_IPV6_ADDR(ipv6, in6) \
-	{ \
-		((uint32_t *)ipv6)[0] = in6.in6_u.u6_addr32[0]; \
-		((uint32_t *)ipv6)[1] = in6.in6_u.u6_addr32[1]; \
-		((uint32_t *)ipv6)[2] = in6.in6_u.u6_addr32[2]; \
-		((uint32_t *)ipv6)[3] = in6.in6_u.u6_addr32[3]; \
-	}
-
-/**
- * Converts the format of an IPv6 address from NSS to Linux. @hideinitializer
- */
-#define IPV6_ADDR_TO_IN6_ADDR(in6, ipv6) \
-	{ \
-		in6.in6_u.u6_addr32[0] = ((uint32_t *)ipv6)[0]; \
-		in6.in6_u.u6_addr32[1] = ((uint32_t *)ipv6)[1]; \
-		in6.in6_u.u6_addr32[2] = ((uint32_t *)ipv6)[2]; \
-		in6.in6_u.u6_addr32[3] = ((uint32_t *)ipv6)[3]; \
-	}
-
-/**
- * Format of an IPv6 address (16 * 8 bits).
- */
-#define IPV6_ADDR_OCTAL_FMT "%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x"
-
-/**
- * Prints an IPv6 address (16 * 8 bits).
- */
-#define IPV6_ADDR_TO_OCTAL(ipv6) ((uint16_t *)ipv6)[0], ((uint16_t *)ipv6)[1], ((uint16_t *)ipv6)[2], ((uint16_t *)ipv6)[3], ((uint16_t *)ipv6)[4], ((uint16_t *)ipv6)[5], ((uint16_t *)ipv6)[6], ((uint16_t *)ipv6)[7]
-
-/*
- * IPv6 connection flags (to be used with nss_ipv6_create::flags.
- */
-#define NSS_IPV6_CREATE_FLAG_NO_SEQ_CHECK 0x1
-		/**< Indicates that sequence numbers are not to be checked. */
-#define NSS_IPV6_CREATE_FLAG_BRIDGE_FLOW 0x02
-		/**< Indicates that this is a pure bridge flow (no routing is involved). */
-#define NSS_IPV6_CREATE_FLAG_ROUTED 0x04	/**< Rule is for a routed connection. */
-#define NSS_IPV6_CREATE_FLAG_DSCP_MARKING 0x08	/**< Rule for DSCP marking. */
-#define NSS_IPV6_CREATE_FLAG_VLAN_MARKING 0x10	/**< Rule for VLAN marking. */
-#define NSS_IPV6_CREATE_FLAG_QOS_VALID 0x20	/**< Rule for Valid QoS. */
-
-/**
- * nss_ipv6_create
- *	Information for an IPv6 flow or connection create rule.
- *
- * All fields must be passed in host-endian order.
- */
-struct nss_ipv6_create {
-	int32_t src_interface_num;
-			/**< Source interface number (virtual or physical). */
-	int32_t dest_interface_num;
-			/**< Destination interface number (virtual or physical). */
-	int32_t protocol;	/**< L4 protocol, e.g., TCP or UDP,. */
-	uint32_t flags;		/**< Flags associated with this rule. */
-	uint32_t from_mtu;	/**< MTU of the incoming interface. */
-	uint32_t to_mtu;	/**< MTU of the outgoing interface. */
-	uint32_t src_ip[4];	/**< Source IP address. */
-	int32_t src_port;	/**< Source L4 port, e.g., TCP or UDP port. */
-	uint32_t dest_ip[4];	/**< Destination IP address. */
-	int32_t dest_port;	/**< Destination L4 port, e.g., TCP or UDP port. */
-	uint8_t src_mac[ETH_ALEN];	/**< Source MAC address. */
-	uint8_t dest_mac[ETH_ALEN];	/**< Destination MAC address. */
-	uint8_t flow_window_scale;	/**< Window scaling factor (TCP). */
-	uint32_t flow_max_window;	/**< Maximum window size (TCP). */
-	uint32_t flow_end;		/**< TCP window end. */
-	uint32_t flow_max_end;		/**< TCP window maximum end. */
-	uint32_t flow_pppoe_if_exist;
-			/**< Flow direction: PPPoE interface existence flag. */
-	int32_t flow_pppoe_if_num;
-			/**< Flow direction: PPPoE interface number. */
-	uint16_t ingress_vlan_tag;
-			/**< Ingress VLAN tag expected for this flow. */
-	uint8_t return_window_scale;
-			/**< Window scaling factor (TCP) for the return direction. */
-	uint32_t return_max_window;
-			/**< Maximum window size (TCP) for the return direction. */
-	uint32_t return_end;
-			/**< End for the return direction. */
-	uint32_t return_max_end;
-			/**< Maximum end for the return direction. */
-	uint32_t return_pppoe_if_exist;
-			/**< Return direction: PPPoE interface existence flag. */
-	int32_t return_pppoe_if_num;
-			/**< Return direction: PPPoE interface number. */
-	uint16_t egress_vlan_tag;	/**< Egress VLAN tag expected for this flow. */
-	uint32_t qos_tag;		/**< Deprecated; will be removed soon. */
-	uint32_t flow_qos_tag;		/**< QoS tag value for flow direction. */
-	uint32_t return_qos_tag;	/**< QoS tag value for the return direction. */
-	uint8_t dscp_itag;		/**< DSCP marking tag. */
-	uint8_t dscp_imask;		/**< DSCP marking input mask. */
-	uint8_t dscp_omask;		/**< DSCP marking output mask. */
-	uint8_t dscp_oval;		/**< DSCP marking output value. */
-	uint16_t vlan_itag;		/**< VLAN marking tag. */
-	uint16_t vlan_imask;		/**< VLAN marking input mask. */
-	uint16_t vlan_omask;		/**< VLAN marking output mask. */
-	uint16_t vlan_oval;		/**< VLAN marking output value. */
-	uint32_t in_vlan_tag[MAX_VLAN_DEPTH];
-					/**< Ingress VLAN tag expected for this flow. */
-	uint32_t out_vlan_tag[MAX_VLAN_DEPTH];
-					/**< Egress VLAN tag expected for this flow. */
-	uint8_t flow_dscp;		/**< IP DSCP value for flow direction. */
-	uint8_t return_dscp;		/**< IP DSCP value for the return direction. */
-	struct net_device *top_ndev;	/**< Netdevice associated with the top interface. */
-};
-
-/**
- * nss_ipv6_destroy
- *	Information for an IPv6 flow or connection destroy rule.
- */
-struct nss_ipv6_destroy {
-	int32_t protocol;	/**< L4 protocol, e.g., TCP or UDP. */
-	uint32_t src_ip[4];	/**< Source IP address. */
-	int32_t src_port;	/**< Source L4 port, e.g., TCP or UDP port. */
-	uint32_t dest_ip[4];	/**< Destination IP address. */
-	int32_t dest_port;	/**< Destination L4 port, e.g., TCP or UDP port. */
-};
-
-/**
  * nss_ipv6_stats_types
  *	IPv6 node statistics.
  */
@@ -199,14 +76,6 @@ enum nss_ipv6_stats_types {
 					/**< Number of IPv6 multicast connection destroy requests that missed the cache. */
 	NSS_IPV6_STATS_MC_CONNECTION_FLUSHES,
 					/**< Number of IPv6 multicast connection flushes. */
-	NSS_IPV6_STATS_CONNECTION_CREATE_INVALID_MIRROR_IFNUM,
-		/**< Number of IPv6 mirror connection requests with an invalid interface number. */
-	NSS_IPV6_STATS_CONNECTION_CREATE_INVALID_MIRROR_IFTYPE,
-		/**< Number of IPv6 mirror connection requests with an invalid interface type. */
-
-	NSS_IPV6_STATS_MIRROR_FAILURES,
-		/**< Number of IPv6 mirror failures. */
-
 	NSS_IPV6_STATS_MAX,
 					/**< Maximum message type. */
 };
@@ -270,14 +139,11 @@ enum nss_ipv6_dscp_map_actions {
 		/**< Drop packets. */
 #define NSS_IPV6_RULE_CREATE_FLAG_EXCEPTION 0x200
 		/**< Rule to except packets. */
+
 #define NSS_IPV6_RULE_CREATE_FLAG_SRC_INTERFACE_CHECK 0x400
 		/**< Check the source interface for the rule. */
 #define NSS_IPV6_RULE_CREATE_FLAG_NO_SRC_IDENT 0x800
 		/**< Flag to indicate NSS to ignore src_ident and use value 0 for it during rule addition. */
-#define NSS_IPV6_RULE_CREATE_FLAG_NO_MAC 0x1000
-		/**< Flag to bypass writing MAC addresses. */
-#define NSS_IPV6_RULE_CREATE_FLAG_EMESH_SP 0x2000
-		/**< Mark rule as E-MESH Service Prioritization valid. */
 
 /*
  * IPv6 rule creation validity flags.
@@ -299,15 +165,12 @@ enum nss_ipv6_dscp_map_actions {
 #define NSS_IPV6_RULE_CREATE_DEST_MAC_VALID 0x400
 		/**< Destination MAC address fields are valid. */
 #define NSS_IPV6_RULE_CREATE_IGS_VALID 0x800	/**< Ingress shaping fields are valid. */
-#define NSS_IPV6_RULE_CREATE_IDENTIFIER_VALID 0x1000	/**< Identifier is valid. */
-#define NSS_IPV6_RULE_CREATE_MIRROR_VALID 0x2000	/**< Mirror fields are valid. */
+
 
 /*
  * Multicast command rule flags
  */
 #define NSS_IPV6_MC_RULE_CREATE_FLAG_MC_UPDATE 0x01	/**< Multicast rule update. */
-#define NSS_IPV6_MC_RULE_CREATE_FLAG_MC_EMESH_SP  0x02
-		/**< Mark multicast rule as E-MESH Service Prioritization valid. */
 
 /*
  * Multicast command validity flags
@@ -353,22 +216,6 @@ enum nss_ipv6_dscp_map_actions {
 #define NSS_IPV6_SRC_MAC_RETURN_VALID 0x02
 		/**< MAC address for the return interface is valid. */
 
-/*
- * Identifier valid flags (to be used with identifier_valid_flags field of nss_ipv6_identifier_rule structure)
- */
-#define NSS_IPV6_FLOW_IDENTIFIER_VALID 0x01
-		/**< Identifier for flow direction is valid. */
-#define NSS_IPV6_RETURN_IDENTIFIER_VALID 0x02
-		/**< Identifier for return direction is valid. */
-
-/*
- * Mirror valid flags (to be used with the valid field of nss_ipv6_mirror_rule structure)
- */
-#define NSS_IPV6_MIRROR_FLOW_VALID 0x01
-		/**< Mirror interface number for the flow direction is valid. */
-#define NSS_IPV6_MIRROR_RETURN_VALID 0x02
-		/**< Mirror interface number for the return direction is valid. */
-
 /**
  * nss_ipv6_exception_events
  *	Exception events from an IPv6 bridge or route handler.
@@ -429,12 +276,14 @@ enum nss_ipv6_exception_events {
 	NSS_IPV6_EXCEPTION_EVENT_TUNIPIP6_NEEDS_FRAGMENTATION,
 	NSS_IPV6_EXCEPTION_EVENT_PPPOE_BRIDGE_NO_ICME,
 	NSS_IPV6_EXCEPTION_EVENT_DONT_FRAG_SET,
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,0))
 	NSS_IPV6_EXCEPTION_EVENT_REASSEMBLY_NOT_SUPPORTED,
+#endif
 	NSS_IPV6_EXCEPTION_EVENT_PPPOE_NO_SESSION,
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,0))
 	NSS_IPV6_EXCEPTION_EVENT_ICMP_IPV6_GRE_HEADER_INCOMPLETE,
 	NSS_IPV6_EXCEPTION_EVENT_ICMP_IPV6_ESP_HEADER_INCOMPLETE,
-	NSS_IPV6_EXCEPTION_EVENT_EMESH_PRIO_MISMATCH,
-	NSS_IPV6_EXCEPTION_EVENT_MC_UCAST_DMAC,
+#endif
 	NSS_IPV6_EXCEPTION_EVENT_MAX
 };
 
@@ -589,29 +438,6 @@ struct nss_ipv6_rps_rule {
 };
 
 /**
- * nss_ipv6_identifier_rule
- *	Identifier rule structure.
- */
-struct nss_ipv6_identifier_rule {
-	uint32_t identifier_valid_flags;
-		/**< Identifier validity flags. */
-	uint32_t flow_identifier;
-		/**< Identifier for flow direction. */
-	uint32_t return_identifier;
-		/**< Identifier for return direction. */
-};
-
-/**
- * nss_ipv6_mirror_rule
- *	Mirror rule structure.
- */
-struct nss_ipv6_mirror_rule {
-	uint32_t valid;			/**< Mirror validity flags. */
-	nss_if_num_t flow_ifnum;	/**< Flow mirror interface number. */
-	nss_if_num_t return_ifnum;	/**< Return mirror interface number. */
-};
-
-/**
  * nss_ipv6_error_response_types
  *	Error types for IPv6 messages.
  */
@@ -647,24 +473,24 @@ enum nss_ipv6_error_response_types {
 		/**< Invalid interface for updating multicast. */
 	NSS_IPV6_CR_ACCEL_MODE_CONFIG_INVALID,
 		/**< Invalid config value for acceleration mode. */
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,0))
 	NSS_IPV6_CR_INVALID_MSG_ERROR,
 		/**< Invalid message size error. */
 	NSS_IPV6_CR_DSCP2PRI_PRI_INVALID,
 		/**< Priority value out of range error. */
 	NSS_IPV6_CR_DSCP2PRI_CONFIG_INVALID,
 		/**< Invalid DSCP value. */
+#endif
 	NSS_IPV6_CR_INVALID_RPS,
 		/**< Invalid RPS Value. */
 	NSS_IPV6_HASH_BITMAP_INVALID,
 		/**< Invalid hash bitmap. */
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,0))
 	NSS_IPV6_DR_HW_DECEL_FAIL_ERROR,
 		/**< Hardware deceleration fail error. */
 	NSS_IPV6_CR_RETURN_EXIST_ERROR,
 		/**< Rule creation failed because a 5-tuple return already exists. */
-	NSS_IPV6_CR_INVALID_IDENTIFIER,
-		/**< Invalid identifier value. */
-	NSS_IPV6_CR_EMESH_SP_CONFIG_INVALID,
-		/**< Rule creation failed because Qos tag was not set for a Emesh SP rule. */
+#endif
 	NSS_IPV6_LAST
 		/**< Maximum number of error responses. */
 };
@@ -705,10 +531,6 @@ struct nss_ipv6_rule_create_msg {
 			/**< RPS parameter. */
 	struct nss_ipv6_igs_rule igs_rule;
 			/**< Ingress shaping related accleration parameters. */
-	struct nss_ipv6_identifier_rule identifier;
-			/**< Rule for adding identifier. */
-	struct nss_ipv6_mirror_rule mirror_rule;
-			/**< Mirror rule parameter. */
 };
 
 /**
@@ -954,16 +776,6 @@ struct nss_ipv6_node_sync {
 
 	uint32_t ipv6_mc_connection_flushes;
 			/**< Number of multicast connection flushes. */
-
-	uint32_t ipv6_connection_create_invalid_mirror_ifnum;
-			/**< Number of failed create requests with an invalid mirror interface number. */
-
-	uint32_t ipv6_connection_create_invalid_mirror_iftype;
-			/**< Number of failed create requests with an invalid mirror interface type. */
-
-	uint32_t ipv6_mirror_failures;
-			/**< Mirror packet failed. */
-
 	uint32_t exception_events[NSS_IPV6_EXCEPTION_EVENT_MAX];
 			/**< Number of exception events. */
 };
--- a/exports/nss_lso_rx.h
+++ b/exports/nss_lso_rx.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
@@ -17,7 +17,7 @@
  */
 
 /*
- * @file nss_lso_rx.h
+ * nss_lso_rx.h
  *	NSS driver LSO (Large Send Offload) Rx header file.
  */
 
--- a/exports/nss_map_t.h
+++ b/exports/nss_map_t.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -37,20 +37,6 @@
 #define NSS_MAX_MAP_T_DYNAMIC_INTERFACES 4
 
 /**
- * MAP-T metadata flag.
- */
-#define NSS_MAPT_MDATA_FLAG_DF_BIT  (1 << 0)
-
-/**
- * nss_map_t_mdata
- *         MAP-T metadata
- */
-struct nss_map_t_mdata {
-	uint16_t flags;				/**< Metadata flags. */
-	uint16_t res[6];			/**< Reserved for future use. */
-};
-
-/**
  * nss_map_t_msg_types
  *	Message types for MAP-T requests and responses.
  */
--- a/exports/nss_mirror.h
+++ b/exports/nss_mirror.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
@@ -79,20 +79,6 @@ enum nss_mirror_error_type {
 };
 
 /**
- * nss_mirror_stats
- *	Mirror interface debug statistics.
- */
-enum nss_mirror_stats {
-	NSS_MIRROR_STATS_PKTS,			/**< Number of packets exceptioned to host. */
-	NSS_MIRROR_STATS_BYTES,			/**< Number of bytes exceptioned to host. */
-	NSS_MIRROR_STATS_TX_SEND_FAIL,		/**< Transmit send failures. */
-	NSS_MIRROR_STATS_DEST_LOOKUP_FAIL,	/**< Destination lookup failures. */
-	NSS_MIRROR_STATS_MEM_ALLOC_FAIL,	/**< Memory allocation failures. */
-	NSS_MIRROR_STATS_COPY_FAIL,		/**< Copy failures. */
-	NSS_MIRROR_STATS_MAX			/**< Maximum statistics count. */
-};
-
-/**
  * nss_mirror_configure_msg
  *	Mirror interface configuration information.
  */
@@ -134,16 +120,6 @@ struct nss_mirror_stats_sync_msg {
 };
 
 /**
- * nss_mirror_stats_notification
- *	Mirror transmission statistics structure.
- */
-struct nss_mirror_stats_notification {
-	uint64_t stats_ctx[NSS_MIRROR_STATS_MAX];	/**< Context transmission statistics. */
-	uint32_t core_id;				/**< Core ID. */
-	uint32_t if_num;				/**< Interface number. */
-};
-
-/**
  * nss_mirror_msg
  *	Data for sending and receiving mirror interface messages.
  */
@@ -230,17 +206,6 @@ extern nss_tx_status_t nss_mirror_tx_msg
 extern nss_tx_status_t nss_mirror_tx_msg_sync(struct nss_ctx_instance *nss_ctx, struct nss_mirror_msg *msg);
 
 /**
- * nss_mirror_unregister_if
- *	Deregisters a mirror interface from the NSS.
- *
- * @param[in] if_num  NSS interface number.
- *
- * @return
- * None.
- */
-extern void nss_mirror_unregister_if(uint32_t if_num);
-
-/**
  * nss_mirror_register_if
  *	Registers a mirror interface with the NSS for sending and receiving messages.
  *
@@ -264,6 +229,17 @@ extern struct nss_ctx_instance *nss_mirr
 		struct net_device *netdev, uint32_t features);
 
 /**
+ * nss_mirror_unregister_if
+ *	Deregisters a mirror interface from the NSS.
+ *
+ * @param[in] if_num  NSS interface number.
+ *
+ * @return
+ * None.
+ */
+extern void nss_mirror_unregister_if(uint32_t if_num);
+
+/**
  * nss_mirror_verify_if_num
  *	Verify whether the interface is an mirror interface or not.
  *
@@ -284,34 +260,6 @@ extern bool nss_mirror_verify_if_num(uin
 extern void nss_mirror_register_handler(void);
 
 /**
- * nss_mirror_stats_unregister_notifier
- *	Deregisters a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_mirror_stats_unregister_notifier(struct notifier_block *nb);
-
-/**
- * nss_mirror_stats_register_notifier
- *	Registers a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_mirror_stats_register_notifier(struct notifier_block *nb);
-
-/**
  * @}
  */
 #endif
--- a/exports/nss_n2h.h
+++ b/exports/nss_n2h.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -62,7 +62,6 @@ struct nss_n2h_cfg_pvt {
 	struct nss_n2h_payload_info empty_buf_pool_info;	/**< Empty buffer pool information. */
 	struct nss_n2h_payload_info empty_paged_buf_pool_info;	/**< Paged buffer pool information. */
 	int wifi_pool;						/**< Size of the empty Wi-Fi buffer pool. */
-	int shaper_pool;					/**< Size of the empty shaper pool. */
 	int response;						/**< Response from the firmware. */
 };
 
@@ -74,40 +73,43 @@ struct nss_n2h_cfg_pvt {
  */
 enum nss_n2h_stats_types {
 	NSS_N2H_STATS_QUEUE_DROPPED = NSS_STATS_NODE_MAX,
-		/**< Number of packets dropped because the exception queue is too full. */
-	NSS_N2H_STATS_TOTAL_TICKS,	/**< Total clock ticks spend inside the N2H. */
-	NSS_N2H_STATS_WORST_CASE_TICKS,	/**< Worst case iteration of the exception path in ticks. */
-	NSS_N2H_STATS_ITERATIONS,	/**< Number of iterations around the N2H. */
-	NSS_N2H_STATS_PBUF_OCM_TOTAL_COUNT,	/**< Number of pbuf OCM total count. */
-	NSS_N2H_STATS_PBUF_OCM_FREE_COUNT,	/**< Number of pbuf OCM free count. */
+					/* Number of packets dropped because the exception queue is too full */
+	NSS_N2H_STATS_TOTAL_TICKS,	/* Total clock ticks spend inside the N2H */
+	NSS_N2H_STATS_WORST_CASE_TICKS,	/* Worst case iteration of the exception path in ticks */
+	NSS_N2H_STATS_ITERATIONS,	/* Number of iterations around the N2H */
+
 	NSS_N2H_STATS_PBUF_OCM_ALLOC_FAILS_WITH_PAYLOAD,
-					/**< Number of pbuf OCM allocations that have failed with payload. */
+						/* Number of pbuf ocm allocations that have failed with payload */
+	NSS_N2H_STATS_PBUF_OCM_FREE_COUNT,	/* Number of pbuf ocm free count */
+	NSS_N2H_STATS_PBUF_OCM_TOTAL_COUNT,	/* Number of pbuf ocm total count */
 	NSS_N2H_STATS_PBUF_OCM_ALLOC_FAILS_NO_PAYLOAD,
-					/**< Number of pbuf OCM allocations that have failed without payload. */
-	NSS_N2H_STATS_PBUF_DEFAULT_TOTAL_COUNT,	/**< Number of pbuf default total count. */
-	NSS_N2H_STATS_PBUF_DEFAULT_FREE_COUNT,	/**< Number of pbuf default free count. */
+						/* Number of pbuf ocm allocations that have failed without payload */
+
 	NSS_N2H_STATS_PBUF_DEFAULT_ALLOC_FAILS_WITH_PAYLOAD,
-					/**< Number of pbuf default allocations that have failed with payload. */
+						/* Number of pbuf default allocations that have failed with payload */
+
+	NSS_N2H_STATS_PBUF_DEFAULT_FREE_COUNT,	/* Number of pbuf default free count */
+	NSS_N2H_STATS_PBUF_DEFAULT_TOTAL_COUNT,	/* Number of pbuf default total count */
 	NSS_N2H_STATS_PBUF_DEFAULT_ALLOC_FAILS_NO_PAYLOAD,
-	/**< Number of pbuf default allocations that have failed without payload. */
+						/* Number of pbuf default allocations that have failed without payload */
 
-	NSS_N2H_STATS_PAYLOAD_ALLOC_FAILS,	/**< Number of pbuf allocations that have failed because there were no free payloads. */
-	NSS_N2H_STATS_PAYLOAD_FREE_COUNT,	/**< Number of free payloads that exist. */
+	NSS_N2H_STATS_PAYLOAD_ALLOC_FAILS,	/* Number of pbuf allocations that have failed because there were no free payloads */
+	NSS_N2H_STATS_PAYLOAD_FREE_COUNT,	/* Number of free payloads that exist */
 
-	NSS_N2H_STATS_H2N_CONTROL_PACKETS,	/**< Control packets received from HLOS. */
-	NSS_N2H_STATS_H2N_CONTROL_BYTES,	/**< Control bytes received from HLOS. */
-	NSS_N2H_STATS_N2H_CONTROL_PACKETS,	/**< Control packets sent to HLOS. */
-	NSS_N2H_STATS_N2H_CONTROL_BYTES,	/**< Control bytes sent to HLOS. */
-
-	NSS_N2H_STATS_H2N_DATA_PACKETS,		/**< Data packets received from HLOS. */
-	NSS_N2H_STATS_H2N_DATA_BYTES,		/**< Data bytes received from HLOS. */
-	NSS_N2H_STATS_N2H_DATA_PACKETS,		/**< Data packets sent to HLOS. */
-	NSS_N2H_STATS_N2H_DATA_BYTES,		/**< Data bytes sent to HLOS. */
-	NSS_N2H_STATS_N2H_TOT_PAYLOADS,		/**< Number of payloads in NSS. */
-	NSS_N2H_STATS_N2H_INTERFACE_INVALID,	/**< Number of bad interface access. */
-	NSS_N2H_STATS_ENQUEUE_RETRIES,		/**< Number of enqueue retries by N2H. */
+	NSS_N2H_STATS_H2N_CONTROL_PACKETS,	/* Control packets received from HLOS */
+	NSS_N2H_STATS_H2N_CONTROL_BYTES,	/* Control bytes received from HLOS */
+	NSS_N2H_STATS_N2H_CONTROL_PACKETS,	/* Control packets sent to HLOS */
+	NSS_N2H_STATS_N2H_CONTROL_BYTES,	/* Control bytes sent to HLOS */
+
+	NSS_N2H_STATS_H2N_DATA_PACKETS,		/* Data packets received from HLOS */
+	NSS_N2H_STATS_H2N_DATA_BYTES,		/* Data bytes received from HLOS */
+	NSS_N2H_STATS_N2H_DATA_PACKETS,		/* Data packets sent to HLOS */
+	NSS_N2H_STATS_N2H_DATA_BYTES,		/* Data bytes sent to HLOS */
+	NSS_N2H_STATS_N2H_TOT_PAYLOADS,		/* No. of payloads in NSS */
+	NSS_N2H_STATS_N2H_INTERFACE_INVALID,	/* No. of bad interface access */
+	NSS_N2H_STATS_ENQUEUE_RETRIES,		/* No. of enqueue retries by N2H */
 
-	NSS_N2H_STATS_MAX,			/**< Maximum message type. */
+	NSS_N2H_STATS_MAX,
 };
 
 /**
@@ -133,7 +135,6 @@ enum nss_n2h_metadata_types {
 	NSS_TX_METADATA_TYPE_N2H_QUEUE_LIMIT_CFG,
 	NSS_TX_METADATA_TYPE_N2H_PAGED_BUFFER_POOL_INIT,
 	NSS_TX_METADATA_TYPE_N2H_HOST_BACK_PRESSURE_CFG,
-	NSS_TX_METADATA_TYPE_N2H_SHAPER_POOL_CFG,
 	NSS_METADATA_TYPE_N2H_MAX,
 };
 
@@ -362,24 +363,6 @@ struct nss_n2h_host_back_pressure {
 };
 
 /**
- * nss_n2h_shaper_mem_cfg_msg
- *	Shaper memory configuration message.
- */
-struct nss_n2h_shaper_mem_cfg_msg {
-	uint32_t mem_blk_size;	/**< Size of the memory block. */
-	uint32_t num_blks;		/**< Number of memory blocks. */
-
-	uint32_t pool_addr[MAX_PAGES_PER_MSG];
-			/**< Buffer addresses. */
-	nss_ptr_t pool_vaddr[MAX_PAGES_PER_MSG];
-			/**< Virtual addresses of the buffers. */
-#ifndef __LP64__
-	uint32_t padding[MAX_PAGES_PER_MSG];
-			/**< Padding that fits up to 64 bits. Do not reuse. */
-#endif
-};
-
-/**
  * nss_n2h_msg
  *	Data for sending and receiving N2H messages.
  */
@@ -426,8 +409,6 @@ struct nss_n2h_msg {
 				/**< Paged buffer pool initialization. */
 		struct nss_n2h_host_back_pressure host_bp_cfg;
 				/**< Host back pressure configuration. */
-		struct nss_n2h_shaper_mem_cfg_msg shaper_mem_cfg;
-				/**< Shaper memory configuration. */
 	} msg;			/**< Message payload. */
 };
 
--- a/exports/nss_phy_if.h
+++ b/exports/nss_phy_if.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2020, 2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
@@ -17,7 +17,7 @@
  */
 
 /**
- * @file nss_phy_if.h
+ * @file nss_phy_if.h.h
  *	NSS physical interface definitions.
  */
 
--- a/exports/nss_ppe.h
+++ b/exports/nss_ppe.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016-2018, 2020-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -22,8 +22,6 @@
 #ifndef _NSS_PPE_H_
 #define _NSS_PPE_H_
 
-typedef int32_t nss_ppe_port_t;
-
 /**
  * @addtogroup nss_ppe_subsystem
  * @{
@@ -54,38 +52,9 @@ enum nss_ppe_sc_type {
 	NSS_PPE_SC_PTP,			/**< Service code for PTP packets. */
 	NSS_PPE_SC_VLAN_FILTER_BYPASS,	/**< VLAN filter bypass for bridge flows between 2 different VSIs. */
 	NSS_PPE_SC_L3_EXCEPT,		/**< Indicate exception post tunnel/TAP operation. */
-	NSS_PPE_SC_SPF_BYPASS,		/**< Source port filtering bypass in PPE. */
 	NSS_PPE_SC_MAX,			/**< Maximum service code. */
 };
 
-/**
- * nss_ppe_stats_unregister_notifier
- *	Deregisters a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_ppe_stats_unregister_notifier(struct notifier_block *nb);
-
-/**
- * nss_ppe_stats_register_notifier
- *	Registers a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_ppe_stats_register_notifier(struct notifier_block *nb);
-
 /** @} */ /* end_addtogroup nss_ppe_subsystem */
 
 #endif /* _NSS_PPE_H_ */
--- a/exports/nss_project.h
+++ b/exports/nss_project.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017-2018, 2021 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -38,12 +38,6 @@
 #define NSS_PROJECT_IRQS_PER_MESSAGE 32
 
 /**
- *  Maximum possible value of priority after classification
- *  at an ingress interface.
- */
-#define NSS_PROJECT_PRI_MQ_MAP_MAX_SIZE 16
-
-/**
  * nss_project_message_types
  *	Project message types.
  */
@@ -52,8 +46,6 @@ enum nss_project_message_types {
 			/**< Message to enable or disable worker thread statistics. */
 	NSS_PROJECT_MSG_WT_STATS_NOTIFY,
 			/**< NSS to HLOS message containing worker thread statistics. */
-	NSS_PROJECT_MSG_SET_QUEUE_PRI_MAP_CFG,
-			/**< Message to configure priority to multi-queue mapping. */
 	NSS_PROJECT_MSG_MAX,
 };
 
@@ -68,8 +60,6 @@ enum nss_project_error_types {
 			/**< The firmware does not support worker thread statistics. */
 	NSS_PROJECT_ERROR_WT_STATS_REDUNDANT_ENABLE,
 			/**< The firmware received a redundant request to enable worker thread statistics. */
-	NSS_PROJECT_ERROR_MQ_NUMBER_INVALID,
-			/**< The firmware received an invalid multi-queue number. */
 	NSS_PROJECT_ERROR_MAX,
 };
 
@@ -121,15 +111,6 @@ struct nss_project_msg_wt_stats_notify {
 };
 
 /**
- * nss_project_msg_pri_mq_map_cfg
- * 	NSS priority to multi-queue mapping configuration.
- */
-struct nss_project_msg_pri_mq_map_cfg {
-	uint8_t pri_mq_map[NSS_PROJECT_PRI_MQ_MAP_MAX_SIZE];
-				/**< Priority to multi-queue mapping array. */
-};
-
-/**
  * nss_project_msg
  *	General message structure for project messages.
  */
@@ -144,8 +125,6 @@ struct nss_project_msg {
 				/**< Enable or disable worker thread statistics. */
 		struct nss_project_msg_wt_stats_notify wt_stats_notify;
 				/**< One-way worker thread statistics message. */
-		struct nss_project_msg_pri_mq_map_cfg pri_mq_map_cfg;
-				/**< Configure priority to multi-queue message. */
 	} msg;			/**< Message payload. */
 };
 
@@ -191,17 +170,6 @@ void nss_project_unregister_sysctl(void)
 void nss_project_register_handler(struct nss_ctx_instance *nss_ctx);
 
 /**
- * nss_project_pri_mq_map_configure
- * 	Configures priority to multi-queue mapping.
- *
- * @param[in] nss_ctx		Pointer to the NSS context.
- *
- * @return
- * Status of the configuration update operation.
- */
-extern nss_tx_status_t nss_project_pri_mq_map_configure(struct nss_ctx_instance *nss_ctx);
-
-/**
  * @}
  */
 
--- a/exports/nss_qrfs.h
+++ b/exports/nss_qrfs.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017-2018, 2021 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -110,7 +110,6 @@ struct nss_qrfs_msg {
 	} msg;			/**< Message payload. */
 };
 
-#ifdef __KERNEL__
 /**
  * Callback function for receiving QRFS messages.
  *
@@ -177,23 +176,6 @@ void nss_qrfs_notify_unregister(int core
  * Status of the Tx operation.
  */
 nss_tx_status_t nss_qrfs_set_flow_rule(struct sk_buff *skb, uint32_t cpu, uint32_t action);
-/**
- * nss_qrfs_configure_flow_rule
- *	Configures and sends a QRFS message to the NSS core to configure(add/remove) the flow rule.
- *
- * @param[in] dst_addr	Destination IP address.
- * @param[in] src_addr	Source IP address.
- * @param[in] dst_port	Destination port.
- * @param[in] src_port	Source port.
- * @param[in] version	IP version.
- * @param[in] proto	Protocol.
- * @param[in] cpu	CPU number to be offloaded to.
- * @param[in] type	Type of action to perform on the flow table, can be add or delete.
- *
- * @return
- * Status of the Tx operation.
- */
-nss_tx_status_t nss_qrfs_configure_flow_rule(uint32_t *dst_addr, uint32_t *src_addr, uint16_t dst_port, uint16_t src_port, uint32_t version, uint16_t proto, uint16_t cpu, enum nss_qrfs_msg_types type);
 
 /**
  * nss_qrfs_init
@@ -208,5 +190,4 @@ void nss_qrfs_init(void);
  * @}
  */
 
-#endif
 #endif /* __NSS_QRFS_H */
--- a/exports/nss_qvpn.h
+++ b/exports/nss_qvpn.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, 2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -27,6 +27,10 @@
  * @{
  */
 
+#define NSS_QVPN_INTERFACE_MAX_LONG BITS_TO_LONGS(NSS_MAX_NET_INTERFACES)	/**< QVPN interface mapping bits. */
+#define NSS_QVPN_STATS_MAX_LINES (NSS_STATS_NODE_MAX + 32)			/**< Maxminum number of lines for QVPN statistics dump. */
+#define NSS_QVPN_STATS_SIZE_PER_IF (NSS_STATS_MAX_STR_LENGTH * NSS_QVPN_STATS_MAX_LINES)	/**< Total number of statistics per QVPN interface. */
+
 #define NSS_QVPN_CMDS_MAX 10			/**< Maximum number of QVPN commands supported. */
 #define NSS_QVPN_VPN_HDR_HEAD_SIZE_MAX 64	/**< Maximum size of QVPN header. */
 #define NSS_QVPN_VPN_HDR_TAIL_SIZE_MAX 32	/**< Maximum size of QVPN tail. */
@@ -290,16 +294,6 @@ struct nss_qvpn_stats_sync_msg {
 };
 
 /**
- * nss_qvpn_stats_notification
- *	QVPN transmission statistics structure.
- */
-struct nss_qvpn_stats_notification {
-	uint64_t stats_ctx[NSS_STATS_NODE_MAX];		/**< Context transmission statistics. */
-	uint32_t core_id;				/**< Core ID. */
-	uint32_t if_num;				/**< Interface number. */
-};
-
-/**
  * nss_qvpn_msg
  *	QVPN message structure for configuration and statistics.
  */
@@ -426,17 +420,6 @@ typedef void (*nss_qvpn_callback_t)(stru
 typedef void (*nss_qvpn_msg_callback_t)(void *app_data, struct nss_cmn_msg *msg);
 
 /**
- * nss_qvpn_unregister_if
- *	Deregisters the QVPN interface from the NSS.
- *
- * @param[in] if_num              NSS interface number.
- *
- * @return
- * None.
- */
-void nss_qvpn_unregister_if(uint32_t if_num);
-
-/**
  * nss_qvpn_register_if
  *	Register to send/receive QVPN messages to NSS.
  *
@@ -459,6 +442,17 @@ struct nss_ctx_instance *nss_qvpn_regist
 			uint32_t features, void *app_ctx);
 
 /**
+ * nss_qvpn_unregister_if
+ *	Deregisters the QVPN interface from the NSS.
+ *
+ * @param[in] if_num              NSS interface number.
+ *
+ * @return
+ * None.
+ */
+void nss_qvpn_unregister_if(uint32_t if_num);
+
+/**
  * nss_qvpn_ifnum_with_core_id
  *	Gets the QVPN interface number with the core ID.
  *
@@ -488,34 +482,6 @@ void nss_qvpn_register_handler(void);
 unsigned long *nss_qvpn_ifmap_get(void);
 
 /**
- * nss_qvpn_stats_unregister_notifier
- *	Deregisters a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_qvpn_stats_unregister_notifier(struct notifier_block *nb);
-
-/**
- * nss_qvpn_stats_register_notifier
- *	Registers a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_qvpn_stats_register_notifier(struct notifier_block *nb);
-
-/**
  * @}
  */
 
--- a/exports/nss_rmnet_rx.h
+++ b/exports/nss_rmnet_rx.h
@@ -18,7 +18,7 @@
 
 /*
  * @file nss_rmnet_rx.h
- *	NSS RMNET interface message Structure and APIs
+ *	NSS Virtual interface message Structure and APIs
  */
 
 #ifndef __NSS_RMNET_RX_H
@@ -58,7 +58,7 @@ enum nss_rmnet_rx_msg_types {
 
 /**
  * nss_rmnet_rx_error_types
- *	Error types for the RMNET interface.
+ *	Error types for the virtual interface.
  */
 enum nss_rmnet_rx_error_types {
 	NSS_RMNET_RX_SUCCESS,				/**< No error. */
@@ -125,19 +125,19 @@ struct nss_rmnet_rx_msg {
 	struct nss_cmn_msg cm;		/**< Common message header. */
 
 	/**
-	 * Payload of an RMNET interface message.
+	 * Payload of a virtual interface message.
 	 */
 	union {
 		struct nss_rmnet_rx_config_msg if_config;
-				/**< Rule for creating an RMNET interface. */
+				/**< Rule for creating a virtual interface. */
 		struct nss_rmnet_rx_stats stats;
-				/**< RMNET interface statistics. */
+				/**< Virtual interface statistics. */
 	} msg;			/**< Message payload. */
 };
 
 /**
  * Callback to transmit interface data received from NSS
- * to the transmit path of the RMNET interface.
+ * to the transmit path of the virtual interface.
  *
  * @datatypes
  * net_device \n
@@ -183,8 +183,8 @@ struct nss_rmnet_rx_handle {
 	int32_t if_num_h2n;			/**< Redirect interface number on host-to-NSS path. */
 	struct net_device *ndev;		/**< Associated network device. */
 	struct nss_rmnet_rx_pvt *pvt;		/**< Private data structure. */
-	uint64_t *stats_n2h;			/**< RMNET interface statistics from NSS-to-host. */
-	uint64_t *stats_h2n;			/**< RMNET interface statistics from host-to-NSS. */
+	uint64_t *stats_n2h;			/**< Virtual interface statistics from NSS-to-host. */
+	uint64_t *stats_h2n;			/**< Virtual interface statistics from host-to-NSS. */
 	atomic_t refcnt;			/**< Reference count. */
 	nss_rmnet_rx_msg_callback_t cb;		/**< Message callback. */
 	void *app_data;		/**< Application data to be passed to the callback. */
@@ -192,12 +192,12 @@ struct nss_rmnet_rx_handle {
 
 /**
  * nss_rmnet_rx_destroy_sync
- *	Destroys the RMNET interface synchronously.
+ *	Destroys the virtual interface synchronously.
  *
  * @datatypes
  * nss_rmnet_rx_handle
  *
- * @param[in,out] handle  Pointer to the RMNET interface handle (provided during
+ * @param[in,out] handle  Pointer to the virtual interface handle (provided during
  *                        dynamic interface allocation).
  *
  * @return
@@ -210,7 +210,7 @@ extern nss_tx_status_t nss_rmnet_rx_dest
 
 /**
  * nss_rmnet_rx_create_sync_nexthop
- *	Creates an RMNET interface synchronously with specified nexthops.
+ *	Creates a virtual interface synchronously with specified nexthops.
  *
  * @datatypes
  * net_device
@@ -220,33 +220,19 @@ extern nss_tx_status_t nss_rmnet_rx_dest
  * @param[in] nexthop_h2n  Nexthop interface number of host-to-NSS dynamic interface.
  *
  * @return
- * Pointer to the NSS RMNET interface handle.
+ * Pointer to NSS virtual interface handle.
  */
 extern struct nss_rmnet_rx_handle *nss_rmnet_rx_create_sync_nexthop(struct net_device *netdev, uint32_t nexthop_n2h, uint32_t nexthop_h2n);
 
 /**
- * nss_rmnet_rx_create
- *	Creates an RMNET interface synchronously with generic nexthops.
- *
- * @datatypes
- * net_device
- *
- * @param[in] netdev       Pointer to the associated network device.
- *
- * @return
- * Pointer to the NSS RMNET interface handle.
- */
-extern struct nss_rmnet_rx_handle *nss_rmnet_rx_create(struct net_device *netdev);
-
-/**
  * nss_rmnet_rx_tx_buf
- *	Forwards RMNET interface packets to the NSS.
+ *	Forwards virtual interface packets to the NSS.
  *
  * @datatypes
  * nss_rmnet_rx_handle \n
  * sk_buff
  *
- * @param[in,out] handle  Pointer to the RMNET interface handle (provided during
+ * @param[in,out] handle  Pointer to the virtual interface handle (provided during
  *                        registration).
  * @param[in]    skb     Pointer to the data socket buffer.
  *
@@ -258,14 +244,14 @@ extern nss_tx_status_t nss_rmnet_rx_tx_b
 
 /**
  * nss_rmnet_rx_tx_msg
- *	Sends a message to the RMNET interface.
+ *	Sends a message to the virtual interface.
  *
  * @datatypes
  * nss_ctx_instance \n
  * nss_rmnet_rx_msg
  *
  * @param[in] nss_ctx  Pointer to the NSS context (provided during registration).
- * @param[in] nvim     Pointer to the RMNET interface message.
+ * @param[in] nvim     Pointer to the virtual interface message.
  *
  * @return
  * Command Tx status.
@@ -274,12 +260,12 @@ extern nss_tx_status_t nss_rmnet_rx_tx_m
 
 /**
  * nss_rmnet_rx_xmit_callback_unregister
- *	Deregisters the transmit callback from the RMNET interface.
+ *	Deregisters the transmit callback from the virtual interface.
  *
  * @datatypes
  * nss_rmnet_rx_handle
  *
- * @param[in,out] handle  Pointer to the RMNET interface handle.
+ * @param[in,out] handle  Pointer to the virtual interface handle.
  *
  * @return
  * None.
@@ -288,15 +274,15 @@ extern void nss_rmnet_rx_xmit_callback_u
 
 /**
  * nss_rmnet_rx_xmit_callback_register
- *	Registers a transmit callback to an RMNET interface.
+ *	Registers a transmit callback to a virtual interface.
  *
  * @datatypes
  * nss_rmnet_rx_handle \n
  * nss_rmnet_rx_xmit_callback_t
  *
- * @param[in,out] handle        Pointer to the RMNET interface handle (provided during
+ * @param[in,out] handle        Pointer to the virtual interface handle (provided during
  *                              dynamic interface allocation).
- * @param[in]    cb             Callback handler for RMNET data packets.
+ * @param[in]    cb             Callback handler for virtual data packets.
  *
  * @return
  * None.
@@ -306,12 +292,12 @@ extern void nss_rmnet_rx_xmit_callback_r
 
 /**
  * nss_rmnet_rx_unregister
- *	Deregisters an RMNET interface from the NSS driver.
+ *	Deregisters a virtual interface from the NSS driver.
  *
  * @datatypes
  * nss_rmnet_rx_handle
  *
- * @param[in,out] handle  Pointer to the RMNET interface handle.
+ * @param[in,out] handle  Pointer to the virtual interface handle.
  *
  * @return
  * None.
@@ -320,16 +306,16 @@ extern void nss_rmnet_rx_unregister(stru
 
 /**
  * nss_rmnet_rx_register
- *	Registers an RMNET Interface with NSS driver.
+ *	Registers a virtual Interface with NSS driver.
  *
  * @datatypes
  * nss_rmnet_rx_handle \n
  * nss_rmnet_rx_data_callback_t \n
  * net_device
  *
- * @param[in,out] handle        Pointer to the RMNET interface handle (provided during
+ * @param[in,out] handle        Pointer to the virtual interface handle (provided during
  *                              dynamic interface allocation).
- * @param[in]    data_callback  Callback handler for RMNET data packets.
+ * @param[in]    data_callback  Callback handler for virtual data packets.
  * @param[in]    netdev         Pointer to the associated network device.
  *
  * @return
@@ -363,22 +349,22 @@ extern int32_t nss_rmnet_rx_get_ifnum(st
 
 /**
  * nss_rmnet_rx_get_interface_num
- *	Returns the RMNET interface number associated with the handle.
+ *	Returns the virtual interface number associated with the handle.
  *
  * @datatypes
  * nss_rmnet_rx_handle
  *
- * @param[in] handle  Pointer to the RMNET interface handle (provided during
+ * @param[in] handle  Pointer to the virtual interface handle (provided during
 		      dynamic interface allocation).
  *
  * @return
- * RMNET interface number.
+ * Virtual interface number.
  */
 extern int32_t nss_rmnet_rx_get_interface_num(struct nss_rmnet_rx_handle *handle);
 
 /**
  * nss_rmnet_rx_get_context
- *	Gets the RMNET interface context.
+ *	Gets the virtual interface context.
  *
  * @return
  * Pointer to the NSS core context.
--- a/exports/nss_shaper.h
+++ b/exports/nss_shaper.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014, 2017-2018, 2021 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014, 2017-2018 The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -59,7 +59,7 @@ enum nss_shaper_config_types {
 	NSS_SHAPER_CONFIG_TYPE_FREE_SHAPER_NODE,
 	NSS_SHAPER_CONFIG_TYPE_SET_DEFAULT,
 	NSS_SHAPER_CONFIG_TYPE_SET_ROOT,
-	NSS_SHAPER_CONFIG_TYPE_SHAPER_NODE_STATS_SYNC_MANY,
+	NSS_SHAPER_CONFIG_TYPE_SHAPER_NODE_BASIC_STATS_GET,
 	NSS_SHAPER_CONFIG_TYPE_SHAPER_NODE_ATTACH,
 	NSS_SHAPER_CONFIG_TYPE_SHAPER_NODE_DETACH,
 	NSS_SHAPER_CONFIG_TYPE_SHAPER_NODE_CHANGE_PARAM,
@@ -672,7 +672,6 @@ struct nss_shaper_node_stats {
  *	Statistics response for shaper nodes.
  */
 struct nss_shaper_node_stats_response {
-	uint32_t qos_tag;	/**< QoS tag of the shaper node. */
 	struct nss_shaper_node_stats sn_stats;	/**< Common shaper node statistics. */
 
 	/**
@@ -686,27 +685,21 @@ struct nss_shaper_node_stats_response {
 };
 
 /**
- * nss_shaper_node_stats_sync_many
- * 	Message structure to request shaper node statistics.
+ * nss_shaper_node_stats_get
+ *	Statistics of a shaper node.
  */
-struct nss_shaper_node_stats_sync_many {
+struct nss_shaper_node_stats_get {
 
-        /*
-         * Request/Response
-         */
-        uint32_t last_qos_tag;                  /**< Last QoS tag. Zero indicates a fresh iteration. */
-
-        /*
-         * Request
-         */
-        uint16_t size;                          /**< Total buffer size indicated by host. */
-
-        /*
-         * Response
-         */
-        uint16_t count;                         /**< Number of shaper nodes for which statistics are copied. */
-        struct nss_shaper_node_stats_response stats_sync[];
-                                                /**< Response to host. */
+	/*
+	 * Request
+	 */
+	uint32_t qos_tag;	/**< QoS tag of the shaper node. */
+
+	/*
+	 * Response
+	 */
+	struct nss_shaper_node_stats_response response;
+				/**< Shaper node statistics response */
 };
 
 /**
@@ -733,8 +726,8 @@ struct nss_shaper_configure {
 				/**< Set a shaper to operate in Hybrid mode. */
 		struct nss_shaper_node_config shaper_node_config;
 				/**< Configuration message for any type of shaper node. */
-		struct nss_shaper_node_stats_sync_many stats_get;
-				/**< Statistics of multiple shaper nodes. */
+		struct nss_shaper_node_stats_get shaper_node_stats_get;
+				/**< Statistics for a shaper node. */
 	} msg;			/**< Types of configuration messages. */
 };
 
--- a/exports/nss_tls.h
+++ b/exports/nss_tls.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -69,43 +69,6 @@ enum nss_tls_error {
 };
 
 /**
- * nss_tls_stats_types
- *	TLS statistics types.
- */
-enum nss_tls_stats_types {
-	NSS_TLS_STATS_SINGLE_REC = NSS_STATS_NODE_MAX,
-						/**< Number of transmit single record datagrams. */
-	NSS_TLS_STATS_MULTI_REC,		/**< Number of multiple transmit record datagrams. */
-	NSS_TLS_STATS_TX_INVAL_REQS,		/**< Number of transmit invalidations successfully requested. */
-	NSS_TLS_STATS_RX_CCS_REC,		/**< Number of change cipher specification records received. */
-	NSS_TLS_STATS_FAIL_CCS,			/**< Failure to switch to new crypto. */
-	NSS_TLS_STATS_ETH_NODE_DEACTIVE,	/**< Ethernet node deactivated because no crypto was available. */
-	NSS_TLS_STATS_CRYPTO_ALLOC_SUCCESS,	/**< Number of successful crypto allocations. */
-	NSS_TLS_STATS_CRYPTO_FREE_REQ,		/**< Number of crypto-free requests. */
-	NSS_TLS_STATS_CRYPTO_FREE_SUCCESS,	/**< Number of crypto-free successes. */
-	NSS_TLS_STATS_FAIL_CRYPTO_ALLOC,	/**< Number of failed crypto allocations. */
-	NSS_TLS_STATS_FAIL_CRYPTO_LOOKUP,	/**< Failure to find an active crypto session. */
-	NSS_TLS_STATS_FAIL_REQ_ALLOC,		/**< Failure to allocate request memory pool.  */
-	NSS_TLS_STATS_FAIL_PBUF_STATS,		/**< Failure in pbuf allocation for statistics. */
-	NSS_TLS_STATS_FAIL_CTX_ACTIVE,		/**< Failure in enqueue due to inactive context. */
-	NSS_TLS_STATS_HW_LEN_ERROR,		/**< Length error. */
-	NSS_TLS_STATS_HW_TOKEN_ERROR,		/**< Token error; unknown token command or instruction. */
-	NSS_TLS_STATS_HW_BYPASS_ERROR,		/**< Token contains too much bypass data. */
-	NSS_TLS_STATS_HW_CRYPTO_ERROR,		/**< Cryptographic block size error. */
-	NSS_TLS_STATS_HW_HASH_ERROR,		/**< Hash block size error. */
-	NSS_TLS_STATS_HW_CONFIG_ERROR,		/**< Invalid command, algorithm, or mode combination. */
-	NSS_TLS_STATS_HW_ALGO_ERROR,		/**< Unsupported algorithm. */
-	NSS_TLS_STATS_HW_HASH_OVF_ERROR,	/**< Hash input overflow. */
-	NSS_TLS_STATS_HW_AUTH_ERROR,		/**< Hash input overflow. */
-	NSS_TLS_STATS_HW_PAD_VERIFY_ERROR,	/**< Pad verification error. */
-	NSS_TLS_STATS_HW_TIMEOUT_ERROR,		/**< Data timed out. */
-	NSS_TLS_STATS_NO_DESC_IN,		/**< Ingress DMA descriptor not available. */
-	NSS_TLS_STATS_NO_DESC_OUT,		/**< Egress DMA descriptor not available. */
-	NSS_TLS_STATS_NO_REQS,			/**< Not enough requests available for records. */
-	NSS_TLS_STATS_MAX,			/**< Maximum statistics type. */
-};
-
-/**
  * nss_tls_hw_stats
  *	TLS HW statistics.
  */
@@ -194,16 +157,6 @@ struct nss_tls_cipher_update {
 };
 
 /**
- * nss_tls_stats_notification
- *	TLS transmission statistics structure.
- */
-struct nss_tls_stats_notification {
-	uint64_t stats_ctx[NSS_TLS_STATS_MAX];		/**< Context transmission statistics. */
-	uint32_t core_id;				/**< Core ID. */
-	uint32_t if_num;				/**< Interface number. */
-};
-
-/**
  * nss_tls_msg
  *	Data for sending and receiving TLS messages.
  */
@@ -292,7 +245,7 @@ extern nss_tx_status_t nss_tls_tx_msg(st
  * @param[in]  if_num   NSS interface number.
  * @param[in]  type     Type of message.
  * @param[in]  len      Size of the payload.
- * @param[in]  ntcm     Pointer to the NSS IPsec message.
+ * @param[in]  nicm     Pointer to the NSS IPsec message.
  *
  * @return
  * Status of the Tx operation.
@@ -302,20 +255,6 @@ extern nss_tx_status_t nss_tls_tx_msg_sy
 						struct nss_tls_msg *ntcm);
 
 /**
- * nss_tls_unregister_if
- *	Deregisters a TLS session interface from the NSS.
- *
- * @param[in] if_num  NSS interface number.
- *
- * @return
- * None.
- *
- * @dependencies
- * The TLS session interface must have been previously registered.
- */
-extern void nss_tls_unregister_if(uint32_t if_num);
-
-/**
  * nss_tls_register_if
  *	Registers a TLS session interface with the NSS for sending and receiving
  *	messages.
@@ -345,19 +284,22 @@ extern struct nss_ctx_instance *nss_tls_
 							 void *app_ctx);
 
 /**
- * nss_tls_notify_unregister
- *	Deregisters an event callback.
+ * nss_tls_unregister_if
+ *	Deregisters a TLS session interface from the NSS.
  *
- * @param[in] ifnum  NSS interface number.
+ * @param[in] if_num  NSS interface number.
  *
  * @return
  * None.
+ *
+ * @dependencies
+ * The TLS session interface must have been previously registered.
  */
-extern void nss_tls_notify_unregister(uint32_t ifnum);
+extern void nss_tls_unregister_if(uint32_t if_num);
 
 /**
  * nss_tls_notify_register
- *	Registers an event callback to handle notification from TLS firmware package.
+ *	Register an event callback to handle notification from TLS firmware package.
  *
  * @datatypes
  * nss_tls_msg_callback_t
@@ -372,6 +314,17 @@ extern void nss_tls_notify_unregister(ui
 extern struct nss_ctx_instance *nss_tls_notify_register(uint32_t ifnum, nss_tls_msg_callback_t ev_cb, void *app_data);
 
 /**
+ * nss_tls_notify_unregister
+ *	Unregister an event callback.
+ *
+ * @param[in] ifnum  NSS interface number.
+ *
+ * @return
+ * None.
+ */
+extern void nss_tls_notify_unregister(uint32_t ifnum);
+
+/**
  * nss_tls_msg_init
  *	Initializes a TLS message sent asynchronously.
  *
@@ -424,44 +377,6 @@ extern struct nss_ctx_instance *nss_tls_
  * Pointer to the device.
  */
 extern struct device *nss_tls_get_dev(struct nss_ctx_instance *nss_ctx);
-
-/**
- * nss_tls_ifmap_get
- *	Returns active TLS interfaces.
- *
- * @return
- * Pointer to the interface map.
- */
-unsigned long *nss_tls_ifmap_get(void);
-
-/**
- * nss_tls_stats_unregister_notifier
- *	Deregisters a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_tls_stats_unregister_notifier(struct notifier_block *nb);
-
-/**
- * nss_tls_stats_register_notifier
- *	Registers a statistics notifier.
- *
- * @datatypes
- *	notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or non-zero on failure.
- */
-extern int nss_tls_stats_register_notifier(struct notifier_block *nb);
-
 /**
  * @}
  */
--- a/exports/nss_trustsec_tx.h
+++ b/exports/nss_trustsec_tx.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016-2017, 2020, 2021 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2017, 2020 The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -44,7 +44,7 @@ enum nss_trustsec_tx_msg_types {
  *	Error types for the TrustSec Tx interface.
  */
 enum nss_trustsec_tx_error_types {
-	NSS_TRUSTSEC_TX_ERR_NONE,		/** No error. */
+	NSS_TRUSTSEC_TX_ERR_NONE,		/** No error */
 	NSS_TRUSTSEC_TX_ERR_INVAL_SRC_IF,	/** Source interface is invalid. */
 	NSS_TRUSTSEC_TX_ERR_RECONFIGURE_SRC_IF,	/** Source interface is already configured. */
 	NSS_TRUSTSEC_TX_ERR_DEST_IF_NOT_FOUND,	/** Destination interface is not found. */
--- a/exports/nss_tunipip6.h
+++ b/exports/nss_tunipip6.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014, 2017-2018, 2020, 2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014, 2017-2018, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -23,154 +23,81 @@
 #define __NSS_TUNIPIP6_H
 
 /**
- * Maximum number of supported TUNIPIP6 tunnels.
- */
-#define NSS_TUNIPIP6_TUNNEL_MAX 32
-
-/**
  * @addtogroup nss_tunipip6_subsystem
  * @{
  */
 
+#define NSS_TUNIPIP6_MAX_FMR_NUMBER 4	/**< Maximum number of forward mapping rule (FMR). */
+
 /**
- * nss_tunipip6_map_rule
- *	Mapping rule (FMR/BMR) for forwarding traffic to the node in the same domain.
+ * nss_tunipip6_fmr
+ *	Forward mapping rule (FMR) for direct forwarding traffic to the node in the same domain.
  */
-struct nss_tunipip6_map_rule {
+struct nss_tunipip6_fmr {
 	uint32_t ip6_prefix[4];		/**< An IPv6 prefix assigned by a mapping rule. */
 	uint32_t ip4_prefix;		/**< An IPv4 prefix assigned by a mapping rule. */
 	uint32_t ip6_prefix_len;	/**< IPv6 prefix length. */
 	uint32_t ip4_prefix_len;	/**< IPv4 prefix length. */
-	uint32_t ip6_suffix[4];		/**< IPv6 suffix. */
-	uint32_t ip6_suffix_len;	/**< IPv6 suffix length. */
 	uint32_t ea_len;		/**< Embedded Address (EA) bits. */
-	uint32_t psid_offset;		/**< PSID offset default 6. */
-};
-
-/**
- * nss_tunipip6_err_types
- * 	Error types for response to messages from the host.
- */
-enum nss_tunipip6_err_types {
-	NSS_TUNIPIP6_ERR_TYPE_MAX_TUNNELS,		/**< Maximum number of tunnel reached. */
-	NSS_TUNIPIP6_ERR_TYPE_TUNNEL_EXIST,		/**< Tunnel already exists. */
-	NSS_TUNIPIP6_ERR_TYPE_ENCAP_BAD_PARAM,	/**< Bad configuration. */
-	NSS_TUNIPIP6_ERR_TYPE_ENCAP_FMR_EXIST,	/**< FMR already exists. */
-	NSS_TUNIPIP6_ERR_TYPE_ENCAP_NO_FMR,		/**< No FMR configured.*/
-	NSS_TUNIPIP6_ERR_TYPE_ENCAP_FMR_FULL,	/**< FMR table is full. */
-	NSS_TUNIPIP6_ERR_TYPE_ENCAP_INVALID_FMR,	/**< Invalid FMR configured.*/
-	NSS_TUNIPIP6_ERR_TYPE_ENCAP_BMR_EXIST,	/**< BMR already exists. */
-	NSS_TUNIPIP6_ERR_TYPE_ENCAP_NO_BMR,		/**< No BMR configured. */
-	NSS_TUNIPIP6_ERR_TYPE_ENCAP_FMR_MEM_ALLOC_FAILED,	/**< Pool allocation for FMR failed. */
-	NSS_TUNIPIP6_ERR_TYPE_UNKNOWN,		/**< Unknown message type. */
-	NSS_TUNIPIP6_ERROR_MAX,			/**< Maximum number of errors. */
+	uint32_t offset;		/**< PSID offset default 6. */
 };
 
 /**
  * nss_tunipip6_metadata_types
- *	Message types for TUNIPIP6 (IPv4 in IPv6) tunnel requests and responses.
+ *	Message types for DS-Lite (IPv4 in IPv6) tunnel requests and responses.
  */
 enum nss_tunipip6_metadata_types {
 	NSS_TUNIPIP6_TX_ENCAP_IF_CREATE,
 	NSS_TUNIPIP6_TX_DECAP_IF_CREATE,
-	NSS_TUNIPIP6_STATS_SYNC,
-	NSS_TUNIPIP6_FMR_RULE_ADD,
-	NSS_TUNIPIP6_FMR_RULE_DEL,
-	NSS_TUNIPIP6_FMR_RULE_FLUSH,
-	NSS_TUNIPIP6_BMR_RULE_ADD,
-	NSS_TUNIPIP6_BMR_RULE_DEL,
+	NSS_TUNIPIP6_RX_STATS_SYNC,
 	NSS_TUNIPIP6_MAX,
 };
 
 /**
  * nss_tunipip6_create_msg
- *	Payload for configuring the TUNIPIP6 interface.
+ *	Payload for configuring the DS-Lite interface.
  */
 struct nss_tunipip6_create_msg {
+	struct nss_tunipip6_fmr fmr[NSS_TUNIPIP6_MAX_FMR_NUMBER];	/**< Tunnel FMR array. */
 	uint32_t saddr[4];						/**< Tunnel source address. */
 	uint32_t daddr[4];						/**< Tunnel destination address. */
 	uint32_t flowlabel;						/**< Tunnel IPv6 flow label. */
 	uint32_t flags;							/**< Tunnel additional flags. */
+	uint32_t fmr_number;						/**< Tunnel FMR number. */
 	uint32_t sibling_if_num;					/**< Sibling interface number. */
+	uint16_t reserved1;						/**< Reserved for alignment. */
 	uint8_t hop_limit;						/**< Tunnel IPv6 hop limit. */
 	uint8_t draft03;						/**< Use MAP-E draft03 specification. */
-	uint8_t ttl_inherit;						/**< Inherit IPv4 TTL to hoplimit. */
-	uint8_t tos_inherit;						/**< Inherit IPv4 ToS. */
-	uint8_t frag_id_update;						/**< Enable update of fragment identifier of IPv4. */
-	uint8_t reserved[3];						/**< Reserved bytes. */
-	uint32_t fmr_max;						/**< Maximum number of FMRs that can be configured. */
-};
-
-/**
- * nss_tunipip6_debug_stats
- * 	TUNIPIP6 debug statistics.
- */
-struct nss_tunipip6_debug_stats {
-	struct {
-		struct {
-			uint32_t low_headroom;		/**< Low headroom for encapsulation. */
-			uint32_t unhandled_proto;	/**< Unhandled protocol for encapsulation. */
-		} exp;
-
-		struct {
-			uint32_t enqueue_fail;		/**< Encapsulation enqueue fail. */
-		} drop;
-
-		struct {
-			uint32_t err_tunnel_cfg;	/**< Tunnel configuration error. */
-			uint32_t total_fmr;		/**< Total number of existing FMRs. */
-			uint32_t fmr_add_req;		/**< FMR add requests. */
-			uint32_t fmr_del_req;		/**< FMR delete requests. */
-			uint32_t fmr_flush_req;		/**< FMR flush requests. */
-			uint32_t fmr_update_req;	/**< FMR update requests. */
-			uint32_t fmr_add_fail;		/**< FMR addition failed. */
-			uint32_t fmr_del_fail;		/**< FMR deletion failed. */
-			uint32_t err_no_fmr;		/**< No FMR configured. */
-			uint32_t bmr_add_req;		/**< BMR add requests. */
-			uint32_t bmr_del_req;		/**< BMR delete requests. */
-			uint32_t err_bmr_exist;		/**< BMR already configured. */
-			uint32_t err_no_bmr;		/**< No BMR configured. */
-		} cfg;
-	} encap;
-
-	struct {
-		struct {
-			uint32_t enqueue_fail;		/**< Decapsulation enqueue fail. */
-		} drop;
-	} decap;
 };
 
 /**
  * nss_tunipip6_stats_sync_msg
- *	Message information for TUNIPIP6 synchronization statistics.
+ *	Message information for DS-Lite synchronization statistics.
  */
 struct nss_tunipip6_stats_sync_msg {
-	struct nss_cmn_node_stats node_stats;		/**< Common node statistics. */
-	struct nss_tunipip6_debug_stats tun_stats;	/**< TUNIPIP6 debug statistics. */
+	struct nss_cmn_node_stats node_stats;	/**< Common node statistics. */
 };
 
 /**
  * nss_tunipip6_msg
- *	Data for sending and receiving TUNIPIP6 messages.
+ *	Data for sending and receiving DS-Lite messages.
  */
 struct nss_tunipip6_msg {
 	struct nss_cmn_msg cm;			/**< Common message header. */
 
 	/**
-	 * Payload of a TUNIPIP6 message.
+	 * Payload of a DS-Lite message.
 	 */
 	union {
 		struct nss_tunipip6_create_msg tunipip6_create;
-				/**< Create a TUNIPIP6 tunnel. */
-		struct nss_tunipip6_stats_sync_msg stats;
-				/**< Synchronized statistics for the TUNIPIP6 interface. */
-		struct nss_tunipip6_map_rule map_rule;
-				/**< BMR/FMR rule to add/delete, new or existing rules. */
-	} msg;			/**< Message payload for TUNIPIP6 messages exchanged with NSS core. */
+				/**< Create a DS-Lite tunnel. */
+		struct nss_tunipip6_stats_sync_msg stats_sync;
+				/**< Synchronized statistics for the DS-Lite interface. */
+	} msg;			/**< Message payload for IPIP6 Tunnel messages exchanged with NSS core. */
 };
 
 /**
- * Callback function for receiving TUNIPIP6 messages.
+ * Callback function for receiving DS-Lite messages.
  *
  * @datatypes
  * nss_tunipip6_msg
@@ -182,7 +109,7 @@ typedef void (*nss_tunipip6_msg_callback
 
 /**
  * nss_tunipip6_tx
- *	Sends a TUNIPIP6 message to NSS core.
+ *	Sends a DS-Lite message to NSS core.
  *
  * @datatypes
  * nss_ctx_instance \n
@@ -197,23 +124,7 @@ typedef void (*nss_tunipip6_msg_callback
 extern nss_tx_status_t nss_tunipip6_tx(struct nss_ctx_instance *nss_ctx, struct nss_tunipip6_msg *msg);
 
 /**
- * nss_tunipip6_tx_sync
- *	Sends a TUNIPIP6 message to NSS core synchronously.
- *
- * @datatypes
- * nss_ctx_instance \n
- * nss_tunipip6_msg
- *
- * @param[in] nss_ctx  Pointer to the NSS context.
- * @param[in] msg      Pointer to the message data.
- *
- * @return
- * Status of the Tx operation.
- */
-extern nss_tx_status_t nss_tunipip6_tx_sync(struct nss_ctx_instance *nss_ctx, struct nss_tunipip6_msg *msg);
-
-/**
- * Callback function for receiving TUNIPIP6 data.
+ * Callback function for receiving DS-Lite data.
  *
  * @datatypes
  * net_device \n
@@ -226,10 +137,10 @@ extern nss_tx_status_t nss_tunipip6_tx_s
  */
 typedef void (*nss_tunipip6_callback_t)(struct net_device *netdev, struct sk_buff *skb, struct napi_struct *napi);
 
-/**
+/*
  * nss_register_tunipip6_if
  *	Registers the TUNIPIP6 interface with the NSS for sending and receiving
- *	TUNIPIP6 messages.
+ *	DS-Lite messages.
  *
  * @datatypes
  * nss_tunipip6_callback_t \n
@@ -279,9 +190,9 @@ extern void nss_unregister_tunipip6_if(u
  */
 extern void nss_tunipip6_msg_init(struct nss_tunipip6_msg *ntm, uint16_t if_num, uint32_t type,  uint32_t len, void *cb, void *app_data);
 
-/**
+/*
  * nss_tunipip6_get_context()
- *	Get TUNIPIP6 context.
+ *	Get tunipip6 context.
  *
  * @return
  * Pointer to the NSS core context.
--- a/exports/nss_virt_if.h
+++ b/exports/nss_virt_if.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2017, 2019, 2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2017, 2019, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -93,8 +93,8 @@ struct nss_virt_if_interface_stats {
  *	Virtual interface statistics received from the NSS.
  */
 struct nss_virt_if_stats {
-	struct nss_virt_if_base_node_stats base_stats;	/**< Virtual interface statistics of NSS base node. */
-	struct nss_virt_if_interface_stats if_stats;	/**< Virtual interface statistics of each pair of interfaces. */
+	struct nss_virt_if_base_node_stats base_stats;
+	struct nss_virt_if_interface_stats if_stats;
 };
 
 /**
--- a/exports/nss_vxlan.h
+++ b/exports/nss_vxlan.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, 2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -53,11 +53,6 @@
 #define NSS_VXLAN_RULE_FLAG_UDP 0x0100				/**< UDP tunnel. */
 
 /**
- * Flag used to set the IPSec interface number in the MAC add message for binding with VxLAN.
- */
-#define NSS_VXLAN_MAC_ENABLE_IPSEC_BIND 0x01
-
-/**
  * nss_vxlan_msg_type
  *	Message types for VxLAN tunnel.
  */
@@ -116,8 +111,6 @@ struct nss_vxlan_stats_msg {
 	uint32_t except_vni_lookup_failed;	/**< Virtual network ID look up failed. */
 	uint32_t dropped_malformed;		/**< Packet is malformed. */
 	uint32_t dropped_next_node_queue_full;	/**< Next node dropped the packet. */
-	uint32_t except_inner_hash;		/**< Inner hash calculation failed. */
-	uint32_t decap_ipsec_src_err;	/* Drops due to incorrect packet buffer source for VxLAN over IPSec flow. */
 };
 
 /**
@@ -140,7 +133,7 @@ struct nss_vxlan_rule_msg {
 	 */
 	uint16_t flow_label;		/**< Flow label. */
 	uint8_t tos;			/**< Type of service/traffic class. */
-	uint8_t ttl;			/**< TTL/hop limit. */
+	uint8_t ttl;			/**< TTL/Hop Limit. */
 
 	/*
 	 * L4 rules
@@ -168,9 +161,6 @@ struct nss_vxlan_mac_msg {
 					/**< Tunnel encapsulation header. */
 	uint32_t vni;			/**< VxLAN network identifier. */
 	uint16_t mac_addr[3];		/**< MAC address. */
-	uint8_t reserved;	/**< Reserved. */
-	uint8_t flags;		/**< First bit set in the LSB indicates if IPSec is enabled. */
-	uint32_t ipsec_if_num;	/**< IPSec source interface number. */
 };
 
 /**
--- a/exports/nss_wifi.h
+++ b/exports/nss_wifi.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2015-2018, 2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2015-2018, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -35,8 +35,6 @@
 #define NSS_WIFI_IPV6_ADDR_LEN 16		/**< Size of the IPv6 address. */
 #define NSS_WIFI_MAX_RSSI_CHAINS 4		/**< Maximum number of RSSI chains. */
 #define NSS_WIFI_WME_NUM_AC 4			/**< Number of ACs. */
-#define NSS_WIFI_MIC_KEY_LEN 8
-
 
 /**
  * Maximum number of Wi-Fi peers per radio as a sum of
@@ -94,8 +92,6 @@ enum nss_wifi_metadata_types {
 	NSS_WIFI_OL_PEER_TIME_MSG,
 	NSS_WIFI_PEER_SET_VLAN_ID_MSG,
 	NSS_WIFI_PEER_ISOLATION_MSG,
-	NSS_WIFI_PEER_AUTH_MSG,
-	NSS_WIFI_PEER_SECURITY_CFG,
 	NSS_WIFI_MAX_MSG
 };
 
@@ -638,11 +634,6 @@ struct nss_wifi_stats_sync_msg {
 	 * Number of times a deny list was hit during multicast enhancement.
 	 */
 	uint32_t mc_enhance_denylist_hit;
-
-	/**
-	 * Total number of data packets dropped for an unauthorized peer.
-	 */
-	uint32_t peer_unauth_rx_pkt_drop;
 };
 
 /**
@@ -650,8 +641,8 @@ struct nss_wifi_stats_sync_msg {
  *	Information for creating a Wi-Fi peer freelist.
  */
 struct nss_wifi_peer_freelist_append_msg {
-	uint32_t addr;		/**< Starting address of the peer freelist pool. */
-	uint32_t length;	/**< Size of the peer freelist pool. */
+	uint32_t addr;		/**< Starting address of peer freelist pool. */
+	uint32_t length;	/**< Size of peer freelist pool. */
 	uint32_t num_peers;	/**< Maximum peer entries supported in the pool. */
 };
 
@@ -718,7 +709,7 @@ struct nss_wifi_peer_ol_stats {
 	uint32_t tx_mcast;	/**< Number of multicast packets sent. */
 	uint32_t tx_ucast;	/**< Number of unicast packets sent. */
 	uint32_t tx_data;	/**< Number data packets sent. */
-	uint32_t tx_bytes;	/**< Number of bytes transmitted. */
+	uint32_t tx_bytes;	/**< Number of bytes sent. */
 	uint32_t tx_fail;	/**< Number of failed Tx packets. */
 	uint32_t thrup_bytes;	/**< Number of throughput bytes. */
 	uint32_t tx_bcast_pkts;	/**< Number of broadcast packets sent. */
@@ -731,10 +722,6 @@ struct nss_wifi_peer_ol_stats {
 	uint32_t ppdu_retries;	/**< Number of PPDU retries. */
 	uint32_t rssi_chains[NSS_WIFI_MAX_RSSI_CHAINS];
 				/**< Acknowledgment RSSI per chain. */
-	uint32_t rx_msdus;	/**< Number of MSDUs received. */
-	uint32_t rx_bytes;	/**< Number of bytes received. */
-	uint32_t rx_mpdus;	/**< Number of MPDUs received. */
-	uint32_t rx_retries;	/**< Number of MPDU retries. */
 };
 
 /**
@@ -751,7 +738,7 @@ struct nss_wifi_ol_stats_msg {
 
 /**
  * nss_wifi_sta_kickout_msg
- *	Station kickout message from NSS firmware.
+ *	Station kickout message from NSS Firmware
  */
 struct nss_wifi_sta_kickout_msg {
 	uint32_t peer_id;	/**< Peer ID. */
@@ -766,18 +753,9 @@ struct nss_wifi_peer_isolation_msg {
 	uint16_t isolation;	/**< Isolation enabled/disabled. */
 };
 
-/*
- * nss_wifi_peer_auth_msg
- *	Peer authentication flag status.
- */
-struct nss_wifi_peer_auth_msg {
-	uint16_t peer_id;	/**< Peer ID. */
-	uint16_t auth_flag;	/**< Peer authentication flag. */
-};
-
 /**
  * nss_wifi_wnm_peer_rx_activity_msg
- *	Receive active state information for the peer.
+ *	Rx active state information for the peer.
  */
 struct nss_wifi_wnm_peer_rx_activity_msg {
 	uint16_t nentries;	/**< Number of entries. */
@@ -789,17 +767,6 @@ struct nss_wifi_wnm_peer_rx_activity_msg
 };
 
 /**
- * nss_wifi_peer_security_type_msg
- *	Wi-fi security type message.
- */
-struct nss_wifi_peer_security_type_msg {
-	uint16_t peer_id;			/**< Peer ID. */
-	uint8_t pkt_type;			/**< Unicast or broadcast packet type. */
-	uint8_t security_type;			/**< Security type. */
-	uint8_t mic_key[NSS_WIFI_MIC_KEY_LEN];	/**< MIC key. */
-};
-
-/**
  * nss_wifi_append_metaheader
  * 	Append metaheader after pbuf->data for stats_v2.
  */
@@ -946,21 +913,17 @@ struct nss_wifi_msg {
 		struct nss_wifi_cmd_msg wcmdm;
 				/**< Pdev command information. */
 		struct nss_wifi_enable_ol_statsv2 wesh_msg;
-				/**< Enable version 2 transmit/receive statistics. */
+				/**< Enable version 2 tx/rx stats. */
 		struct nss_wifi_ol_peer_time_msg wopt_msg;
 				/**< Send per peer/TID timestamp statistics to host. */
 		struct nss_wifi_peer_isolation_msg isolation_msg;
 				/**< Enable or disable peer isolation. */
-		struct nss_wifi_peer_auth_msg auth_msg;
-				/**< Enable or disable peer authorization. */
-		struct nss_wifi_peer_security_type_msg securitymsg;
-				/**< Wifili peer security message. */
 	} msg; /**< Message Payload. */
 };
 
 /**
  * nss_wifi_get_context
- *	Gets the Wi-Fi context used in NSS GRE transmit.
+ *	Gets the Wi-Fi context used in nss_gre_tx.
  *
  * @return
  * Pointer to the NSS core context.
--- /dev/null
+++ b/exports/nss_wifi_if.h
@@ -0,0 +1,292 @@
+/*
+ **************************************************************************
+ * Copyright (c) 2015-2017, The Linux Foundation. All rights reserved.
+ * Permission to use, copy, modify, and/or distribute this software for
+ * any purpose with or without fee is hereby granted, provided that the
+ * above copyright notice and this permission notice appear in all copies.
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ **************************************************************************
+ */
+
+/**
+ * @file nss_wifi_if.h
+ *	NSS Wi-Fi interface message Structure and APIs.
+ */
+
+#ifndef __NSS_WIFI_IF_H
+#define __NSS_WIFI_IF_H
+
+/**
+ * @addtogroup nss_wifi_subsystem
+ * @{
+ */
+
+/**
+ * nss_wifi_if_msg_types
+ *	Message types for Wi-Fi interface requests and responses.
+ */
+enum nss_wifi_if_msg_types {
+	NSS_WIFI_IF_OPEN = NSS_IF_OPEN,
+	NSS_WIFI_IF_CLOSE = NSS_IF_CLOSE,
+	NSS_WIFI_IF_LINK_STATE_NOTIFY = NSS_IF_LINK_STATE_NOTIFY,
+	NSS_WIFI_IF_MTU_CHANGE = NSS_IF_MTU_CHANGE,
+	NSS_WIFI_IF_MAC_ADDR_SET = NSS_IF_MAC_ADDR_SET,
+	NSS_WIFI_IF_STATS_SYNC = NSS_IF_STATS,
+	NSS_WIFI_IF_ISHAPER_ASSIGN = NSS_IF_ISHAPER_ASSIGN,
+	NSS_WIFI_IF_BSHAPER_ASSIGN = NSS_IF_BSHAPER_ASSIGN,
+	NSS_WIFI_IF_ISHAPER_UNASSIGN = NSS_IF_ISHAPER_UNASSIGN,
+	NSS_WIFI_IF_BSHAPER_UNASSIGN = NSS_IF_BSHAPER_UNASSIGN,
+	NSS_WIFI_IF_ISHAPER_CONFIG = NSS_IF_ISHAPER_CONFIG,
+	NSS_WIFI_IF_BSHAPER_CONFIG = NSS_IF_BSHAPER_CONFIG,
+	NSS_WIFI_IF_VSI_ASSIGN = NSS_IF_VSI_ASSIGN,
+	NSS_WIFI_IF_VSI_UNASSIGN = NSS_IF_VSI_UNASSIGN,
+	NSS_WIFI_IF_TX_CREATE_MSG = NSS_IF_MAX_MSG_TYPES + 1,
+	NSS_WIFI_IF_TX_DESTROY_MSG,
+	NSS_WIFI_IF_STATS_SYNC_MSG,
+	NSS_WIFI_IF_MAX_MSG_TYPES
+};
+
+/**
+ * nss_wifi_if_error_types
+ *	Error types for the Wi-Fi interface.
+ */
+enum nss_wifi_if_error_types {
+	NSS_WIFI_IF_SUCCESS,
+	NSS_WIFI_IF_CORE_FAILURE,
+	NSS_WIFI_IF_ALLOC_FAILURE,
+	NSS_WIFI_IF_DYNAMIC_IF_FAILURE,
+	NSS_WIFI_IF_MSG_TX_FAILURE,
+	NSS_WIFI_IF_REG_FAILURE,
+	NSS_WIFI_IF_CORE_NOT_INITIALIZED
+};
+
+/**
+ * nss_wifi_if_create_msg
+ *	Payload for configuring the Wi-Fi interface.
+ */
+struct nss_wifi_if_create_msg {
+	uint32_t flags;				/**< Interface flags. */
+	uint8_t mac_addr[ETH_ALEN];		/**< MAC address. */
+};
+
+/**
+ * nss_wifi_if_destroy_msg
+ *	Payload for destroying the Wi-Fi interface.
+ */
+struct nss_wifi_if_destroy_msg {
+	int32_t reserved;			/**< Placeholder. */
+};
+
+/**
+ * nss_wifi_if_stats
+ *	Wi-Fi interface statistics received from the NSS.
+ */
+struct nss_wifi_if_stats {
+	struct nss_cmn_node_stats node_stats;
+				/**< Common statistics. */
+	uint32_t tx_enqueue_failed;
+				/**< Number of packets dropped when queuing to the next node in a network graph. */
+	uint32_t shaper_enqueue_failed;
+				/**< Number of packets dropped when queuing to the shaper node. */
+};
+
+/**
+ * nss_wifi_if_msg
+ *	Data for sending and receiving Wi-Fi interface messages.
+ */
+struct nss_wifi_if_msg {
+	struct nss_cmn_msg cm;			/**< Common message header. */
+
+	/**
+	 * Payload of a Wi-Fi interface message.
+	 */
+	union {
+		union nss_if_msgs if_msgs;
+				/**< NSS interface messages. */
+		struct nss_wifi_if_create_msg create;
+				/**< Creates a Wi-Fi interface rule. */
+		struct nss_wifi_if_destroy_msg destroy;
+				/**< Destroys a Wi-Fi interface rule. */
+		struct nss_wifi_if_stats stats;
+				/**< Interface statistics. */
+	} msg;			/**< Message payload. */
+};
+
+/**
+ * nss_wifi_if_pvt
+ *	Private data information for the Wi-Fi interface.
+ */
+struct nss_wifi_if_pvt {
+	struct semaphore sem;
+			/**< Semaphore for a specified Wi-Fi interface number. */
+	struct completion complete;
+			/**< Waits for the NSS to process a message on the specified Wi-Fi interface. */
+	int response;	/**< Response received on a Wi-Fi interface number. */
+	int sem_init_done;
+			/**< Indicates whether the semaphore is initialized. */
+};
+
+/**
+ * Callback function for receiving Wi-Fi data.
+ *
+ * @datatypes
+ * net_device \n
+ * sk_buff \n
+ * napi_struct
+ *
+ * @param[in] netdev  Pointer to the associated network device.
+ * @param[in] skb     Pointer to the data socket buffer.
+ * @param[in] napi    Pointer to the NAPI structure.
+ */
+typedef void (*nss_wifi_if_data_callback_t)(struct net_device *netdev,
+		struct sk_buff *skb, struct napi_struct *napi);
+
+/**
+ * Callback function for receiving Wi-Fi messages.
+ *
+ * @datatypes
+ * nss_cmn_msg
+ *
+ * @param[in] app_data  Pointer to the application context of the message.
+ * @param[in] msg       Pointer to the message data.
+ */
+typedef void (*nss_wifi_if_msg_callback_t)(void *app_data,
+		struct nss_cmn_msg *msg);
+
+/**
+ * nss_wifi_if_handle
+ *	Context for WLAN-to-NSS communication.
+ */
+struct nss_wifi_if_handle {
+	struct nss_ctx_instance *nss_ctx;	/**< NSS context. */
+	int32_t if_num;				/**< Interface number. */
+	struct nss_wifi_if_pvt *pvt;		/**< Private data structure. */
+	struct nss_wifi_if_stats stats;
+			/**< Statistics corresponding to this handle. */
+	nss_wifi_if_msg_callback_t cb;
+			/**< Callback registered by other modules. */
+	void *app_data;
+			/**< Application context to be passed to that callback. */
+};
+
+/**
+ * nss_wifi_if_tx_msg
+ *	Sends a message to the Wi-Fi interface.
+ *
+ * @datatypes
+ * nss_ctx_instance \n
+ * nss_wifi_if_msg
+ *
+ * @param[in] nss_ctx  Pointer to the NSS context (provided during registration).
+ * @param[in] nwim     Pointer to the Wi-Fi interface message.
+ *
+ * @return
+ * Status of the Tx operation.
+ */
+extern nss_tx_status_t nss_wifi_if_tx_msg(struct nss_ctx_instance *nss_ctx,
+					struct nss_wifi_if_msg *nwim);
+
+/**
+ * nss_wifi_if_register
+ *	Registers a Wi-Fi interface with the NSS driver.
+ *
+ * @datatypes
+ * nss_wifi_if_handle \n
+ * nss_wifi_if_data_callback_t \n
+ * net_device
+ *
+ * @param[in] handle       Pointer to the Wi-Fi context (provided during Wi-Fi
+ *                             interface allocation).
+ * @param[in] rx_callback  Callback handler for Wi-Fi data packets.
+ * @param[in] netdev       Pointer to the associated network device.
+ *
+ * @return
+ * None.
+ */
+extern void nss_wifi_if_register(struct nss_wifi_if_handle *handle,
+				nss_wifi_if_data_callback_t rx_callback,
+				struct net_device *netdev);
+
+/**
+ * nss_wifi_if_unregister
+ *	Deregisters a Wi-Fi interface from the NSS driver.
+ *
+ * @datatypes
+ * nss_wifi_if_handle
+ *
+ * @param[in] handle  Pointer to the Wi-Fi context.
+ *
+ * @return
+ * None.
+ */
+extern void nss_wifi_if_unregister(struct nss_wifi_if_handle *handle);
+
+/**
+ * nss_wifi_if_create_sync
+ *	Creates a Wi-Fi interface.
+ *
+ * @datatypes
+ * net_device
+ *
+ * @param[in] netdev  Pointer to the associated network device.
+ *
+ * @return
+ * Pointer to the Wi-Fi handle.
+ */
+extern struct nss_wifi_if_handle *nss_wifi_if_create_sync(struct net_device *netdev);
+
+/**
+ * nss_wifi_if_destroy_sync
+ *	Destroys the Wi-Fi interface associated with the interface number.
+ *
+ * @datatypes
+ * nss_wifi_if_handle
+ *
+ * @param[in] handle  Pointer to the Wi-Fi handle.
+ *
+ * @return
+ * Status of the Tx operation.
+ */
+extern nss_tx_status_t nss_wifi_if_destroy_sync(struct nss_wifi_if_handle *handle);
+
+/**
+ * nss_wifi_if_tx_buf
+ *	Sends a data packet or buffer to the NSS.
+ *
+ * @datatypes
+ * nss_wifi_if_handle \n
+ * sk_buff
+ *
+ * @param[in] handle  Context associated with the interface.
+ * @param[in] skb     Pointer to the data socket buffer.
+ *
+ * @return
+ * Status of the Tx operation.
+ */
+extern nss_tx_status_t nss_wifi_if_tx_buf(struct nss_wifi_if_handle *handle,
+					struct sk_buff *skb);
+
+/**
+ * nss_wifi_if_copy_stats
+ *	Copies Wi-Fi interface statistics for display.
+ *
+ * @param[in]  if_num  NSS interface number.
+ * @param[in]  index   Index in the statistics array.
+ * @param[out] line    Pointer to the buffer into which the statistics are copied.
+ *
+ * @return
+ * Number of bytes copied.
+ */
+int32_t nss_wifi_if_copy_stats(int32_t if_num, int index, char *line);
+
+/**
+ * @}
+ */
+
+#endif /* __NSS_WIFI_IF_H */
--- a/exports/nss_wifi_mac_db_if.h
+++ b/exports/nss_wifi_mac_db_if.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2020, 2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -25,18 +25,6 @@
 
 #define NSS_WIFI_MAC_DB_ENTRY_IF_LOCAL 0x1
 
- /**
- * @addtogroup nss_wifi_mac_db_if_subsystem
- * @{
- */
-
-/*
- * MAX Wi-Fi MAC database entries sent in group
- * is chosen considering the entry size and
- * maximum entries a smallest buffer could accomodate.
- */
-#define NSS_WIFI_MAC_DB_GROUP_ENTRIES_MAX 48
-
 /**
  * nss_wifi_mac_db_msg_types
  *	Wi-Fi MAC database messages.
@@ -47,9 +35,6 @@ enum nss_wifi_mac_db_msg_types {
 	NSS_WIFI_MAC_DB_DEL_ENTRY_MSG,		/**< Wi-Fi MAC database delete entry message. */
 	NSS_WIFI_MAC_DB_UPDATE_ENTRY_MSG,	/**< Wi-Fi MAC database update entry message. */
 	NSS_WIFI_MAC_DB_DEINIT_MSG,		/**< Wi-Fi MAC database deinitialization message. */
-	NSS_WIFI_MAC_DB_GROUP_ENTRIES_ADD_MSG,	/**< Wi-Fi MAC database group entries add message. */
-	NSS_WIFI_MAC_DB_ENTRY_ACTIVITY_MSG,	/**< Wi-Fi MAC database entry activity message. */
-	NSS_WIFI_MAC_DB_CREATE_ENTRY_MSG,	/**< Wi-Fi MAC database entry create message. */
 	NSS_WIFI_MAC_DB_MAX_MSG
 };
 
@@ -77,84 +62,11 @@ enum nss_wifi_mac_db_if_opmode {
 };
 
 /**
- * nss_wifi_mac_db_err_types
- * Wi-Fi MAC database errors.
- */
-enum nss_wifi_mac_db_err_types {
-	NSS_WIFI_MAC_DB_ERROR_NONE,
-		/**< Wi-Fi MAC database error none. */
-	NSS_WIFI_MAC_DB_ERROR_ENTRY_ALLOC_FAIL,
-		/**< Error used to report a Wi-Fi MAC database entry pool allocation failure. */
-	NSS_WIFI_MAC_DB_ERROR_MAC_EXISTS,
-		/**< Error used to report that a Wi-Fi MAC database entry already exists. */
-	NSS_WIFI_MAC_DB_ERROR_MAC_TABLE_FULL,
-		/**< Error used to report that a Wi-Fi MAC table is full. */
-	NSS_WIFI_MAC_DB_ERROR_MAC_ENTRY_ALLOC_FAILED,
-		/**< Error used to report a Wi-Fi MAC database entry allocation failure. */
-	NSS_WIFI_MAC_DB_ERROR_ENTRY_NOT_FOUND,
-		/**< Error used to report that a Wi-Fi MAC database entry is not present. */
-	NSS_WIFI_MAC_DB_ERROR_MAC_ENTRY_UNHASHED,
-		/**< Error used to report that a Wi-Fi MAC database entry is unhashed. */
-	NSS_WIFI_MAC_DB_ERROR_MAC_ENTRY_DELETE_FAILED,
-		/**< Error used to report a Wi-Fi MAC database entry delete failure. */
-	NSS_WIFI_MAC_DB_ERROR_INVALID_NUM_ENTRIES_FAIL,
-		/**< Error used to report the number of invalid Wi-Fi MAC database entries. */
-	NSS_WIFI_MAC_DB_ERROR_NOT_ALLOCATED_FAIL,
-		/**< Error used to report that a Wi-Fi MAC database is not allocated. */
-	NSS_WIFI_MAC_DB_ERROR_INV_IF_RECVD_FAIL,
-		/**< Error used to report that a Wi-Fi MAC database entry interface is invalid. */
-	NSS_WIFI_MAC_DB_ERROR_INVALID_EVENT,
-		/**< Error used to report that a Wi-Fi MAC database event is invalid. */
-	NSS_WIFI_MAC_DB_ERROR_PN_INVALID,
-		/**< Error used to report that a Wi-Fi MAC database entry pnode is invalid. */
-	NSS_WIFI_MAC_DB_ERROR_PHY_PN_INVALID,
-		/**< Error used to report that a Wi-Fi MAC database entry radio pnode is invalid. */
-	NSS_WIFI_MAC_DB_ERROR_ENTRY_POOL_INVALID,
-		/**< Error used to report that a Wi-Fi MAC database entry pool is invalid. */
-	NSS_WIFI_MAC_DB_ERROR_ENTRY_POOL_ALREADY_ALLOCATED,
-		/**< Error used to report that a Wi-Fi MAC database entry pool exists. */
-	NSS_WIFI_MAC_DB_ERROR_GROUP_ENTRY_ADD_FAIL,
-		/**< Error used to report that a Wi-Fi MAC database group entry add failure. */
-	NSS_WIFI_MAC_DB_ERROR_MAX,
-		/**< Wi-Fi MAC database error maximum. */
-};
-
-/**
- * nss_wifi_mac_db_entry_create_msg
- * 	Wi-Fi MAC database entry create message.
- */
-struct nss_wifi_mac_db_entry_create_msg {
-	uint8_t mac_addr[ETH_ALEN];			/**< MAC address. */
-	uint16_t reserved;				/**< Reserved bytes. */
-	int32_t nss_if;					/**< NSS interface number. */
-};
-
-/**
- * nss_wifi_mac_db_entry_activity_info
- * 	Wi-Fi MAC database entry activity information.
- */
-struct nss_wifi_mac_db_entry_activity_info {
-	uint8_t mac_addr[ETH_ALEN];			/**< MAC address. */
-	uint16_t reserved;				/**< Reserved bytes. */
-	int32_t nss_if;					/**< NSS interface number. */
-};
-
-/**
- * nss_wifi_mac_db_entry_activity_info_msg
- * 	Wi-Fi MAC database entry activity information message.
- */
-struct nss_wifi_mac_db_entry_activity_info_msg {
-	uint32_t nentries;		/**< Number of entries. */
-	struct nss_wifi_mac_db_entry_activity_info info[1];
-					/**< Wi-Fi MAC database entry activity information. */
-};
-
-/**
  * nss_wifi_mac_db_entry_info_msg
  *	Wi-Fi MAC database entry information.
  */
 struct nss_wifi_mac_db_entry_info_msg {
-	uint8_t mac_addr[ETH_ALEN];	/**< MAC address. */
+	uint8_t mac_addr[6];		/**< MAC address. */
 	uint16_t flag;			/**< Flag information about NSS interface. */
 	int32_t nss_if;		    	/**< NSS interface number. */
 	uint32_t iftype;		/**< NSS interface type. */
@@ -163,17 +75,6 @@ struct nss_wifi_mac_db_entry_info_msg {
 };
 
 /**
- * nss_wifi_mac_db_entry_group_info_msg
- *	Wi-Fi MAC database group of entries information.
- */
-struct nss_wifi_mac_db_entry_group_info_msg {
-	uint32_t num_entries;
-		/**< Number of entries in group information message. */
-	struct nss_wifi_mac_db_entry_info_msg entry[NSS_WIFI_MAC_DB_GROUP_ENTRIES_MAX];
-		/**< Wi-Fi MAC database information specific message. */
-};
-
-/**
  * nss_wifi_mac_db_msg
  *	Structure that describes Wi-Fi MAC database messages.
  */
@@ -186,12 +87,6 @@ struct nss_wifi_mac_db_msg {
 	union {
 		struct nss_wifi_mac_db_entry_info_msg nmfdbeimsg;
 				/**< Wi-Fi MAC database information specific message. */
-		struct nss_wifi_mac_db_entry_group_info_msg nmfdbegimsg;
-				/**< Wi-Fi MAC database information specific message. */
-		struct nss_wifi_mac_db_entry_activity_info_msg nmfdbeact_imsg;
-				/**< Wi-Fi MAC database entry activity information message. */
-		struct nss_wifi_mac_db_entry_create_msg nmfdbecmsg;
-				/**< Wi-Fi MAC database entry create message. */
 	} msg;			/**< Message payload. */
 };
 
@@ -280,9 +175,4 @@ struct nss_ctx_instance *nss_register_wi
  */
 void nss_unregister_wifi_mac_db_if(uint32_t if_num);
 struct nss_ctx_instance *nss_wifi_mac_db_get_context(void);
-
-/**
- * @}
- */
-
 #endif /* __NSS_WIFI_MAC_DB_H */
--- a/exports/nss_wifi_vdev.h
+++ b/exports/nss_wifi_vdev.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2015-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2015-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -16,7 +16,7 @@
 
 /**
  * @file nss_wifi_vdev.h
- *	NSS-to-HLOS Wi-Fi virtual device interface definitions.
+ *	NSS TO HLOS Wi-Fi virtual device interface definitions.
  */
 
 #ifndef __NSS_WIFI_VDEV_H
@@ -31,7 +31,6 @@
 /**< Offset of the metadata in a virtual device message. */
 #define NSS_WIFI_VDEV_DSCP_MAP_LEN 64		/**< Length of the DSCP MAP field. */
 #define NSS_WIFI_VDEV_IPV6_ADDR_LENGTH 16	/**< Size of the IPv6 address field. */
-#define NSS_WIFI_VDEV_IPV6_ADDR_WORDS 4		/**< Size of the IPv6 address field in words. */
 #define NSS_WIFI_MAX_SRCS 4			/**< Maximum number of multicast sources. */
 #define NSS_WIFI_VDEV_MAX_ME_ENTRIES 32		/**< Maximum number of multicast enhancement entries. */
 
@@ -75,8 +74,6 @@ enum nss_wifi_vdev_msg_types {
 	NSS_WIFI_VDEV_INTERFACE_RECOVERY_RESET_MSG,
 	NSS_WIFI_VDEV_INTERFACE_RECOVERY_RECONF_MSG,
 	NSS_WIFI_VDEV_SET_GROUP_KEY,
-	NSS_WIFI_VDEV_HMMC_MEMBER_ADD_MSG,
-	NSS_WIFI_VDEV_HMMC_MEMBER_DEL_MSG,
 	NSS_WIFI_VDEV_MAX_MSG
 };
 
@@ -131,15 +128,6 @@ enum nss_wifi_vdev_err_types {
 	NSS_WIFI_VDEV_VLAN_MODE_CONFIG_FAIL,
 	NSS_WIFI_VDEV_RECOVERY_RESET_FAIL,
 	NSS_WIFI_VDEV_RECOVERY_RECONF_FAIL,
-	NSS_WIFI_VDEV_CONFIG_GROUP_KEY_FAIL,
-	NSS_WIFI_VDEV_MULTIPASS_NOT_ENABLED,
-	NSS_WIFI_VDEV_ALLOC_VLAN_MAP_FAILED,
-	NSS_WIFI_VDEV_MTU_CHANGE_FAIL,
-	NSS_WIFI_VDEV_MAC_ADDR_CHANGE_FAIL,
-	NSS_WIFI_VDEV_PPE_PORT_CREATE_FAIL,
-	NSS_WIFI_VDEV_PPE_PORT_DESTROY_FAIL,
-	NSS_WIFI_VDEV_PPE_VSI_ASSIGN_FAIL,
-	NSS_WIFI_VDEV_PPE_VSI_UNASSIGN_FAIL,
 	NSS_WIFI_VDEV_EINV_MAX_CFG
 };
 
@@ -162,14 +150,6 @@ enum nss_wifi_vdev_ext_data_pkt_type {
 	NSS_WIFI_VDEV_EXT_TX_COMPL_PKT_TYPE = 11,	/**< Tx completion. */
 	NSS_WIFI_VDEV_EXT_DATA_PKT_TYPE_WDS_LEARN = 12,	/**< WDS source port learning command. */
 	NSS_WIFI_VDEV_EXT_DATA_PPDU_INFO = 13,		/**< PPDU metadata information. */
-	NSS_WIFI_VDEV_EXT_DATA_PKT_TYPE_MCBC_RX = 14,	/**< Multicast/broadcast packet received. */
-	NSS_WIFI_VDEV_MESH_EXT_DATA_PKT_TYPE_RX_SPL_PACKET = 15,
-							/**< Mesh link VAP special packet. */
-	NSS_WIFI_VDEV_MESH_EXT_DATA_PKT_TYPE_RX_MCAST_EXC = 16,
-							/**< Mesh link VAP multicast packet. */
-	NSS_WIFI_VDEV_EXT_DATA_PKT_TYPE_4ADDR = 17,	/**< 4 address exception to host. */
-	NSS_WIFI_VDEV_EXT_DATA_MPDU_INFO = 18,		/**< MPDU metadata information. */
-	NSS_WIFI_VDEV_EXT_DATA_PKT_TYPE_EAPOL = 19,	/**< EAPOL packets. */
 	NSS_WIFI_VDEV_EXT_DATA_PKT_TYPE_MAX
 };
 
@@ -200,13 +180,6 @@ enum nss_wifi_vdev_cmd {
 	NSS_WIFI_VDEV_CFG_AST_OVERRIDE_CMD,	/**< Configuration to set AST (Address Search Table) override on VAP. */
 	NSS_WIFI_VDEV_CFG_SON_CAP_CMD,		/**< Configuration to set software defined network capability on VAP. */
 	NSS_WIFI_VDEV_CFG_MULTIPASS_CMD,	/**< Configuration to enable multipass phrase capability on VAP. */
-	NSS_WIFI_VDEV_CFG_HLOS_TID_OVERRIDE_CMD,
-					/**< Configuration to enable HLOS TID override on VAP. */
-	NSS_WIFI_VDEV_ENABLE_IGMP_ME_CMD,	/**< Configuration to set IGMP multicast enhancement on VAP. */
-	NSS_WIFI_VDEV_CFG_WDS_BACKHAUL_CMD,
-					/**< Configuration to set WDS backhaul extension on VAP. */
-	NSS_WIFI_VDEV_CFG_MCBC_EXC_TO_HOST_CMD, /**< Configuration to set multicast/broadcast exception to host on VAP. */
-	NSS_WIFI_VDEV_DROP_3ADDR_MCAST_CMD, /**< Configuration to drop multicast three address frames. */
 	NSS_WIFI_VDEV_MAX_CMD
 };
 
@@ -242,11 +215,6 @@ enum nss_wifi_vdev_vlan_tagging_mode {
 	NSS_WIFI_VDEV_VLAN_MAX		/**< Wi-Fi maximum VLAN support type. */
 };
 
-enum vap_ext_mode {
-	WIFI_VDEV_EXT_MODE_MESH_LINK = 1,	/* Wi-Fi mesh VAP mode */
-	WIFI_VDEV_EXT_MODE_MAX,			/* Wi-Fi maximum VAP mode */
-};
-
 /**
  * nss_wifi_vdev_config_msg
  *	Virtual device configuration.
@@ -272,9 +240,7 @@ struct nss_wifi_vdev_config_msg {
 					/**< VAP is configured as a smart monitor VAP. */
 	uint8_t is_wrap;		/**< Specifies whether the VAP is a WRAP-AP. */
 	uint8_t is_nss_qwrap_en;	/**< VAP is configured for NSS firmware QWRAP logic. */
-	uint8_t tx_per_pkt_vdev_id_check;	/**< Transmit per-packet virtual device ID check. */
-	uint8_t align_pad;		/**< Reserved field. */
-	uint32_t vap_ext_mode;		/**< Different VAP extended modes. */
+	uint8_t reserved[2];		/**< Reserved for 4-byte alignment padding. */
 };
 
 /**
@@ -345,7 +311,7 @@ struct nss_wifi_vdev_me_snptbl_grp_creat
 	union {
 		uint32_t grpaddr_ip4;
 				/**< IPv4 address. */
-		uint32_t grpaddr_ip6[NSS_WIFI_VDEV_IPV6_ADDR_WORDS];
+		uint8_t grpaddr_ip6[NSS_WIFI_VDEV_IPV6_ADDR_LENGTH];
 				/**< IPv6 address. */
 	} u;			/**< IP address of the multicast group. */
 
@@ -366,7 +332,7 @@ struct nss_wifi_vdev_me_snptbl_grp_delet
 	union {
 		uint32_t grpaddr_ip4;
 				/**< IPv4 address. */
-		uint32_t grpaddr_ip6[NSS_WIFI_VDEV_IPV6_ADDR_WORDS];
+		uint8_t grpaddr_ip6[NSS_WIFI_VDEV_IPV6_ADDR_LENGTH];
 				/**< IPv6 address. */
 	} u;			/**< IP address of the multicast group. */
 
@@ -397,7 +363,7 @@ struct nss_wifi_vdev_me_snptbl_grp_mbr_a
 	union {
 		uint32_t grpaddr_ip4;
 				/**< IPv4 address. */
-		uint32_t grpaddr_ip6[NSS_WIFI_VDEV_IPV6_ADDR_WORDS];
+		uint8_t grpaddr_ip6[NSS_WIFI_VDEV_IPV6_ADDR_LENGTH];
 				/**< IPv6 address. */
 	} u;			/**< IP address of the multicast group. */
 
@@ -427,7 +393,7 @@ struct nss_wifi_vdev_me_snptbl_grp_mbr_d
 	union {
 		uint32_t grpaddr_ip4;
 				/**< IPv4 address. */
-		uint32_t grpaddr_ip6[NSS_WIFI_VDEV_IPV6_ADDR_WORDS];
+		uint8_t grpaddr_ip6[NSS_WIFI_VDEV_IPV6_ADDR_LENGTH];
 				/**< IPv6 address. */
 	}u;			/**< IP address of the multicast group. */
 	uint8_t grp_addr[ETH_ALEN];
@@ -449,7 +415,7 @@ struct nss_wifi_vdev_me_snptbl_grp_mbr_u
 	union {
 		uint32_t grpaddr_ip4;
 				/**< IPv4 address. */
-		uint32_t grpaddr_ip6[NSS_WIFI_VDEV_IPV6_ADDR_WORDS];
+		uint8_t grpaddr_ip6[NSS_WIFI_VDEV_IPV6_ADDR_LENGTH];
 				/**< IPv6 address. */
 	}u;			/**< IP address of the multicast group. */
 
@@ -464,66 +430,6 @@ struct nss_wifi_vdev_me_snptbl_grp_mbr_u
 };
 
 /**
- * nss_wifi_vdev_me_hmmc_add_msg
- *	Information for adding an entry into the host-managed multicast list.
- */
-struct nss_wifi_vdev_me_hmmc_add_msg {
-	uint32_t ether_type;	/**< IPv4 or IPv6. */
-	union {
-		uint32_t ipv4_addr;
-			/**< IPv4 multicast group address. */
-		uint32_t ipv6_addr[NSS_WIFI_VDEV_IPV6_ADDR_WORDS];
-			/**< IPv6 multicast group address. */
-	} u;	/**< Type of group addresses. */
-	uint32_t netmask;	/**< IP subnet netmask. */
-};
-
-/**
- * nss_wifi_vdev_me_hmmc_del_msg
- *	Information for deleting an entry from the host-managed multicast list.
- */
-struct nss_wifi_vdev_me_hmmc_del_msg {
-	uint32_t ether_type;	/**< IPv4 or IPv6. */
-	union {
-		uint32_t ipv4_addr;
-			/**< IPv4 multicast group address. */
-		uint32_t ipv6_addr[NSS_WIFI_VDEV_IPV6_ADDR_WORDS];
-			/**< IPv6 multicast group address. */
-	} u;	/**< Type of group addresses. */
-	uint32_t netmask;	/**< IP subnet netmask. */
-};
-
-/**
- * nss_wifi_vdev_me_deny_ip_add_msg
- *	Information for adding an entry into the denylist.
- */
-struct nss_wifi_vdev_me_deny_ip_add_msg {
-	uint32_t ether_type;	/**< IPv4 or IPv6. */
-	union {
-		uint32_t ipv4_addr;
-			/**< IPv4 multicast group address. */
-		uint32_t ipv6_addr[NSS_WIFI_VDEV_IPV6_ADDR_WORDS];
-			/**< IPv6 multicast group address. */
-	} u;	/**< Type of group addresses. */
-	uint32_t netmask;	/**< IP subnet netmask. */
-};
-
-/**
- * nss_wifi_vdev_me_deny_ip_del_msg
- *	Information for deleting an entry from the denylist.
- */
-struct nss_wifi_vdev_me_deny_ip_del_msg {
-	uint32_t ether_type;	/**< IPv4 or IPv6. */
-	union {
-		uint32_t ipv4_addr;
-			/**< IPv4 multicast group address. */
-		uint32_t ipv6_addr[NSS_WIFI_VDEV_IPV6_ADDR_WORDS];
-			/**< IPv6 multicast group address. */
-	} u;	/**< Type of group addresses. */
-	uint32_t netmask;	/**< IP subnet netmask. */
-};
-
-/**
  * nss_wifi_vdev_me_snptbl_deny_grp_add_msg
  *	Information for adding a snooplist member to a deny list.
  */
@@ -818,49 +724,6 @@ struct nss_wifi_vdev_ppdu_metadata {
 };
 
 /**
- * nss_wifi_vdev_peer_mpdu_metadata
- *	MPDU metadata.
- */
-struct nss_wifi_vdev_peer_mpdu_metadata {
-	uint16_t peer_id;               /**< Corresponding peer ID. */
-	uint8_t tid;                    /**< TID of the flow or MPDU queue. */
-	uint8_t msdu_info;              /**< First or last MSDU information. */
-	uint32_t ppdu_id;               /**< PPDU ID. */
-	uint32_t tsf;                   /**< Timing synchronization function. */
-	uint8_t transmit_cnt;           /**< Transmission count. */
-	uint8_t status;                 /**< Frame acknowledged/failed. */
-	uint16_t reserved;		/**< Reserved. */
-};
-
-/**
- * nss_wifi_vdev_eapol_mdata_dir
- *	EAPOL metadata direction.
- */
-enum nss_wifi_vdev_eapol_mdata_dir {
-	WIFI_VDEV_EAPOL_MDATA_TX,       /**< EAPOL metadata for transmit direction. */
-	WIFI_VDEV_EAPOL_MDATA_RX        /**< EAPOL metadata for receive direction. */
-};
-
-/**
- * nss_wifi_vdev_eapol_metadata
- *	Metadata per EAPOL packet.
- */
-struct nss_wifi_vdev_eapol_per_packet_metadata {
-	enum nss_wifi_vdev_eapol_mdata_dir dir;		/**< EAPOL metadata direction. */
-	uint16_t peer_id;				/**< Peer ID. */
-};
-
-/**
- * nss_wifi_vdev_addr4_data_metadata
- *	Address 4 metadata
- */
-struct nss_wifi_vdev_addr4_data_metadata {
-	uint16_t peer_id;		/**< Peer ID. */
-	uint8_t sa_valid;		/**< Source address is valid. */
-	uint8_t addr4_valid;		/**< Address 4 is valid. */
-};
-
-/**
  * nss_wifi_vdev_per_packet_metadata
  *	Wi-Fi per packet metadata content.
  */
@@ -889,12 +752,6 @@ struct nss_wifi_vdev_per_packet_metadata
 			/**< Per packet Tx metadata structure for wireless distribution system mode. */
 		struct nss_wifi_vdev_ppdu_metadata ppdu_metadata;
 			/**< Per packet PPDU metadata needed for per PPDU copy mode. */
-		struct nss_wifi_vdev_addr4_data_metadata addr4_metadata;
-			/**< Create metadata for the WDS extension interface. */
-		struct nss_wifi_vdev_peer_mpdu_metadata mpdu_metadata;
-			/**< Per packet Tx metadata structure for Tx capture info per MPDU. */
-		struct nss_wifi_vdev_eapol_per_packet_metadata eapol_metadata;
-			/**< Per packet metadata structure for EAPOL. */
 	} metadata;
 			/**< Metadata payload for special data receive message. */
 };
@@ -904,8 +761,9 @@ struct nss_wifi_vdev_per_packet_metadata
  *	Metadata payload for Mesh mode receive.
  */
 struct nss_wifi_vdev_meshmode_rx_metadata {
-	uint16_t rs_ratephy_lo;	/**< PHY rate lower order bytes. */
-	uint16_t rs_ratephy_hi;	/**< PHY rate higher order bytes. */
+	uint16_t rs_ratephy;	/**< PHY rate. */
+	uint16_t rs_ratephy_lo;	/**< PHY rate lower bytes. */
+	uint16_t rs_ratephy_hi;	/**< PHY rate higher bytes. */
 	uint16_t cntr_chan_freq;	/** Center channel frequency. */
 	uint16_t vdev_id;	/**< Virtual device ID. */
 	uint16_t peer_id;	/**< Peer ID. */
@@ -1031,22 +889,6 @@ struct nss_wifi_vdev_mcast_enhance_stats
 	 * Number of multicast bytes received for multicast enhancement.
 	 */
 	uint32_t mcast_rcvd_bytes;
-
-	/**
-	 * Number of IGMP packets received for conversion to unicast.
-	 */
-	uint32_t igmp_rcvd;
-
-	/**
-	 * Number of IGMP packets converted to unicast as a part of
-	 * VoW IGMP improvements.
-	 */
-	uint32_t igmp_ucast_converted;
-
-	/**
-	 * Number of group members that could not be added due to failed allocation.
-	 */
-	uint32_t mcast_mbr_alloc_failed;
 };
 
 /**
@@ -1055,8 +897,8 @@ struct nss_wifi_vdev_mcast_enhance_stats
  */
 struct nss_wifi_vdev_stats_sync_msg {
 	uint32_t dropped;			/**< Number of dropped packets. */
-	uint32_t tx_enqueue_cnt;		/**< Transmit pnode enqueue count. */
-	uint32_t tx_enqueue_fail_cnt;		/**< Transmit pnode enqueue count. */
+	uint32_t tx_enqueue_cnt;		/**< Tx pnode enqueue count. */
+	uint32_t tx_enqueue_fail_cnt;		/**< Tx pnode enqueue count. */
 	uint32_t tx_intra_bss_enqueue_cnt;	/**< Intra BSS enqueue count. */
 	uint32_t tx_intra_bss_enqueue_fail_cnt;
 						/**< Intra BSS enqueue fail count. */
@@ -1064,12 +906,12 @@ struct nss_wifi_vdev_stats_sync_msg {
 						/**< Virual device multicast/broadcast packet count in AP mode. */
 	uint32_t tx_intra_bss_mcast_send_fail_cnt;
 						/**< Virtual device multicast/broadcast packet count in AP mode. */
-	uint32_t tx_enqueue_bytes;		/**< Transmit enqueue bytes count. */
+	uint32_t tx_enqueue_bytes;		/**< Tx enqueue bytes count. */
 	uint32_t rx_enqueue_cnt;		/**< Ethernet node enqueue count. */
 	uint32_t rx_enqueue_fail_cnt;		/**< Ethernet node enqueue fail count. */
 	uint32_t rx_except_enqueue_cnt;		/**< N2H (NSS to Host) node enqueue count. */
 	uint32_t rx_except_enqueue_fail_cnt;	/**< N2H (NSS to Host) node enqueue fail count. */
-	uint32_t rx_enqueue_bytes;		/**< Receive enqueue bytes count. */
+	uint32_t rx_enqueue_bytes;		/**< Rx enqueue bytes count. */
 	uint32_t rx_wds_learn_send_cnt;		/**< Virtual device WDS source port learn count. */
 	uint32_t rx_wds_learn_send_fail_cnt;	/**< Virtual device WDS source count fail. */
 	struct nss_wifi_vdev_mcast_enhance_stats wvmes;
@@ -1089,17 +931,6 @@ struct nss_wifi_vdev_stats_sync_msg {
 	uint32_t tx_eapol_cnt;			/**< Number of EAPoL frames in transmit direction. */
 	uint32_t nawds_tx_mcast_cnt;		/**< Number of NAWDS packets sent. */
 	uint32_t nawds_tx_mcast_bytes;		/**< Number of NAWDS bytes sent. */
-	uint32_t per_pkt_vdev_check_fail;	/**< Number of packets that failed vdev id check in Tx. */
-	uint32_t rx_mcast_cnt;			/**< Receive multicast packet count. */
-	uint32_t rx_mcast_bytes;		/**< Receive multicast bytes count. */
-	uint32_t rx_decrypt_err;		/**< Receive decryption error */
-	uint32_t rx_mic_err;			/**< Receive MIC error */
-	uint32_t mcbc_exc_host_fail_cnt;
-			/**< Number of multicast/broadcast packets failed to send to host through exception path. */
-	uint32_t addr4_exc_fail;			/**< Number of failed 4 address exceptions. */
-	uint32_t addr4_exc_pass;			/**< Number of successful 4 address exceptions. */
-	uint32_t eapol_over_nl_exc_fail_cnt;		/**< Number of EAPOL over NL exception packet failures. */
-	uint32_t eapol_over_nl_exc_pass_cnt;		/**< Number of EAPOL over NL exception packet successes. */
 };
 
 /**
@@ -1130,15 +961,7 @@ struct nss_wifi_vdev_msg {
 		struct nss_wifi_vdev_me_snptbl_grp_mbr_update_msg vdev_grp_member_update;
 				/**< Updates a snooplist group member. */
 		struct nss_wifi_vdev_me_snptbl_deny_grp_add_msg vdev_deny_member_add;
-				/**< Add a snooplist member to the deny list. */
-		struct nss_wifi_vdev_me_hmmc_add_msg vdev_hmmc_member_add;
-				/**< Adds a member to the HMMC list. */
-		struct nss_wifi_vdev_me_hmmc_del_msg vdev_hmmc_member_del;
-				/**< Deletes a member from the HMMC list. */
-		struct nss_wifi_vdev_me_deny_ip_add_msg vdev_deny_list_member_add;
-				/**< Adds a member to the denylist. */
-		struct nss_wifi_vdev_me_deny_ip_del_msg vdev_deny_list_member_del;
-				/**< Deletes a member from the denylist. */
+				/**< Adds a snooplist member to a deny list. */
 		struct nss_wifi_vdev_txmsg vdev_txmsgext;
 				/**< Transmits special data. */
 		struct nss_wifi_vdev_vow_dbg_cfg_msg vdev_vow_dbg_cfg;
--- a/exports/nss_wifili_if.h
+++ b/exports/nss_wifili_if.h
@@ -1,19 +1,16 @@
 /*
  **************************************************************************
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
+ * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
+ * Permission to use, copy, modify, and/or distribute this software for
+ * any purpose with or without fee is hereby granted, provided that the
+ * above copyright notice and this permission notice appear in all copies.
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  **************************************************************************
  */
 
@@ -65,7 +62,7 @@
 				/**< Maximum number of bandwidth supported. */
 #define NSS_WIFILI_REPT_MU_MIMO 1
 #define NSS_WIFILI_REPT_MU_OFDMA_MIMO 3
-#define NSS_WIFILI_MAX_RESERVED_TYPE 2
+#define NSS_WIFILI_MAX_RESERVED_TYPE 3
 				/**< Maximum reserved type. */
 #define NSS_WIFILI_SOC_PER_PACKET_METADATA_SIZE 60
 				/**< Metadata area total size. */
@@ -87,7 +84,7 @@
 				/**< Maximum DMA error codes. */
 #define NSS_WIFILI_MAX_TID 8
 				/**< Maximum TID values. */
-#define NSS_WIFILI_DELAY_INDEX_MAX 13
+#define NSS_WIFILI_DELAY_INDEX_MAX 10
 				/**< Maximum software enqueue delay buckets. */
 #define NSS_WIFILI_MAX_NUMBER_OF_ADDTNL_SEG 64
 				/**< Maximum number of additional pages allocated from host. */
@@ -97,69 +94,12 @@
 				/**< Maximum number of flow queues. */
 #define NSS_WIFILI_WBM_INTERNAL_ERR_MAX 5
 				/**< WBM internal maximum errors. */
-#define NSS_WIFILI_MAX_VOW_TID_NUM 4
-				/**< Maximum version 3 TID values. */
-
-/*
- * Peer Size in Bytes
- */
-#define NSS_WIFILI_PEER_SIZE 1600
-
-/*
- * Maximum size of target SoC type string
- */
-#define NSS_WIFILI_SOC_STRING_SIZE_MAX 24
 
 /*
  * Radio specific flags
  */
 #define NSS_WIFILI_PDEV_FLAG_V3_STATS_ENABLED 0x00000008
 				/**< Flag to enable version 3 statistics. */
-/**
- * Peer message flags.
- */
-#define NSS_WIFILI_PEER_MSG_DISABLE_4ADDR 0x01
-
-#ifdef __KERNEL__ /* only kernel will use. */
-
-/**
- * Wireless Multimedia Extention Access Category to TID. @hideinitializer
- */
-#define NSS_WIFILI_WME_AC_TO_TID(_ac) (	\
-		((_ac) == NSS_WIFILI_WME_AC_VO) ? 6 : \
-		(((_ac) == NSS_WIFILI_WME_AC_VI) ? 5 : \
-		(((_ac) == NSS_WIFILI_WME_AC_BK) ? 1 : \
-		0)))
-
-/**
- * Wireless TID to Wireless Extension Multimedia Access Category. @hideinitializer
- */
-#define NSS_WIFILI_TID_TO_WME_AC(_tid) (	\
-		(((_tid) == 0) || ((_tid) == 3)) ? NSS_WIFILI_WME_AC_BE : \
-		((((_tid) == 1) || ((_tid) == 2)) ? NSS_WIFILI_WME_AC_BK : \
-		((((_tid) == 4) || ((_tid) == 5)) ? NSS_WIFILI_WME_AC_VI : \
-		NSS_WIFILI_WME_AC_VO)))
-#endif /* __KERNEL */
-
-/**
- * nss_wifili_thread_scheme_id
- *	List of thread scheme IDs.
- */
-enum nss_wifili_thread_scheme_id {
-	NSS_WIFILI_THREAD_SCHEME_ID_0,		/**< High priority scheme index. */
-	NSS_WIFILI_THREAD_SCHEME_ID_1,		/**< Low priority scheme index. */
-	NSS_WIFILI_THREAD_SCHEME_ID_2,		/**< High priority scheme index. */
-	NSS_WIFILI_THREAD_SCHEME_ID_MAX		/**< Maximum value of scheme index. */
-};
-
-/*
- * nss_wifili_thread_scheme_priority
- *	List of wifili thread scheme priority.
- */
-enum nss_wifili_thread_scheme_priority {
-	NSS_WIFILI_LOW_PRIORITY_SCHEME,		/**< Low priority scheme. */
-	NSS_WIFILI_HIGH_PRIORITY_SCHEME,	/**< High priority scheme. */
-};
 
 /**
  * nss_wifili_wme_stream_classes
@@ -244,20 +184,6 @@ enum nss_wifili_msg_types {
 	NSS_WIFILI_ISOLATION_MSG,
 	NSS_WIFILI_PEER_EXT_STATS_MSG,
 	NSS_WIFILI_CLR_STATS,
-	NSS_WIFILI_PEER_4ADDR_EVENT_MSG,
-	NSS_WIFILI_DBDC_REPEATER_LOOP_DETECTION_MSG,
-	NSS_WIFILI_PEER_UPDATE_AUTH_FLAG,
-	NSS_WIFILI_SEND_MESH_CAPABILITY_INFO,
-	NSS_WIFILI_PDEV_TX_CAPTURE_MSG,
-	NSS_WIFILI_PEER_TX_CAPTURE_MSG,
-	NSS_WIFILI_PDEV_V3_RX_ERROR_STATS_SYNC_MSG,
-	NSS_WIFILI_SEND_DBG_LATENCY_EVENT_MSG,
-	NSS_WIFILI_SET_TX_LATENCY_THRESHOLD,
-	NSS_WIFILI_SET_TX_LATENCY_PKTLOG_THRESHOLD,
-	NSS_WIFILI_SET_V3_STATS_TX_DROP_TID,
-	NSS_WIFILI_SET_V3_STATS_TX_DROP_THRESHOLD,
-	NSS_WIFILI_ASTENTRY_SYNC_MSG,
-	NSS_WIFILI_MECENTRY_SYNC_MSG,
 	NSS_WIFILI_MAX_MSG
 };
 
@@ -404,8 +330,6 @@ enum nss_wifili_error_types {
 			/**< Invalid TLV length. */
 	NSS_WIFILI_EMESG_RX_BUF_LEN_INVALID,
 			/**< Invalid Rx buffer length. */
-	NSS_WIFILI_EMSG_TX_CAPTURE_MODE_UPDATE_FAIL,
-			/**< Tx capture mode update failure. */
 	NSS_WIFILI_EMSG_UNKNOWN
 			/**< Unknown error message. */
 };
@@ -435,7 +359,6 @@ enum nss_wifili_radio_cmd {
 	NSS_WIFILI_SET_FORCE_CLIENT_MCAST_TRAFFIC,	/**< Flag to force multicast traffic for a radio. */
 	NSS_WIFILI_SET_DROP_SECONDARY_MCAST,		/**< Flag to drop multicast traffic on secondary radio. */
 	NSS_WIFILI_SET_DBDC_FASTLANE,			/**< Flag to set DBDC fast-lane mode. */
-	NSS_WIFILI_SET_DBDC_NOBACKHAUL_RADIO,           /**< Flag to set DBDC to no backhaul radio. */
 	NSS_WIFILI_RADIO_MAX_CMD			/**< Maximum radio command index. */
 };
 
@@ -541,8 +464,6 @@ enum nss_wifili_stats_tx_comp {
 	NSS_WIFILI_STATS_TX_DESC_FREE_INV_COOKIE,	/**< Number of invalid cookie packets. */
 	NSS_WIFILI_STATS_TX_DESC_FREE_HW_RING_EMPTY,	/**< Number of times hardware ring empty found. */
 	NSS_WIFILI_STATS_TX_DESC_FREE_REAPED,		/**< Number of Tx packets that are reaped out of the Tx completion ring. */
-	NSS_WIFILI_STATS_TX_CAPTURE_ENQUEUE,		/**< Number of Tx packets enqueued to host. */
-	NSS_WIFILI_STATS_TX_CAPTURE_ENQUEUE_FAIL,	/**< Number of Tx packets failed to enqueue to host. */
 	NSS_WIFILI_STATS_TX_DESC_FREE_MAX,		/**< Number of Tx completion statistics. */
 };
 
@@ -642,14 +563,14 @@ enum nss_wifili_stats_rxdma_ring {
  *	Wifili WBM(Wireless Buffer Manager) ring statistics.
  */
 enum nss_wifili_stats_wbm {
-	NSS_WIFILI_STATS_WBM_IE_LOCAL_ALLOC_FAIL,	/**< Number of Wireless Buffer Manager internal local allocation failures. */
-	NSS_WIFILI_STATS_WBM_SRC_DMA,			/**< Number of receive invalid source DMA. */
-	NSS_WIFILI_STATS_WBM_SRC_DMA_CODE_INV,		/**< Number of receive invalid source DMA. */
-	NSS_WIFILI_STATS_WBM_SRC_REO,			/**< Number of receive invalid source reorder. */
-	NSS_WIFILI_STATS_WBM_SRC_REO_CODE_NULLQ,	/**< Number of receive invalid reorder error with NULL queue. */
-	NSS_WIFILI_STATS_WBM_SRC_REO_CODE_INV,		/**< Number of receive invalid reorder code invalid. */
-	NSS_WIFILI_STATS_WBM_SRC_INV,			/**< Number of receive invalid source invalid. */
-	NSS_WIFILI_STATS_WBM_MAX,			/**< Number of receive Wireless Buffer Manager statistics. */
+	NSS_WIFILI_STATS_WBM_IE_LOCAL_ALLOC_FAIL,	/**< Number of Wireless Buffer Manger internal local allocation failures. */
+	NSS_WIFILI_STATS_WBM_SRC_DMA,			/**< Number of Rx invalid source DMA. */
+	NSS_WIFILI_STATS_WBM_SRC_DMA_CODE_INV,		/**< Number of Rx invalid source DMA. */
+	NSS_WIFILI_STATS_WBM_SRC_REO,			/**< Number of Rx invalid source reorder. */
+	NSS_WIFILI_STATS_WBM_SRC_REO_CODE_NULLQ,	/**< Number of Rx invalid reorder error with NULL queue. */
+	NSS_WIFILI_STATS_WBM_SRC_REO_CODE_INV,		/**< Number of Rx invalid reorder code invalid. */
+	NSS_WIFILI_STATS_WBM_SRC_INV,			/**< Number of Rx invalid source invalid. */
+	NSS_WIFILI_STATS_WBM_MAX,			/**< Number of Rx Wireless Buffer Manager statistics. */
 };
 
 /**
@@ -681,12 +602,9 @@ struct nss_wifili_stats {
  * NSS wifili soc stats
  */
 struct nss_wifili_soc_stats {
-	uint32_t soc_maxpdev;
-					/**< Maximum number of radios per SoC. */
+	uint32_t soc_maxpdev;	/**< Maximum number of radios per SoC. */
 	struct nss_wifili_stats stats_wifili;
-					/**< Per-SoC statistics. */
-	char soc_type[NSS_WIFILI_SOC_STRING_SIZE_MAX];
-					/**< Target SoC type string. */
+				/**< Per-SoC statistics. */
 };
 
 /**
@@ -732,13 +650,11 @@ struct nss_wifili_hal_srng_info{
  */
 struct nss_wifili_hal_srng_soc_msg {
 	uint32_t dev_base_addr;
-			/**< Base address of WLAN device. */
+			/**< Base address of wlan dev. */
 	uint32_t shadow_rdptr_mem_addr;
 			/**< Shadow read pointer address. */
 	uint32_t shadow_wrptr_mem_addr;
 			/**< Shadow write pointer address. */
-	uint32_t lmac_rings_start_id;
-			/**< Start ID of LMAC rings. */
 };
 
 /**
@@ -857,10 +773,6 @@ struct nss_wifili_pdev_init_msg {
 			/**< Number of descriptors per Rx pool. */
 	uint32_t target_pdev_id;
 			/**< Target physical device ID. */
-	uint8_t scheme_id;
-			/**< Radio scheme ID. */
-	uint8_t reserved[3];
-			/**< Padding for alignment. */
 };
 
 /**
@@ -911,10 +823,6 @@ struct nss_wifili_peer_msg {
 			/**< AST hash to be used during packet transmission. */
 	uint32_t pext_stats_mem;
 			/**< Peer extended statistics memory. */
-	uint32_t flags;
-			/**< Peer flags. */
-	uint32_t peer_memory_size;
-			/**< Peer memory allocated from host to NSS. */
 };
 
 /**
@@ -1030,12 +938,10 @@ struct nss_wifili_tx_tcl_ring_stats {
  *	Tx completion ring statistics.
  */
 struct nss_wifili_tx_comp_ring_stats {
-	uint32_t invalid_bufsrc;		/**< Tx completion ring descriptor invalid buffer source. */
-	uint32_t invalid_cookie;		/**< Tx completion ring descriptor has invalid cookies. */
-	uint32_t hw_ring_empty;			/**< Tx completion hardware ring empty. */
-	uint32_t ring_reaped;			/**< Tx completion successfull ring reaped. */
-	uint32_t tx_cap_enqueue_count;		/**< Number of Tx packets enqueued to host. */
-	uint32_t tx_cap_enqueue_fail_count;	/**< Number of Tx packets failed to enqueue to host. */
+	uint32_t invalid_bufsrc;	/**< Tx comp (Completion) ring descriptor invalid buffer source. */
+	uint32_t invalid_cookie;	/**< Tx comletion ring descriptor has invalid cookies. */
+	uint32_t hw_ring_empty;		/**< Tx completion hardware ring empty. */
+	uint32_t ring_reaped;		/**< Tx completion successfull ring reaped. */
 };
 
 /**
@@ -1074,16 +980,16 @@ struct nss_wifili_rx_wbm_ring_stats {
 	uint32_t invalid_buf_mgr;		/**< Invalid buffer manager. */
 	uint32_t err_src_rxdma;			/**< Wireless Buffer Manager source is Rx DMA ring. */
 	uint32_t err_src_rxdma_code_inv;	/**< Wireless Buffer Manager source DMA reason unknown. */
-	uint32_t err_src_reo;			/**< Wireless Buffer Manager source is receive reorder ring. */
-	uint32_t err_src_reo_code_nullq;	/**< Wireless Buffer Manager source receive reorder ring because of NULL TLV. */
-	uint32_t err_src_reo_code_inv;		/**< Wireless Buffer Manager source receive reorder ring reason unknown. */
+	uint32_t err_src_reo;			/**< Wireless Buffer Manager source is Rx reorder ring. */
+	uint32_t err_src_reo_code_nullq;	/**< Wireless Buffer Manager source Rx reorder ring because of NULL TLV. */
+	uint32_t err_src_reo_code_inv;		/**< Wireless Buffer Manager source Rx reorder ring reason unknown. */
 	uint32_t err_src_invalid;		/**< Wireless Buffer Manager source is unknown. */
 	uint32_t err_reo_codes[NSS_WIFILI_REO_CODE_MAX];
-						/**< Receive reoder error codes. */
+						/**< Rx reoder error codes. */
 	uint32_t err_dma_codes[NSS_WIFILI_DMA_CODE_MAX];
 						/**< DMA error codes. */
 	uint32_t err_internal_codes[NSS_WIFILI_WBM_INTERNAL_ERR_MAX];
-						/**< Wireless Buffer Manager error codes. */
+						/**< Wireless Buffer Manger error codes. */
 };
 
 /**
@@ -1260,50 +1166,6 @@ struct nss_wifili_pdev_v3_delay_stats_sy
 };
 
 /**
- * nss_wifili_v3_reo_stats
- * 	Wifili REO error statistics for version 3.
- */
-struct nss_wifili_v3_reo_stats {
-	uint32_t err_src_reo_code_inv;
-			/**< Reason for the Wireless Buffer Manager Rx REO ring is unknown.. */
-	uint32_t err_reo_codes[NSS_WIFILI_REO_CODE_MAX];
-			/**< Rx REO error codes. */
-};
-
-/**
- * nss_wifili_v3_rxdma_stats
- * 	Wifili Rx DMA error statistics for version 3.
- */
-struct nss_wifili_v3_rxdma_stats {
-	uint32_t err_src_rxdma_code_inv;
-			/**< DMA reason unknown. */
-	uint32_t err_dma_codes[NSS_WIFILI_DMA_CODE_MAX];
-			/**< DMA Rx error codes. */
-};
-
-/**
- * nss_wifili_radio_error_stats_v3
- * 	Wifili radio error statistics for version 3.
- */
-struct nss_wifili_radio_error_stats_v3 {
-	struct nss_wifili_v3_reo_stats reo_stats[NSS_WIFILI_MAX_VOW_TID_NUM];
-				/**< REO statistics per maximum version 3 TID values. */
-	struct nss_wifili_v3_rxdma_stats rxdma_stats[NSS_WIFILI_MAX_VOW_TID_NUM];
-				/**< Rx DMA statistics per maximum version 3 TID values. */
-};
-
-/**
- * nss_wifili_pdev_v3_error_stats_sync_msg
- * 	Wifili message to synchronize version 3 error statistics to HLOS.
- */
-struct nss_wifili_pdev_v3_error_stats_sync_msg {
-	uint32_t radio_id;
-			/**< Radio ID of Wifili message. */
-	struct nss_wifili_radio_error_stats_v3 wlpv3_error_stats;
-			/**< Wifli version 3 error statistics. */
-};
-
-/**
  * nss_wifili_device_stats
  * 	Wifili specific statistics.
  */
@@ -1339,8 +1201,6 @@ struct nss_wifili_device_stats {
 struct nss_wifili_stats_sync_msg {
 	struct nss_wifili_device_stats stats;
 			/**< Device statistics. */
-	uint32_t target_type;
-			/**< Target SoC type. */
 };
 
 /**
@@ -1417,7 +1277,6 @@ struct nss_wifili_rx_err {
 struct nss_wifili_rx_ctrl_stats {
 	struct nss_wifili_rx_err err;			/**< Rx peer errors. */
 	uint32_t multipass_rx_pkt_drop;         /**< Total number of multipass packets without a VLAN header. */
-	uint32_t peer_unauth_rx_pkt_drop;		/**< Number of receive packets dropped due to an authorized peer. */
 	uint32_t reserved_type[NSS_WIFILI_MAX_RESERVED_TYPE];	/**< Reserved type for future use. */
 	uint32_t non_amsdu_cnt;			/**< Number of MSDUs with no MSDU level aggregation. */
 	uint32_t amsdu_cnt;			/**< Number of MSDUs part of AMSDU. */
@@ -1433,19 +1292,6 @@ struct nss_wifili_rx_ctrl_stats {
 	uint32_t rx_intra_bss_fail_bytes;	/**< Total Intra-BSS bytes received. */
 	uint32_t bcast_rcv_cnt;			/**< Total number of broadcast packets received. */
 	uint32_t bcast_rcv_bytes;		/**< Total number of broadcast bytes received. */
-	uint32_t defrag_mcast_drop;		/**< Total number of defrag multicast dropped packets. */
-	uint32_t mcast_3addr_drop;		/**< Total number of 3 address multicast dropped packets. */
-};
-
-/**
- * nss_wifili_retry_ctrl_stats
- *	Peer retry statistics.
- */
-struct nss_wifili_retry_ctrl_stats {
-	uint32_t tx_failed_retry_count;		/**< Transmit failed retry count. */
-	uint32_t tx_retry_count;		/**< Transmit retry count. */
-	uint32_t tx_multiple_retry_count;	/**< Transmit multiple retry count. */
-	uint32_t rx_retry_count;		/**< Receive retry count. */
 };
 
 /**
@@ -1458,8 +1304,6 @@ struct nss_wifili_peer_ctrl_stats {
 				/**< Peer Tx control statistics. */
 	struct nss_wifili_rx_ctrl_stats rx;
 				/**< Peer Rx control statistics. */
-	struct nss_wifili_retry_ctrl_stats retry;
-				/**< Peer retry Statistics. */
 };
 
 /**
@@ -1686,14 +1530,6 @@ struct nss_wifili_peer_isolation_msg {
 };
 
 /**
- * nss_wifili_dbdc_repeater_loop_detection_msg
- *	Wifili DBDC repeater loop detection message.
- */
-struct nss_wifili_dbdc_repeater_loop_detection_msg {
-	bool dbdc_loop_detected;		/**< DBDC repeater loop detection flag. */
-};
-
-/**
  * nss_wifili_dbdc_repeater_set_msg
  *	Wifili DBDC repeater set message.
  */
@@ -1746,16 +1582,6 @@ struct nss_wifili_clr_stats_msg {
 };
 
 /**
- * nss_wifili_update_auth_flag
- * 	Peer authentication flag message.
- */
-struct nss_wifili_peer_update_auth_flag {
-	uint16_t peer_id;		/**< Peer ID. */
-	uint8_t auth_flag;		/**< Peer authentication flag. */
-	uint8_t reserved;		/**< Alignment padding. */
-};
-
-/**
  * nss_wifili_update_pdev_lmac_id_msg
  * 	Physical device ID and lower MAC ID update message.
  */
@@ -1775,25 +1601,6 @@ struct nss_wifili_radio_cmd_msg {
 	uint32_t value;			/**< Value of the command. */
 };
 
-/*
- * nss_wifili_pdev_tx_capture_msg
- *	Tx capture enable per pdev message.
- */
-struct nss_wifili_pdev_tx_capture_msg {
-	uint8_t pdev_id;		/**< Physical device ID. */
-	uint8_t tx_cap_config;		/**< Flag to enable or disable Tx capture for physical device. */
-};
-
-/*
- * nss_wifili_peer_tx_capture_msg
- *	Tx capture enable per peer message.
- */
-struct nss_wifili_peer_tx_capture_msg {
-	uint16_t peer_id;		/**< Peer ID. */
-	uint8_t tx_cap_config;		/**< Flag to enable or disable Tx capture for peer. */
-	uint8_t reserved;		/**< Reserved. */
-};
-
 /**
  * nss_wifili_radio_buf_cfg_msg
  *	Wi-Fi Radio buffer requirement configuration.
@@ -1831,108 +1638,6 @@ struct nss_wifili_radio_cfg_msg {
 };
 
 /**
- * struct wifili_peer_wds_4addr_allow_msg
- *	Per-peer four address configuration message.
- */
-struct nss_wifili_peer_wds_4addr_allow_msg {
-	uint32_t peer_id;	/**< Peer ID. */
-	uint32_t if_num;	/**< Associate virtual interface number. */
-	bool enable;		/**< Boolean flag to enable/disable four address frames. */
-};
-
-/**
- * struct nss_wifili_mesh_capability_info
- * 	Wi-Fi mesh capability flag.
- */
-struct nss_wifili_mesh_capability_info {
-	bool mesh_enable;	/**< Wi-Fi mesh capability flag. */
-};
-
-/**
- * struct nss_wifili_dbg_latency_event_msg
- * 	Wifili debug latency event sent to host.
- */
-struct nss_wifili_dbg_latency_event_msg {
-	uint32_t tid;		/**< Traffic Identifier (TID) value. */
-	uint32_t pktlog_en;	/**< Packet log enable value. */
-	uint32_t value;		/**< Packet log enumeration value. */
-	uint32_t tx_latency;	/**< Transmit latency value of event. */
-	uint32_t tx_drop;	/**< Tx drop value */
-	uint16_t peer_id;	/**< Peer ID of event. */
-	uint8_t reserved[2];	/**< Reserved field. */
-};
-
-/*
- * nss_wifili_set_tx_latency_threshold
- * 	Sets transmit latency threshold value.
- */
-struct nss_wifili_set_tx_latency_threshold {
-	uint32_t radio_id;		/**< Radio ID of event. */
-	uint32_t latency_threshold;	/**< Latency threshold value.. */
-};
-
-/*
- * nss_wifli_v3_stats_set_vow_tid_msg
- * 	Sets TID value for version 3 debugging.
- */
-struct nss_wifli_v3_stats_set_vow_tid_msg {
-	uint32_t radio_id;	/**< Radio ID. */
-	uint32_t tid;		/**< Traffic Identifier (TID) value. */
-};
-
-/*
- * nss_wifili_set_tx_drop_threshold
- * 	Set Tx drop threshold value.
- */
-struct nss_wifili_set_tx_drop_threshold {
-	uint32_t radio_id;		/**< Radio ID. */
-	uint32_t tx_drop_threshold;	/**< Tx drop threshold value. */
-};
-
-/*
- * nss_wifi_peer_map_astentry_info
- *	NSS wifi peer map AST entry information.
- */
-struct nss_wifi_peer_map_astentry_info {
-	uint16_t entry_no;				/**< Entry number. */
-	uint16_t dest_mac_addr[ETH_ALEN/2];		/**< MAC address. */
-	uint16_t peer_id;				/**< Peer ID. */
-	uint16_t hw_ast_idx;				/**< Peer associated hardware IDX. */
-	uint16_t astinfoseq;				/**< AST entry information sequence. */
-	uint8_t radio_id;				/**< AST entry radio ID. */
-	uint8_t ast_type;				/**< AST entry type. */
-};
-
-/*
- * nss_wifili_astentry_info_msg
- *	NSS wifili AST entry information message.
- */
-struct nss_wifili_astentry_info_msg {
-	uint16_t nentries;					/**< Number of entries in the information message. */
-	struct nss_wifi_peer_map_astentry_info info[0];		/**< AST entry information specific message. */
-};
-
-/*
- * nss_wifi_peer_map_mecentry_info
- *	NSS wifi peer map MEC entry information.
- */
-struct nss_wifi_peer_map_mecentry_info {
-	uint16_t entry_no;			/**< Entry number. */
-	uint16_t mac_addr[ETH_ALEN/2];		/**< MAC address. */
-	uint8_t radio_id;			/**< MEC entry radio ID. */
-	uint8_t reserved[3];			/**< Reserved fields. */
-};
-
-/*
- * nss_wifili_mecentry_info_msg
- *	NSS wifili MEC entry information message.
- */
-struct nss_wifili_mecentry_info_msg {
-	uint16_t nentries;				/**< Number of entries in the information message. */
-	struct nss_wifi_peer_map_mecentry_info info[0];	/**< MEC entry information specific message. */
-};
-
-/*
  * nss_wifili_msg
  *	Structure that describes wifili messages.
  */
@@ -2008,32 +1713,6 @@ struct nss_wifili_msg {
 				/**< Peer extended statistics message. */
 		struct nss_wifili_clr_stats_msg clrstats;
 				/**< Clear NSS firmware statistics. */
-		struct nss_wifili_peer_wds_4addr_allow_msg wpswm;
-				/**< Peer four-address event message. */
-		struct nss_wifili_dbdc_repeater_loop_detection_msg wdrldm;
-				/**< Wifili DBDC repeater loop detection message. */
-		struct nss_wifili_peer_update_auth_flag peer_auth;
-				/**< Peer authentication flag message. */
-		struct nss_wifili_mesh_capability_info cap_info;
-				/**< Mesh capability flag. */
-		struct nss_wifili_pdev_tx_capture_msg pdevtxcapmsg;
-				/**< Wifili physical device Tx capture message. */
-		struct nss_wifili_peer_tx_capture_msg peertxcapmsg;
-				/**< Wifili peer Tx capture message. */
-		struct nss_wifili_pdev_v3_error_stats_sync_msg v3_rx_error_stats_msg;
-				/**< Wifili version 3 Rx error statistics message. */
-		struct nss_wifili_dbg_latency_event_msg dbg_info;
-				/**< Debug latency event for host. */
-		struct nss_wifili_set_tx_latency_threshold tx_latency_threshold;
-				/**< Tx latency threshold value. */
-		struct nss_wifli_v3_stats_set_vow_tid_msg v3_tid;
-				/**< TID value for version 3. */
-		struct nss_wifili_set_tx_drop_threshold tx_drop_threshold;
-				/**< Tx drop threshold value. */
-		struct nss_wifili_astentry_info_msg astinfo;
-				/**< Wifili AST database entry information message. */
-		struct nss_wifili_mecentry_info_msg mecinfo;
-				/**< Wifili MEC database entry information message. */
 	} msg;			/**< Message payload. */
 };
 
@@ -2178,60 +1857,7 @@ void nss_unregister_wifili_radio_if(uint
  * @return
  * External interface number.
  */
-nss_if_num_t nss_get_available_wifili_external_if(void);
-
-/**
- * nss_wifili_release_external_if
- *	Release the used interface number
- *
- * @datatypes
- * nss_if_num
- *
- * @param[in] if_num             NSS interface number.
- *
- * @return
- * void
- */
-void nss_wifili_release_external_if(nss_if_num_t ifnum);
-
-/**
- * nss_wifili_thread_scheme_alloc
- *	Allocate thread scheme entry and return scheme index.
- *
- * @param[in] nss_ctx  NSS context pointer.
- * @param[in] radio_ifnum  Radio interface number.
- * @param[in] radio_priority  Radio Priority requested.
- *
- * @return
- * uint8_t.
- */
-uint8_t nss_wifili_thread_scheme_alloc(struct nss_ctx_instance *nss_ctx,
-				int32_t radio_ifnum,
-				uint32_t radio_priority);
-
-/**
- * nss_wifili_thread_scheme_dealloc
- *	Release thread scheme database entry.
- *
- * @param[in] nss_ctx  NSS context pointer.
- * @param[in] radio_ifnum  Radio interface number.
- *
- * @return
- * void.
- */
-void nss_wifili_thread_scheme_dealloc(struct nss_ctx_instance *nss_ctx,
-				int32_t radio_ifnum);
-
-/**
- * nss_wifili_get_radio_num
- *    Get radio number.
- *
- * @param[in] nss_ctx  NSS context pointer.
- *
- * @return
- * uint32_t.
- */
-uint32_t nss_wifili_get_radio_num(struct nss_ctx_instance *nss_ctx);
+uint32_t nss_get_available_wifili_external_if(void);
 
 /**
  * nss_wifili_stats_register_notifier
--- a/nss_capwap.c
+++ b/nss_capwap.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -49,32 +49,16 @@ struct nss_capwap_handle {
 static struct nss_capwap_handle *nss_capwap_hdl[NSS_MAX_DYNAMIC_INTERFACES];
 
 /*
- * nss_capwap_get_interface_type()
- *	Function to get the type of dynamic interface.
- */
-static enum nss_dynamic_interface_type nss_capwap_get_interface_type(uint32_t if_num)
-{
-	struct nss_ctx_instance *nss_ctx;
-	nss_ctx = &nss_top_main.nss[nss_top_main.capwap_handler_id];
-	NSS_VERIFY_CTX_MAGIC(nss_ctx);
-
-	return nss_dynamic_interface_get_type(nss_ctx, if_num);
-}
-
-/*
  * nss_capwap_verify_if_num()
  *	Verify if_num passed to us.
  */
 static bool nss_capwap_verify_if_num(uint32_t if_num)
 {
-	enum nss_dynamic_interface_type type;
-
 	if (nss_is_dynamic_interface(if_num) == false) {
 		return false;
 	}
 
-	type = nss_capwap_get_interface_type(if_num);
-	if ((type != NSS_DYNAMIC_INTERFACE_TYPE_CAPWAP_HOST_INNER) && (type != NSS_DYNAMIC_INTERFACE_TYPE_CAPWAP_OUTER) ) {
+	if (nss_dynamic_interface_get_type(nss_capwap_get_ctx(), if_num) != NSS_DYNAMIC_INTERFACE_TYPE_CAPWAP) {
 		return false;
 	}
 
@@ -104,10 +88,10 @@ static void nss_capwap_refcnt_dec(int32_
 }
 
 /*
- * nss_capwap_refcnt_get()
+ * nss_capwap_refcnt()
  *	Get refcnt on the tunnel.
  */
-static uint32_t nss_capwap_refcnt_get(int32_t if_num)
+static uint32_t nss_capwap_refcnt(int32_t if_num)
 {
 	if_num = if_num - NSS_DYNAMIC_IF_START;
 	return atomic_read(&nss_capwap_hdl[if_num]->refcnt);
@@ -149,62 +133,45 @@ static nss_capwap_msg_callback_t nss_cap
 }
 
 /*
- * nss_capwap_update_stats()
+ * nss_capwapmgr_update_stats()
  *	Update per-tunnel stats for each CAPWAP interface.
  */
-static void nss_capwap_update_stats(struct nss_capwap_handle *handle, struct nss_capwap_stats_msg *fstats)
+static void nss_capwapmgr_update_stats(struct nss_capwap_handle *handle, struct nss_capwap_stats_msg *fstats)
 {
 	struct nss_capwap_tunnel_stats *stats;
-	enum nss_dynamic_interface_type type;
 
 	stats = &handle->stats;
-	type = nss_capwap_get_interface_type(handle->if_num);
 
-	switch(type) {
-	case NSS_DYNAMIC_INTERFACE_TYPE_CAPWAP_OUTER:
-		stats->rx_segments += fstats->rx_segments;
-		stats->dtls_pkts += fstats->dtls_pkts;
-		stats->rx_dup_frag += fstats->rx_dup_frag;
-		stats->rx_oversize_drops += fstats->rx_oversize_drops;
-		stats->rx_frag_timeout_drops += fstats->rx_frag_timeout_drops;
-		stats->rx_n2h_drops += fstats->rx_n2h_drops;
-		stats->rx_n2h_queue_full_drops += fstats->rx_n2h_queue_full_drops;
-		stats->rx_mem_failure_drops += fstats->rx_mem_failure_drops;
-		stats->rx_csum_drops += fstats->rx_csum_drops;
-		stats->rx_malformed += fstats->rx_malformed;
-		stats->rx_frag_gap_drops += fstats->rx_frag_gap_drops;
-
-		/*
-		 * Update pnode rx stats for OUTER node.
-		 */
-		stats->pnode_stats.rx_packets += fstats->pnode_stats.rx_packets;
-		stats->pnode_stats.rx_bytes += fstats->pnode_stats.rx_bytes;
-		stats->pnode_stats.rx_dropped += nss_cmn_rx_dropped_sum(&fstats->pnode_stats);
-		break;
-
-	case NSS_DYNAMIC_INTERFACE_TYPE_CAPWAP_HOST_INNER:
-		stats->tx_segments += fstats->tx_segments;
-		stats->tx_queue_full_drops += fstats->tx_queue_full_drops;
-		stats->tx_mem_failure_drops += fstats->tx_mem_failure_drops;
-		stats->tx_dropped_sg_ref += fstats->tx_dropped_sg_ref;
-		stats->tx_dropped_ver_mis += fstats->tx_dropped_ver_mis;
-		stats->tx_dropped_hroom += fstats->tx_dropped_hroom;
-		stats->tx_dropped_dtls += fstats->tx_dropped_dtls;
-		stats->tx_dropped_nwireless += fstats->tx_dropped_nwireless;
-
-		/*
-		 * Update pnode tx stats for INNER node.
-		 */
-		stats->pnode_stats.tx_packets += fstats->pnode_stats.tx_packets;
-		stats->pnode_stats.tx_bytes += fstats->pnode_stats.tx_bytes;
-		stats->tx_dropped_inner += nss_cmn_rx_dropped_sum(&fstats->pnode_stats);
-		break;
-
-	default:
-		nss_warning("%px: Received invalid dynamic interface type: %d", handle, type);
-		nss_assert(0);
-		return;
-	}
+	stats->rx_segments += fstats->rx_segments;
+	stats->dtls_pkts += fstats->dtls_pkts;
+
+	stats->rx_dup_frag += fstats->rx_dup_frag;
+	stats->rx_oversize_drops += fstats->rx_oversize_drops;
+	stats->rx_frag_timeout_drops += fstats->rx_frag_timeout_drops;
+	stats->rx_queue_full_drops += fstats->rx_queue_full_drops;
+	stats->rx_n2h_queue_full_drops += fstats->rx_n2h_queue_full_drops;
+	stats->rx_mem_failure_drops += fstats->rx_mem_failure_drops;
+	stats->rx_csum_drops += fstats->rx_csum_drops;
+	stats->rx_malformed += fstats->rx_malformed;
+	stats->rx_frag_gap_drops += fstats->rx_frag_gap_drops;
+
+	stats->tx_segments += fstats->tx_segments;
+	stats->tx_queue_full_drops += fstats->tx_queue_full_drops;
+	stats->tx_mem_failure_drops += fstats->tx_mem_failure_drops;
+	stats->tx_dropped_sg_ref += fstats->tx_dropped_sg_ref;
+	stats->tx_dropped_ver_mis += fstats->tx_dropped_ver_mis;
+	stats->tx_dropped_hroom += fstats->tx_dropped_hroom;
+	stats->tx_dropped_dtls += fstats->tx_dropped_dtls;
+	stats->tx_dropped_nwireless += fstats->tx_dropped_nwireless;
+
+	/*
+	 * add pnode stats now.
+	 */
+	stats->pnode_stats.rx_packets += fstats->pnode_stats.rx_packets;
+	stats->pnode_stats.rx_bytes += fstats->pnode_stats.rx_bytes;
+	stats->pnode_stats.rx_dropped += nss_cmn_rx_dropped_sum(&fstats->pnode_stats);
+	stats->pnode_stats.tx_packets += fstats->pnode_stats.tx_packets;
+	stats->pnode_stats.tx_bytes += fstats->pnode_stats.tx_bytes;
 
 	/*
 	 * Set to 1 when the tunnel is operating in fast memory.
@@ -250,7 +217,7 @@ static void nss_capwap_msg_handler(struc
 				/*
 				 * Update driver statistics and send statistics notifications to the registered modules.
 				 */
-				nss_capwap_update_stats(nss_capwap_hdl[if_num], &ntm->msg.stats);
+				nss_capwapmgr_update_stats(nss_capwap_hdl[if_num], &ntm->msg.stats);
 				nss_capwap_stats_notify(ncm->interface, nss_ctx->id);
 			}
 		}
@@ -295,23 +262,23 @@ static bool nss_capwap_instance_alloc(st
 	memset(h, 0, sizeof(struct nss_capwap_handle));
 	h->if_num = if_num;
 
-	spin_lock_bh(&nss_capwap_spinlock);
+	spin_lock(&nss_capwap_spinlock);
 	if (nss_capwap_hdl[if_num - NSS_DYNAMIC_IF_START] != NULL) {
-		spin_unlock_bh(&nss_capwap_spinlock);
+		spin_unlock(&nss_capwap_spinlock);
 		kfree(h);
 		nss_warning("%px: Another thread is already allocated instance for :%d", nss_ctx, if_num);
 		return false;
 	}
 
 	nss_capwap_hdl[if_num - NSS_DYNAMIC_IF_START] = h;
-	spin_unlock_bh(&nss_capwap_spinlock);
+	spin_unlock(&nss_capwap_spinlock);
 
 	return true;
 }
 
 /*
  * nss_capwap_tx_msg()
- *	Transmit a CAPWAP message to NSS FW. Don't call this from softirq/interrupts.
+ * 	Transmit a CAPWAP message to NSS FW. Don't call this from softirq/interrupts.
  */
 nss_tx_status_t nss_capwap_tx_msg(struct nss_ctx_instance *nss_ctx, struct nss_capwap_msg *msg)
 {
@@ -332,14 +299,14 @@ nss_tx_status_t nss_capwap_tx_msg(struct
 	}
 
 	if_num = msg->cm.interface - NSS_DYNAMIC_IF_START;
-	spin_lock_bh(&nss_capwap_spinlock);
+	spin_lock(&nss_capwap_spinlock);
 	if (!nss_capwap_hdl[if_num]) {
-		spin_unlock_bh(&nss_capwap_spinlock);
+		spin_unlock(&nss_capwap_spinlock);
 		nss_warning("%px: capwap tunnel if_num is not there: %d", nss_ctx, msg->cm.interface);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 	nss_capwap_refcnt_inc(msg->cm.interface);
-	spin_unlock_bh(&nss_capwap_spinlock);
+	spin_unlock(&nss_capwap_spinlock);
 
 	/*
 	 * Trace messages.
@@ -381,14 +348,14 @@ bool nss_capwap_get_stats(uint32_t if_nu
 	}
 
 	if_num = if_num - NSS_DYNAMIC_IF_START;
-	spin_lock_bh(&nss_capwap_spinlock);
+	spin_lock(&nss_capwap_spinlock);
 	if (nss_capwap_hdl[if_num] == NULL) {
-		spin_unlock_bh(&nss_capwap_spinlock);
+		spin_unlock(&nss_capwap_spinlock);
 		return false;
 	}
 
 	memcpy(stats, &nss_capwap_hdl[if_num]->stats, sizeof(struct nss_capwap_tunnel_stats));
-	spin_unlock_bh(&nss_capwap_spinlock);
+	spin_unlock(&nss_capwap_spinlock);
 	return true;
 }
 EXPORT_SYMBOL(nss_capwap_get_stats);
@@ -409,13 +376,13 @@ struct nss_ctx_instance *nss_capwap_noti
 		return NULL;
 	}
 
-	spin_lock_bh(&nss_capwap_spinlock);
+	spin_lock(&nss_capwap_spinlock);
 	if (nss_capwap_hdl[if_num - NSS_DYNAMIC_IF_START] != NULL) {
-		spin_unlock_bh(&nss_capwap_spinlock);
+		spin_unlock(&nss_capwap_spinlock);
 		nss_warning("%px: notfiy register tunnel already exists for interface %d", nss_ctx, if_num);
 		return NULL;
 	}
-	spin_unlock_bh(&nss_capwap_spinlock);
+	spin_unlock(&nss_capwap_spinlock);
 
 	return nss_ctx;
 }
@@ -443,9 +410,9 @@ nss_tx_status_t nss_capwap_notify_unregi
 	}
 
 	index = if_num - NSS_DYNAMIC_IF_START;
-	spin_lock_bh(&nss_capwap_spinlock);
+	spin_lock(&nss_capwap_spinlock);
 	if (nss_capwap_hdl[index] == NULL) {
-		spin_unlock_bh(&nss_capwap_spinlock);
+		spin_unlock(&nss_capwap_spinlock);
 		nss_warning("%px: notify unregister received for unallocated if_num: %d", nss_ctx, if_num);
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
@@ -454,14 +421,14 @@ nss_tx_status_t nss_capwap_notify_unregi
 	 * It's the responsibility of caller to wait and call us again. We return failure saying
 	 * that we can't remove msg handler now.
 	 */
-	if (nss_capwap_refcnt_get(if_num) != 0) {
-		spin_unlock_bh(&nss_capwap_spinlock);
+	if (nss_capwap_refcnt(if_num) != 0) {
+		spin_unlock(&nss_capwap_spinlock);
 		nss_warning("%px: notify unregister tunnel %d: has reference", nss_ctx, if_num);
 		return NSS_TX_FAILURE_QUEUE;
 	}
 
 	nss_capwap_set_msg_callback(if_num, NULL, NULL);
-	spin_unlock_bh(&nss_capwap_spinlock);
+	spin_unlock(&nss_capwap_spinlock);
 
 	return NSS_TX_SUCCESS;
 }
@@ -482,12 +449,12 @@ struct nss_ctx_instance *nss_capwap_data
 		return NULL;
 	}
 
-	spin_lock_bh(&nss_capwap_spinlock);
+	spin_lock(&nss_capwap_spinlock);
 	if (nss_ctx->subsys_dp_register[if_num].ndev != NULL) {
-		spin_unlock_bh(&nss_capwap_spinlock);
+		spin_unlock(&nss_capwap_spinlock);
 		return NULL;
 	}
-	spin_unlock_bh(&nss_capwap_spinlock);
+	spin_unlock(&nss_capwap_spinlock);
 
 	core_status = nss_core_register_handler(nss_ctx, if_num, nss_capwap_msg_handler, NULL);
 	if (core_status != NSS_CORE_STATUS_SUCCESS) {
@@ -521,18 +488,18 @@ bool nss_capwap_data_unregister(uint32_t
 		return false;
 	}
 
-	spin_lock_bh(&nss_capwap_spinlock);
+	spin_lock(&nss_capwap_spinlock);
 	/*
 	 * It's the responsibility of caller to wait and call us again.
 	 */
-	if (nss_capwap_refcnt_get(if_num) != 0) {
-		spin_unlock_bh(&nss_capwap_spinlock);
+	if (nss_capwap_refcnt(if_num) != 0) {
+		spin_unlock(&nss_capwap_spinlock);
 		nss_warning("%px: notify unregister tunnel %d: has reference", nss_ctx, if_num);
 		return false;
 	}
 	h = nss_capwap_hdl[if_num - NSS_DYNAMIC_IF_START];
 	nss_capwap_hdl[if_num - NSS_DYNAMIC_IF_START] = NULL;
-	spin_unlock_bh(&nss_capwap_spinlock);
+	spin_unlock(&nss_capwap_spinlock);
 
 	(void) nss_core_unregister_handler(nss_ctx, if_num);
 
--- a/nss_capwap_stats.c
+++ b/nss_capwap_stats.c
@@ -50,7 +50,7 @@ static ssize_t nss_capwap_stats_encap(ch
 		tcnt = s->tx_dropped_ver_mis;
 		break;
 	case 5:
-		tcnt = s->tx_dropped_inner;
+		tcnt = 0;
 		break;
 	case 6:
 		tcnt = s->tx_dropped_hroom;
@@ -114,7 +114,7 @@ static ssize_t nss_capwap_stats_decap(ch
 		tcnt = s->rx_frag_gap_drops;
 		break;
 	case 9:
-		tcnt = s->rx_n2h_drops;
+		tcnt = s->rx_queue_full_drops;
 		return snprintf(line, len, "%s = %llu (n2h = %llu)\n", nss_capwap_strings_decap_stats[i].stats_name, tcnt, s->rx_n2h_queue_full_drops);
 	case 10:
 		tcnt = s->rx_n2h_queue_full_drops;
@@ -166,22 +166,12 @@ static ssize_t nss_capwap_stats_read(str
 
 	for (; if_num <= max_if_num; if_num++) {
 		bool isthere;
-		enum nss_dynamic_interface_type dtype;
 
 		if (nss_is_dynamic_interface(if_num) == false) {
 			continue;
 		}
 
-		dtype = nss_dynamic_interface_get_type(nss_capwap_get_ctx(), if_num);
-
-		/*
-		 * Read encap stats from inner node and decap stats from outer node.
-		 */
-		if ((type == 1) && (dtype != NSS_DYNAMIC_INTERFACE_TYPE_CAPWAP_HOST_INNER)) {
-			continue;
-		}
-
-		if ((type == 0) && (dtype != NSS_DYNAMIC_INTERFACE_TYPE_CAPWAP_OUTER)) {
+		if (nss_dynamic_interface_get_type(nss_capwap_get_ctx(), if_num) != NSS_DYNAMIC_INTERFACE_TYPE_CAPWAP) {
 			continue;
 		}
 
--- a/nss_capwap_strings.c
+++ b/nss_capwap_strings.c
@@ -32,7 +32,7 @@ struct nss_stats_info nss_capwap_strings
 	{"tx_segments",		NSS_STATS_TYPE_SPECIAL},
 	{"tx_drop_seg_ref",	NSS_STATS_TYPE_DROP},
 	{"tx_drop_ver_mismatch",NSS_STATS_TYPE_DROP},
-	{"tx_dropped_inner",	NSS_STATS_TYPE_DROP},
+	{"tx_drop_unalign",	NSS_STATS_TYPE_DROP},
 	{"tx_drop_hroom",	NSS_STATS_TYPE_DROP},
 	{"tx_drop_DTLS",	NSS_STATS_TYPE_DROP},
 	{"tx_drop_nwireless",	NSS_STATS_TYPE_DROP},
@@ -69,7 +69,7 @@ struct nss_stats_info nss_capwap_strings
 	{"rx_drop_frag_timeout",NSS_STATS_TYPE_DROP},
 	{"rx_drop_frag_dup",	NSS_STATS_TYPE_DROP},
 	{"rx_drop_frag_gap",	NSS_STATS_TYPE_DROP},
-	{"rx_drop_n2h",		NSS_STATS_TYPE_DROP},
+	{"rx_drop_qfull",	NSS_STATS_TYPE_DROP},
 	{"rx_drop_n2h_qfull",	NSS_STATS_TYPE_DROP},
 	{"rx_drop_mem_fail",	NSS_STATS_TYPE_DROP},
 	{"rx_drop_csum",	NSS_STATS_TYPE_DROP},
--- a/nss_clmap.c
+++ b/nss_clmap.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -23,7 +23,6 @@
 #include "nss_cmn.h"
 #include "nss_tx_rx_common.h"
 #include "nss_clmap_stats.h"
-#include "nss_clmap_strings.h"
 #include "nss_clmap_log.h"
 
 #define NSS_CLMAP_TX_TIMEOUT 3000
@@ -107,7 +106,6 @@ static void nss_clmap_msg_handler(struct
 	switch (nclm->cm.type) {
 	case NSS_CLMAP_MSG_TYPE_SYNC_STATS:
 		nss_clmap_stats_sync(nss_ctx, &nclm->msg.stats, ncm->interface);
-		nss_clmap_stats_notify(nss_ctx, ncm->interface);
 		break;
 	}
 
@@ -116,7 +114,7 @@ static void nss_clmap_msg_handler(struct
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
 		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
-		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[ncm->interface].app_data;
+		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[nss_ctx->id][ncm->interface].app_data;
 	}
 
 	/*
@@ -338,9 +336,7 @@ EXPORT_SYMBOL(nss_clmap_get_ctx);
  */
 void nss_clmap_init()
 {
+	nss_clmap_stats_dentry_create();
 	sema_init(&clmap_pvt.sem, 1);
 	init_completion(&clmap_pvt.complete);
-
-	nss_clmap_stats_dentry_create();
-	nss_clmap_strings_dentry_create();
 }
--- a/nss_clmap_stats.c
+++ b/nss_clmap_stats.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -15,25 +15,15 @@
  */
 
 #include "nss_tx_rx_common.h"
-#include "nss_clmap.h"
 #include "nss_clmap_stats.h"
-#include "nss_clmap_strings.h"
 
-/*
- * Declare atomic notifier data structure for statistics.
- */
-ATOMIC_NOTIFIER_HEAD(nss_clmap_stats_notifier);
-
-/*
- * Spinlock to protect clmap statistics update/read
- */
 DEFINE_SPINLOCK(nss_clmap_stats_lock);
 
 struct nss_clmap_stats *stats_db[NSS_CLMAP_MAX_DEBUG_INTERFACES] = {NULL};
 
 /*
  * nss_clmap_interface_type_str
- *	Clmap interface type string.
+ * 	Clmap interface type string.
  */
 static char *nss_clmap_interface_type_str[NSS_CLMAP_INTERFACE_TYPE_MAX] = {
 	"Upstream",
@@ -41,23 +31,34 @@ static char *nss_clmap_interface_type_st
 };
 
 /*
- * nss_clmap_stats_session_unregister
- *	Unregister debug statistic for clmap session.
+ * nss_clmap_stats_str
+ *	Clmap statistics strings for nss tunnel stats
  */
-void nss_clmap_stats_session_unregister(uint32_t if_num)
-{
-	uint32_t i;
-
-	spin_lock_bh(&nss_clmap_stats_lock);
-	for (i = 0; i < NSS_CLMAP_MAX_DEBUG_INTERFACES; i++) {
-		if (stats_db[i] && (stats_db[i]->nss_if_num == if_num)) {
-			kfree(stats_db[i]);
-			stats_db[i] = NULL;
-			break;
-		}
-	}
-	spin_unlock_bh(&nss_clmap_stats_lock);
-}
+static char *nss_clmap_stats_str[NSS_CLMAP_INTERFACE_STATS_MAX] = {
+	"rx_pkts",
+	"rx_bytes",
+	"tx_pkts",
+	"tx_bytes",
+	"rx_queue_0_dropped",
+	"rx_queue_1_dropped",
+	"rx_queue_2_dropped",
+	"rx_queue_3_dropped",
+	"MAC DB look up failed",
+	"Invalid packet count",
+	"Headroom drop",
+	"Next node queue full drop",
+	"Pbuf alloc failed drop",
+	"Linear failed drop",
+	"Shared packet count",
+	"Ethernet frame error",
+	"Macdb create requests count",
+	"Macdb create failures MAC exists count",
+	"Macdb create failures MAC table full count",
+	"Macdb destroy requests count",
+	"Macdb destroy failures MAC not found count",
+	"Macdb destroy failures MAC unhashed count",
+	"Macdb flush requests count"
+};
 
 /*
  * nss_clmap_stats_session_register
@@ -94,6 +95,25 @@ bool nss_clmap_stats_session_register(ui
 }
 
 /*
+ * nss_clmap_stats_session_unregister
+ * 	Unregister debug statistic for clmap session.
+ */
+void nss_clmap_stats_session_unregister(uint32_t if_num)
+{
+	uint32_t i;
+
+	spin_lock_bh(&nss_clmap_stats_lock);
+	for (i = 0; i < NSS_CLMAP_MAX_DEBUG_INTERFACES; i++) {
+		if (stats_db[i] && (stats_db[i]->nss_if_num == if_num)) {
+			kfree(stats_db[i]);
+			stats_db[i] = NULL;
+			break;
+		}
+	}
+	spin_unlock_bh(&nss_clmap_stats_lock);
+}
+
+/*
  * nss_clmap_get_debug_stats()
  *	Get clmap debug statistics.
  */
@@ -122,12 +142,12 @@ static int nss_clmap_get_debug_stats(str
 static ssize_t nss_clmap_stats_read(struct file *fp, char __user *ubuf,
 					size_t sz, loff_t *ppos)
 {
-	uint32_t max_output_lines = (NSS_CLMAP_INTERFACE_STATS_MAX * NSS_CLMAP_MAX_DEBUG_INTERFACES) + NSS_STATS_EXTRA_OUTPUT_LINES;
+	uint32_t max_output_lines = 2 + (NSS_CLMAP_INTERFACE_STATS_MAX * NSS_CLMAP_MAX_DEBUG_INTERFACES + 2) + 2;
 	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
 	size_t size_wr = 0;
 	ssize_t bytes_read = 0;
 	struct net_device *dev;
-	uint32_t id;
+	uint32_t id, i;
 	struct nss_clmap_stats *clmap_stats = NULL;
 	int interface_cnt;
 
@@ -151,7 +171,8 @@ static ssize_t nss_clmap_stats_read(stru
 	 * Get clmap statistics.
 	 */
 	interface_cnt = nss_clmap_get_debug_stats(clmap_stats);
-	size_wr += nss_stats_banner(lbuf, size_wr, size_al, "clmap stats", NSS_STATS_SINGLE_CORE);
+	size_wr = scnprintf(lbuf + size_wr, size_al - size_wr,
+			"\n clmap Interface statistics start:\n\n");
 	for (id = 0; id < interface_cnt; id++) {
 		struct nss_clmap_stats *clmsp = clmap_stats + id;
 
@@ -169,10 +190,16 @@ static ssize_t nss_clmap_stats_read(stru
 				clmsp->nss_if_num, nss_clmap_interface_type_str[clmsp->nss_if_type], dev->name);
 		dev_put(dev);
 
-		size_wr += nss_stats_print("clmap", NULL, NSS_STATS_SINGLE_INSTANCE, nss_clmap_strings_stats,
-						clmsp->stats, NSS_CLMAP_INTERFACE_STATS_MAX, lbuf, size_wr, size_al);
+		for (i = 0; i < NSS_CLMAP_INTERFACE_STATS_MAX; i++) {
+			size_wr += scnprintf(lbuf + size_wr, size_al - size_wr,
+					"\t%s = %llu\n", nss_clmap_stats_str[i],
+					clmsp->stats[i]);
+		}
+		size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\n");
 	}
 
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr,
+			"\n clmap Interface statistics end\n");
 	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, size_wr);
 
 	kfree(clmap_stats);
@@ -245,52 +272,3 @@ void nss_clmap_stats_dentry_create(void)
 {
 	nss_stats_create_dentry("clmap", &nss_clmap_stats_ops);
 }
-
-/*
- * nss_clmap_stats_notify()
- *	Sends notifications to all the registered modules.
- *
- * Leverage NSS-FW statistics timing to update Netlink.
- */
-void nss_clmap_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num)
-{
-	struct nss_clmap_stats_notification clmap_stats;
-	struct nss_clmap_stats *s = NULL;
-	int i;
-
-	spin_lock_bh(&nss_clmap_stats_lock);
-	for (i = 0; i < NSS_CLMAP_MAX_DEBUG_INTERFACES; i++) {
-		if (!stats_db[i] || (stats_db[i]->nss_if_num != if_num)) {
-			continue;
-		}
-
-		s = stats_db[i];
-		clmap_stats.core_id = nss_ctx->id;
-		clmap_stats.if_num = if_num;
-		memcpy(clmap_stats.stats_ctx, s->stats, sizeof(clmap_stats.stats_ctx));
-		spin_unlock_bh(&nss_clmap_stats_lock);
-		atomic_notifier_call_chain(&nss_clmap_stats_notifier, NSS_STATS_EVENT_NOTIFY, &clmap_stats);
-		return;
-	}
-	spin_unlock_bh(&nss_clmap_stats_lock);
-}
-
-/*
- * nss_clmap_stats_unregister_notifier()
- *	Deregisters statistics notifier.
- */
-int nss_clmap_stats_unregister_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_unregister(&nss_clmap_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_clmap_stats_unregister_notifier);
-
-/*
- * nss_clmap_stats_register_notifier()
- *	Registers statistics notifier.
- */
-int nss_clmap_stats_register_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_register(&nss_clmap_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_clmap_stats_register_notifier);
--- a/nss_clmap_stats.h
+++ b/nss_clmap_stats.h
@@ -1,6 +1,6 @@
 /*
  ******************************************************************************
- * Copyright (c) 2019, 2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -20,11 +20,50 @@
 #define NSS_CLMAP_MAX_DEBUG_INTERFACES 2 * NSS_CLMAP_MAX_INTERFACES
 
 /*
+ * Clmap NSS interface type.
+ */
+enum nss_clmap_interface_type {
+	NSS_CLMAP_INTERFACE_TYPE_US,
+	NSS_CLMAP_INTERFACE_TYPE_DS,
+	NSS_CLMAP_INTERFACE_TYPE_MAX
+};
+
+/*
+ * Clmap statistic counters.
+ */
+enum nss_clmap_stats_type {
+        NSS_CLMAP_INTERFACE_STATS_RX_PKTS,
+        NSS_CLMAP_INTERFACE_STATS_RX_BYTES,
+        NSS_CLMAP_INTERFACE_STATS_TX_PKTS,
+        NSS_CLMAP_INTERFACE_STATS_TX_BYTES,
+        NSS_CLMAP_INTERFACE_STATS_RX_QUEUE_0_DROPPED,
+        NSS_CLMAP_INTERFACE_STATS_RX_QUEUE_1_DROPPED,
+        NSS_CLMAP_INTERFACE_STATS_RX_QUEUE_2_DROPPED,
+        NSS_CLMAP_INTERFACE_STATS_RX_QUEUE_3_DROPPED,
+	NSS_CLMAP_INTERFACE_STATS_DROPPED_MACDB_LOOKUP_FAILED,
+	NSS_CLMAP_INTERFACE_STATS_DROPPED_INVALID_PACKET_SIZE,
+	NSS_CLMAP_INTERFACE_STATS_DROPPED_LOW_HEADROOM,
+	NSS_CLMAP_INTERFACE_STATS_DROPPED_NEXT_NODE_QUEUE_FULL,
+	NSS_CLMAP_INTERFACE_STATS_DROPPED_PBUF_ALLOC_FAILED,
+	NSS_CLMAP_INTERFACE_STATS_DROPPED_LINEAR_FAILED,
+	NSS_CLMAP_INTERFACE_STATS_SHARED_PACKET_CNT,
+	NSS_CLMAP_INTERFACE_STATS_ETHERNET_FRAME_ERROR,
+	NSS_CLMAP_INTERFACE_STATS_MACDB_CREATE_REQUESTS_CNT,
+	NSS_CLMAP_INTERFACE_STATS_MACDB_CREATE_MAC_EXISTS_CNT,
+	NSS_CLMAP_INTERFACE_STATS_MACDB_CREATE_MAC_TABLE_FULL_CNT,
+	NSS_CLMAP_INTERFACE_STATS_MACDB_DESTROY_REQUESTS_CNT,
+	NSS_CLMAP_INTERFACE_STATS_MACDB_DESTROY_MAC_NOT_FOUND_CNT,
+	NSS_CLMAP_INTERFACE_STATS_MACDB_DESTROY_MAC_UNHASHED_CNT,
+	NSS_CLMAP_INTERFACE_STATS_MACDB_FLUSH_REQUESTS_CNT,
+	NSS_CLMAP_INTERFACE_STATS_MAX,
+};
+
+/*
  * Clmap session debug statistics.
  */
 struct nss_clmap_stats {
-	uint64_t stats[NSS_CLMAP_INTERFACE_STATS_MAX];	/* Clmap statistics. */
-	int32_t if_index;				/* Interface index. */
+	uint64_t stats[NSS_CLMAP_INTERFACE_STATS_MAX];
+	int32_t if_index;
 	uint32_t nss_if_num;				/* NSS interface number. */
 	enum nss_clmap_interface_type nss_if_type;	/* NSS interface type. */
 	bool valid;
@@ -33,7 +72,6 @@ struct nss_clmap_stats {
 /*
  * Clmap statistics APIs.
  */
-extern void nss_clmap_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num);
 extern bool nss_clmap_stats_session_register(uint32_t if_num, enum nss_clmap_interface_type if_type, struct net_device *netdev);
 extern void nss_clmap_stats_session_unregister(uint32_t if_num);
 extern void nss_clmap_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_clmap_stats_msg *stats_msg, uint32_t if_num);
--- a/nss_clmap_strings.c
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- **************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- **************************************************************************
- */
-
-#include "nss_stats.h"
-#include "nss_core.h"
-#include "nss_strings.h"
-#include "nss_clmap_strings.h"
-
-/*
- * nss_clmap_strings_stats
- *	Clmap statistics strings for nss tunnel stats
- */
-struct nss_stats_info nss_clmap_strings_stats[NSS_CLMAP_INTERFACE_STATS_MAX] = {
-	{"rx_pkts",					NSS_STATS_TYPE_COMMON},
-	{"rx_bytes",					NSS_STATS_TYPE_COMMON},
-	{"tx_pkts",					NSS_STATS_TYPE_COMMON},
-	{"tx_bytes",					NSS_STATS_TYPE_COMMON},
-	{"rx_queue_0_dropped",				NSS_STATS_TYPE_DROP},
-	{"rx_queue_1_dropped",				NSS_STATS_TYPE_DROP},
-	{"rx_queue_2_dropped",				NSS_STATS_TYPE_DROP},
-	{"rx_queue_3_dropped",				NSS_STATS_TYPE_DROP},
-	{"MAC DB look up failed",			NSS_STATS_TYPE_SPECIAL},
-	{"Invalid packet count",			NSS_STATS_TYPE_SPECIAL},
-	{"Headroom drop",				NSS_STATS_TYPE_SPECIAL},
-	{"Next node queue full drop",			NSS_STATS_TYPE_SPECIAL},
-	{"Pbuf alloc failed drop",			NSS_STATS_TYPE_SPECIAL},
-	{"Linear failed drop",				NSS_STATS_TYPE_SPECIAL},
-	{"Shared packet count",				NSS_STATS_TYPE_SPECIAL},
-	{"Ethernet frame error",			NSS_STATS_TYPE_SPECIAL},
-	{"Macdb create requests count",			NSS_STATS_TYPE_SPECIAL},
-	{"Macdb create failures MAC exists count",	NSS_STATS_TYPE_SPECIAL},
-	{"Macdb create failures MAC table full count",	NSS_STATS_TYPE_SPECIAL},
-	{"Macdb destroy requests count",		NSS_STATS_TYPE_SPECIAL},
-	{"Macdb destroy failures MAC not found count",	NSS_STATS_TYPE_SPECIAL},
-	{"Macdb destroy failures MAC unhashed count",	NSS_STATS_TYPE_SPECIAL},
-	{"Macdb flush requests count",			NSS_STATS_TYPE_SPECIAL}
-};
-
-/*
- * nss_clmap_strings_read()
- *	Read clmap statistics names
- */
-static ssize_t nss_clmap_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_clmap_strings_stats, NSS_CLMAP_INTERFACE_STATS_MAX);
-}
-
-/*
- * nss_clmap_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(clmap);
-
-/*
- * nss_clmap_strings_dentry_create()
- *	Create clmap statistics strings debug entry.
- */
-void nss_clmap_strings_dentry_create(void)
-{
-	nss_strings_create_dentry("clmap", &nss_clmap_strings_ops);
-}
--- a/nss_clmap_strings.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- ***************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ***************************************************************************
- */
-
-#ifndef __NSS_CLMAP_STRINGS_H
-#define __NSS_CLMAP_STRINGS_H
-
-#include "nss_clmap_stats.h"
-
-extern struct nss_stats_info nss_clmap_strings_stats[NSS_CLMAP_INTERFACE_STATS_MAX];
-extern void nss_clmap_strings_dentry_create(void);
-
-#endif /* __NSS_CLMAP_STRINGS_H */
--- a/nss_cmn.c
+++ b/nss_cmn.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -197,7 +197,8 @@ bool nss_cmn_interface_is_redirect(struc
 {
 	enum nss_dynamic_interface_type type = nss_dynamic_interface_get_type(nss_ctx, interface_num);
 
-	return type == NSS_DYNAMIC_INTERFACE_TYPE_GENERIC_REDIR_N2H
+	return type == NSS_DYNAMIC_INTERFACE_TYPE_WIFI
+		|| type == NSS_DYNAMIC_INTERFACE_TYPE_GENERIC_REDIR_N2H
 		|| type == NSS_DYNAMIC_INTERFACE_TYPE_GENERIC_REDIR_H2N
 		|| type == NSS_DYNAMIC_INTERFACE_TYPE_VIRTIF_DEPRECATED;
 }
--- a/nss_core.c
+++ b/nss_core.c
@@ -1,12 +1,9 @@
 /*
  **************************************************************************
- * Copyright (c) 2013-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
- *
+ * Copyright (c) 2013-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
- *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -37,13 +34,7 @@
 #endif
 #include <linux/etherdevice.h>
 #include "nss_tx_rx_common.h"
-
-#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 #include "nss_data_plane.h"
-#endif
-#ifdef NSS_DATA_PLANE_LITE_SUPPORT
-#include "nss_data_plane_lite.h"
-#endif
 
 #define NSS_CORE_JUMBO_LINEAR_BUF_SIZE 128
 
@@ -61,7 +52,9 @@
 (((LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(3, 11, 0)))) || \
 (((LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(3, 19, 0)))) || \
 (((LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0)))) || \
-(((LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(5, 5, 0))))))
+(((LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(5, 5, 0)))) || \
+(((LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0)))) || \
+(((LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(5, 16, 0))))))
 #error "Check skb recycle code in this file to match Linux version"
 #endif
 
@@ -85,10 +78,6 @@ uint16_t pn_qlimits[NSS_MAX_NUM_PRI] = {
 module_param_array(pn_qlimits, short, NULL, 0);
 MODULE_PARM_DESC(pn_qlimits, "Queue limit per queue");
 
-static int qos_mem_size = 0;
-module_param(qos_mem_size, int, S_IRUGO);
-MODULE_PARM_DESC(qos_mem_size, "QoS memory size");
-
 /*
  * Atomic variables to control jumbo_mru & paged_mode
  */
@@ -96,24 +85,6 @@ static atomic_t jumbo_mru;
 static atomic_t paged_mode;
 
 /*
- * nss_core_update_qos_mem_size()
- *	Update the memory size for QoS
- */
-void nss_core_update_qos_mem_size(int size)
-{
-	qos_mem_size = size;
-}
-
-/*
- * nss_core_get_qos_mem_size()
- *	Get the memeory size for QoS
- */
-int nss_core_get_qos_mem_size(void)
-{
-	return qos_mem_size;
-}
-
-/*
  * nss_core_update_max_ipv4_conn()
  *	Update the maximum number of configured IPv4 connections
  */
@@ -221,12 +192,12 @@ uint32_t nss_core_register_msg_handler(s
 	/*
 	 * Check if already registered
 	 */
-	if (nss_ctx->nss_rx_interface_handlers[interface].msg_cb) {
+	if (nss_ctx->nss_rx_interface_handlers[nss_ctx->id][interface].msg_cb) {
 		nss_warning("Error - Duplicate Interface CB Registered for interface %d\n", interface);
 		return NSS_CORE_STATUS_FAILURE;
 	}
 
-	nss_ctx->nss_rx_interface_handlers[interface].msg_cb = msg_cb;
+	nss_ctx->nss_rx_interface_handlers[nss_ctx->id][interface].msg_cb = msg_cb;
 
 	return NSS_CORE_STATUS_SUCCESS;
 }
@@ -245,7 +216,7 @@ uint32_t nss_core_unregister_msg_handler
 		return NSS_CORE_STATUS_FAILURE;
 	}
 
-	nss_ctx->nss_rx_interface_handlers[interface].msg_cb = NULL;
+	nss_ctx->nss_rx_interface_handlers[nss_ctx->id][interface].msg_cb = NULL;
 
 	return NSS_CORE_STATUS_SUCCESS;
 }
@@ -270,13 +241,13 @@ uint32_t nss_core_register_handler(struc
 	/*
 	 * Check if already registered
 	 */
-	if (nss_ctx->nss_rx_interface_handlers[interface].cb != NULL) {
+	if (nss_ctx->nss_rx_interface_handlers[nss_ctx->id][interface].cb != NULL) {
 		nss_warning("Error - Duplicate Interface CB Registered for interface %d\n", interface);
 		return NSS_CORE_STATUS_FAILURE;
 	}
 
-	nss_ctx->nss_rx_interface_handlers[interface].cb = cb;
-	nss_ctx->nss_rx_interface_handlers[interface].app_data = app_data;
+	nss_ctx->nss_rx_interface_handlers[nss_ctx->id][interface].cb = cb;
+	nss_ctx->nss_rx_interface_handlers[nss_ctx->id][interface].app_data = app_data;
 
 	return NSS_CORE_STATUS_SUCCESS;
 }
@@ -295,8 +266,8 @@ uint32_t nss_core_unregister_handler(str
 		return NSS_CORE_STATUS_FAILURE;
 	}
 
-	nss_ctx->nss_rx_interface_handlers[interface].cb = NULL;
-	nss_ctx->nss_rx_interface_handlers[interface].app_data = NULL;
+	nss_ctx->nss_rx_interface_handlers[nss_ctx->id][interface].cb = NULL;
+	nss_ctx->nss_rx_interface_handlers[nss_ctx->id][interface].app_data = NULL;
 
 	return NSS_CORE_STATUS_SUCCESS;
 }
@@ -325,17 +296,6 @@ void nss_core_set_subsys_dp_type(struct
 }
 
 /*
- * nss_core_is_mq_enabled()
- *	Get multi-queue status.
- *
- * Returns 'true' if multi-queue is enabled otherwise returns 'false'.
- */
-bool nss_core_is_mq_enabled(void)
-{
-	return pn_mq_en;
-}
-
-/*
  * nss_core_register_subsys_dp()
  *	Registers a netdevice and associated information at a given interface.
  *
@@ -445,8 +405,8 @@ void nss_core_handle_nss_status_pkt(stru
 		return;
 	}
 
-	cb = nss_ctx->nss_rx_interface_handlers[nss_if].cb;
-	app_data = nss_ctx->nss_rx_interface_handlers[nss_if].app_data;
+	cb = nss_ctx->nss_rx_interface_handlers[nss_ctx->id][nss_if].cb;
+	app_data = nss_ctx->nss_rx_interface_handlers[nss_ctx->id][nss_if].app_data;
 
 	if (!cb) {
 		nss_warning("%px: Callback not registered for interface %d", nss_ctx, nss_if);
@@ -964,6 +924,7 @@ static inline void nss_core_handle_buffe
 	dev_put(ndev);
 }
 
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,0))
 /*
  * nss_core_handle_ext_buffer_pkt()
  *	Handle Extended data plane packet received on physical or virtual interface.
@@ -1008,6 +969,7 @@ static inline void nss_core_handle_ext_b
 		dev_kfree_skb_any(nbuf);
 	}
 }
+#endif
 
 /*
  * nss_core_rx_pbuf()
@@ -1024,7 +986,9 @@ static inline void nss_core_rx_pbuf(stru
 	NSS_PKT_STATS_DEC(&nss_ctx->nss_top->stats_drv[NSS_DRV_STATS_NSS_SKB_COUNT]);
 
 	if (interface_num >= NSS_MAX_NET_INTERFACES) {
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,0))
 		NSS_PKT_STATS_INC(&nss_ctx->nss_top->stats_drv[NSS_DRV_STATS_RX_INVALID_INTERFACE]);
+#endif
 		nss_warning("%px: Invalid interface_num: %d", nss_ctx, interface_num);
 		dev_kfree_skb_any(nbuf);
 		return;
@@ -1034,7 +998,9 @@ static inline void nss_core_rx_pbuf(stru
 	 * Check if core_id value is valid.
 	 */
 	if (core_id > nss_top_main.num_nss) {
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,0))
 		NSS_PKT_STATS_INC(&nss_ctx->nss_top->stats_drv[NSS_DRV_STATS_RX_INVALID_CORE_ID]);
+#endif
 		nss_warning("%px: Invalid core id: %d", nss_ctx, core_id);
 		dev_kfree_skb_any(nbuf);
 		return;
@@ -1066,9 +1032,11 @@ static inline void nss_core_rx_pbuf(stru
 		nss_core_handle_bounced_pkt(nss_ctx, reg, nbuf);
 		break;
 
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,0))
 	case N2H_BUFFER_PACKET_EXT:
 		nss_core_handle_ext_buffer_pkt(nss_ctx, interface_num, nbuf, napi, desc->bit_flags);
 		break;
+#endif
 
 	case N2H_BUFFER_STATUS:
 		NSS_PKT_STATS_INC(&nss_ctx->nss_top->stats_drv[NSS_DRV_STATS_RX_STATUS]);
@@ -1100,7 +1068,9 @@ static inline void nss_core_rx_pbuf(stru
 		break;
 
 	default:
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,0))
 		NSS_PKT_STATS_INC(&nss_ctx->nss_top->stats_drv[NSS_DRV_STATS_RX_INVALID_BUFFER_TYPE]);
+#endif
 		nss_warning("%px: Invalid buffer type %d received from NSS", nss_ctx, buffer_type);
 		dev_kfree_skb_any(nbuf);
 	}
@@ -1116,7 +1086,7 @@ static inline void nss_core_set_skb_clas
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 		nbuf->tc_verd = SET_TC_NCLS_NSS(nbuf->tc_verd);
 #else
-		skb_set_tc_classify_offload(nbuf);
+		skb_skip_tc_classify(nbuf);
 #endif
 #endif
 }
@@ -1658,7 +1628,7 @@ static int32_t nss_core_handle_cause_que
 		 *
 		 */
 		if (unlikely((buffer_type == N2H_BUFFER_CRYPTO_RESP))) {
-			dma_unmap_single(NULL, (desc->buffer + desc->payload_offs), desc->payload_len, DMA_FROM_DEVICE);
+			dma_unmap_single(nss_ctx->dev, (desc->buffer + desc->payload_offs), desc->payload_len, DMA_FROM_DEVICE);
 			goto consume;
 		}
 
@@ -1734,7 +1704,6 @@ static void nss_core_init_nss(struct nss
 {
 	struct nss_top_instance *nss_top;
 	int ret;
-	int i;
 
 	NSS_CORE_DMA_CACHE_MAINT((void *)if_map, sizeof(*if_map), DMA_FROM_DEVICE);
 	NSS_CORE_DSB();
@@ -1750,9 +1719,6 @@ static void nss_core_init_nss(struct nss
 #ifdef NSS_DRV_C2C_ENABLE
 	nss_ctx->c2c_start = nss_ctx->meminfo_ctx.c2c_start_dma;
 #endif
-	for (i = 0; i < NSS_H2N_DESC_RING_NUM; i++) {
-		nss_ctx->h2n_desc_rings[i].nss_index_local = 0;
-	}
 
 	nss_top = nss_ctx->nss_top;
 	spin_lock_bh(&nss_top->lock);
@@ -1763,12 +1729,6 @@ static void nss_core_init_nss(struct nss
 		ret = nss_n2h_update_queue_config_async(nss_ctx, pn_mq_en, pn_qlimits);
 		if (ret != NSS_TX_SUCCESS) {
 			nss_warning("%px: Failed to send pnode queue config to core 1\n", nss_ctx);
-			return;
-		}
-
-		ret = nss_project_pri_mq_map_configure(nss_ctx);
-		if (ret != NSS_TX_SUCCESS) {
-			nss_warning("%px: Failed to send pnode priority to multi-queue config to core 1\n", nss_ctx);
 		}
 		return;
 	}
@@ -1776,21 +1736,20 @@ static void nss_core_init_nss(struct nss
 	/*
 	 * If nss core0 is up, then we are ready to hook to nss-gmac
 	 */
-#if defined(NSS_DATA_PLANE_GENERIC_SUPPORT) || defined(NSS_DATA_PLANE_LITE_SUPPORT)
-#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 	if (nss_data_plane_schedule_registration()) {
+
 		/*
 		 * Configure the maximum number of IPv4/IPv6
 		 * connections supported by the accelerator.
 		 */
-#ifdef NSS_DRV_IPV4_ENABLE
 		nss_ipv4_conn_cfg = max_ipv4_conn;
-		nss_ipv4_update_conn_count(max_ipv4_conn);
-#endif
 
 #ifdef NSS_DRV_IPV6_ENABLE
 		nss_ipv6_conn_cfg = max_ipv6_conn;
+		nss_ipv4_update_conn_count(max_ipv4_conn);
 		nss_ipv6_update_conn_count(max_ipv6_conn);
+#else
+		nss_ipv4_update_conn_count(max_ipv4_conn);
 #endif
 
 #ifdef NSS_MEM_PROFILE_LOW
@@ -1804,25 +1763,11 @@ static void nss_core_init_nss(struct nss
 			nss_warning("%px: Failed to update empty buffer pool config\n", nss_ctx);
 		}
 #endif
-
-#ifdef NSS_DRV_SHAPER_ENABLE
-		ret = nss_n2h_cfg_qos_mem_size(nss_ctx, qos_mem_size);
-		if (ret != NSS_TX_SUCCESS) {
-			nss_warning("%px: Failed to update QoS memory pool config\n", nss_ctx);
-		}
-#endif
-#endif /* NSS_DATA_PLANE_GENERIC_SUPPORT */
-
-#ifdef NSS_DATA_PLANE_LITE_SUPPORT
-	if (nss_data_plane_lite_schedule_registration()) {
-		nss_data_plane_lite_register(nss_ctx);
-#endif
 	} else {
 		spin_lock_bh(&nss_top->lock);
 		nss_ctx->state = NSS_CORE_STATE_UNINITIALIZED;
 		spin_unlock_bh(&nss_top->lock);
 	}
-#endif /* NSS_DATA_PLANE_GENERIC_SUPPORT || NSS_DATA_PLANE_LITE_SUPPORT */
 }
 
 /*
@@ -2281,15 +2226,6 @@ static void nss_core_handle_cause_nonque
 #endif
 	}
 
-#if defined(NSS_DRV_EDMA_LITE_ENABLE)
-		/*
-		 * check if point offload it enabled; if yes then send message
-		 */
-		if (nss_edma_lite_enabled(nss_ctx) && !nss_edma_lite_is_configured()) {
-			nss_edma_lite_msg_cfg_map(nss_ctx);
-		}
-#endif
-
 	/*
 	 * TODO: find better mechanism to handle empty buffers
 	 */
@@ -2658,7 +2594,11 @@ static inline bool nss_core_skb_can_reus
 	if (unlikely(irqs_disabled()))
 		return false;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 12, 0))
+	if (unlikely(skb_shinfo(nbuf)->flags & SKBFL_ZEROCOPY_ENABLE))
+#else
 	if (unlikely(skb_shinfo(nbuf)->tx_flags & SKBTX_DEV_ZEROCOPY))
+#endif
 		return false;
 
 	if (unlikely(skb_is_nonlinear(nbuf)))
@@ -3046,7 +2986,7 @@ static inline int32_t nss_core_send_buff
  */
 void nss_core_init_handlers(struct nss_ctx_instance *nss_ctx)
 {
-	struct nss_rx_cb_list *cb_list = nss_ctx->nss_rx_interface_handlers;
+	struct nss_rx_cb_list *cb_list = nss_ctx->nss_rx_interface_handlers[nss_ctx->id];
 	memset(cb_list, 0, sizeof(*cb_list) * NSS_MAX_NET_INTERFACES);
 }
 
@@ -3100,52 +3040,48 @@ int32_t nss_core_send_buffer(struct nss_
 	 * Take a lock for queue
 	 */
 	spin_lock_bh(&h2n_desc_ring->lock);
-	nss_index = h2n_desc_ring->nss_index_local;
-	hlos_index = h2n_desc_ring->hlos_index;
-	count = ((nss_index - hlos_index - 1) + size) & (mask);
 
 	/*
-	 * If local index shows that there is not enough space in the ring,
-	 * Read the actual index from the consumer's generation (NSS-FW).
+	 * We need to work out if there's sufficent space in our transmit descriptor
+	 * ring to place all the segments of a nbuf.
 	 */
+	NSS_CORE_DMA_CACHE_MAINT((void *)&if_map->h2n_nss_index[qid], sizeof(uint32_t), DMA_FROM_DEVICE);
+	NSS_CORE_DSB();
+	nss_index = if_map->h2n_nss_index[qid];
+
+	hlos_index = h2n_desc_ring->hlos_index;
+
+	count = ((nss_index - hlos_index - 1) + size) & (mask);
+
 	if (unlikely(count < (segments + 1))) {
 		/*
-		 * We need to work out if there's sufficent space in our transmit descriptor
-		 * ring to place all the segments of a nbuf.
-		 */
-		NSS_CORE_DMA_CACHE_MAINT((void *)&if_map->h2n_nss_index[qid], sizeof(uint32_t), DMA_FROM_DEVICE);
-		NSS_CORE_DSB();
-		nss_index = if_map->h2n_nss_index[qid];
-		h2n_desc_ring->nss_index_local = nss_index;
-		count = ((nss_index - hlos_index - 1) + size) & (mask);
-		if (unlikely(count < (segments + 1))) {
-			/*
-			 * NOTE: tx_q_full_cnt and TX_STOPPED flags will be used
-			 *	when we will add support for DESC Q congestion management
-			 *	in future
-			 */
-			h2n_desc_ring->tx_q_full_cnt++;
-			h2n_desc_ring->flags |= NSS_H2N_DESC_RING_FLAGS_TX_STOPPED;
-			spin_unlock_bh(&h2n_desc_ring->lock);
-			nss_warning("%px: Data/Command Queue full reached", nss_ctx);
+		 * NOTE: tx_q_full_cnt and TX_STOPPED flags will be used
+		 *	when we will add support for DESC Q congestion management
+		 *	in future
+		 */
+		h2n_desc_ring->tx_q_full_cnt++;
+		h2n_desc_ring->flags |= NSS_H2N_DESC_RING_FLAGS_TX_STOPPED;
+		spin_unlock_bh(&h2n_desc_ring->lock);
+		nss_warning("%px: Data/Command Queue full reached", nss_ctx);
 
 #if (NSS_PKT_STATS_ENABLED == 1)
-			if (nss_ctx->id == NSS_CORE_0) {
-				NSS_PKT_STATS_INC(&nss_ctx->nss_top->stats_drv[NSS_DRV_STATS_TX_QUEUE_FULL_0]);
-			} else if (nss_ctx->id == NSS_CORE_1) {
-				NSS_PKT_STATS_INC(&nss_ctx->nss_top->stats_drv[NSS_DRV_STATS_TX_QUEUE_FULL_1]);
-			} else {
-				nss_warning("%px: Invalid nss core: %d\n", nss_ctx, nss_ctx->id);
-			}
+		if (nss_ctx->id == NSS_CORE_0) {
+			NSS_PKT_STATS_INC(&nss_ctx->nss_top->stats_drv[NSS_DRV_STATS_TX_QUEUE_FULL_0]);
+		} else if (nss_ctx->id == NSS_CORE_1) {
+			NSS_PKT_STATS_INC(&nss_ctx->nss_top->stats_drv[NSS_DRV_STATS_TX_QUEUE_FULL_1]);
+		} else {
+			nss_warning("%px: Invalid nss core: %d\n", nss_ctx, nss_ctx->id);
+		}
 #endif
-			/*
-			 * Enable de-congestion interrupt from NSS
-			 */
-			nss_hal_enable_interrupt(nss_ctx, nss_ctx->int_ctx[0].shift_factor, NSS_N2H_INTR_TX_UNBLOCKED);
 
-			return NSS_CORE_STATUS_FAILURE_QUEUE;
-		}
+		/*
+		 * Enable de-congestion interrupt from NSS
+		 */
+		nss_hal_enable_interrupt(nss_ctx, nss_ctx->int_ctx[0].shift_factor, NSS_N2H_INTR_TX_UNBLOCKED);
+
+		return NSS_CORE_STATUS_FAILURE_QUEUE;
 	}
+
 	desc = &desc_ring[hlos_index];
 
 	/*
--- a/nss_core.h
+++ b/nss_core.h
@@ -1,12 +1,9 @@
 /*
  **************************************************************************
- * Copyright (c) 2013-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
- *
+ * Copyright (c) 2013-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
- *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -41,10 +38,8 @@
 #include "nss_phys_if.h"
 #include "nss_hlos_if.h"
 #include "nss_oam.h"
-#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 #include "nss_data_plane.h"
 #include "nss_gmac_stats.h"
-#endif
 #include "nss_meminfo.h"
 #include "nss_stats.h"
 
@@ -191,7 +186,7 @@ static inline void nss_core_dma_cache_ma
 /*
  * NSS maximum IRQ per interrupt instance/core
  */
-#if defined(NSS_HAL_IPQ807x_SUPPORT) || defined(NSS_HAL_IPQ60XX_SUPPORT) || defined(NSS_HAL_IPQ95XX_SUPPORT)
+#if defined(NSS_HAL_IPQ807x_SUPPORT) || defined(NSS_HAL_IPQ60XX_SUPPORT)
 #define NSS_MAX_IRQ_PER_INSTANCE 6
 #define NSS_MAX_IRQ_PER_CORE 10	/* must match with NSS_HAL_N2H_INTR_PURPOSE_MAX */
 #elif defined(NSS_HAL_IPQ50XX_SUPPORT)
@@ -238,7 +233,6 @@ static inline void nss_core_dma_cache_ma
  *
  */
 #define NSS_FREQ_SCALE_NA	0xFAADFAAD	/* Frequency scale not supported */
-#define NSS_FREQ_NA		0x0		/* Instructions Per ms Min */
 
 #define NSS_FREQ_110		110000000	/* Frequency in hz */
 #define NSS_FREQ_110_MIN	0x03000		/* Instructions Per ms Min */
@@ -282,14 +276,6 @@ static inline void nss_core_dma_cache_ma
 #define NSS_FREQ_800_MIN	0x07000		/* Instructions Per ms Min */
 #define NSS_FREQ_800_MAX	0x25000		/* Instructions Per ms Max */
 
-#define NSS_FREQ_850		850000000	/* Frequency in hz */
-#define NSS_FREQ_850_MIN	0x07000		/* Instructions Per ms Min */
-#define NSS_FREQ_850_MAX	0x0c000		/* Instructions Per ms Max */
-
-#define NSS_FREQ_1000		1000000000	/* Frequency in hz */
-#define NSS_FREQ_1000_MIN	0x0c000		/* Instructions Per ms Min */
-#define NSS_FREQ_1000_MAX	0x25000		/* Instructions Per ms Max */
-
 #define NSS_FREQ_1497		1497600000	/* Frequency in hz */
 #if defined(NSS_HAL_IPQ60XX_SUPPORT)
 #define NSS_FREQ_1497_MIN	0x18000		/* Instructions Per ms Min */
@@ -394,7 +380,6 @@ struct hlos_n2h_desc_ring {
 struct hlos_h2n_desc_rings {
 	struct h2n_desc_if_instance desc_ring;	/* Descriptor ring */
 	uint32_t hlos_index;
-	uint32_t nss_index_local;		/* Index number for the next descriptor (NSS owned) */
 	spinlock_t lock;			/* Lock to save from simultaneous access */
 	uint32_t flags;				/* Flags */
 	uint64_t tx_q_full_cnt;			/* Descriptor queue full count */
@@ -492,9 +477,6 @@ struct nss_ctx_instance {
 					/* Service code callbacks */
 	void *service_code_ctx[NSS_MAX_SERVICE_CODE];
 					/* Service code callback contexts */
-	nss_edma_lite_msg_callback_t edma_lite_callback;
-					/* EDMA lite callback */
-	void *edma_lite_ctx;			/* EDMA lite context */
 	spinlock_t decongest_cb_lock;	/* Lock to protect queue decongestion cb table */
 	uint16_t phys_if_mtu[NSS_MAX_PHYSICAL_INTERFACES];
 					/* Current MTU value of physical interface */
@@ -504,7 +486,7 @@ struct nss_ctx_instance {
 					/* Worker thread statistics */
 	struct nss_unaligned_stats unaligned_stats;
 					/* Unaligned emulation performance statistics */
-	struct nss_rx_cb_list nss_rx_interface_handlers[NSS_MAX_NET_INTERFACES];
+	struct nss_rx_cb_list nss_rx_interface_handlers[NSS_MAX_CORES][NSS_MAX_NET_INTERFACES];
 					/* NSS interface callback handlers */
 	struct nss_subsystem_dataplane_register subsys_dp_register[NSS_MAX_NET_INTERFACES];
 					/* Subsystem registration data */
@@ -577,9 +559,6 @@ struct nss_top_instance {
 	uint8_t mirror_handler_id;
 	uint8_t wmdb_handler_id;
 	uint8_t dma_handler_id;
-	uint8_t udp_st_handler_id;
-	uint8_t edma_lite_handler_id[NSS_MAX_CORES];
-	uint8_t trustsec_rx_handler_id;
 
 	/*
 	 * Data/Message callbacks for various interfaces
@@ -674,10 +653,8 @@ struct nss_top_instance {
 	 */
 	atomic64_t stats_drv[NSS_DRV_STATS_MAX];
 					/* Hlos driver statistics */
-#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 	uint64_t stats_gmac[NSS_MAX_PHYSICAL_INTERFACES][NSS_GMAC_STATS_MAX];
 					/* GMAC statistics */
-#endif
 	uint64_t stats_node[NSS_MAX_NET_INTERFACES][NSS_STATS_NODE_MAX];
 					/* IPv4 statistics per interface */
 	bool nss_hal_common_init_done;
@@ -690,10 +667,8 @@ struct nss_top_instance {
 	 */
 	uint64_t last_rx_jiffies;	/* Time of the last RX message from the NA in jiffies */
 	struct nss_hal_ops *hal_ops;	/* nss_hal ops for this target platform */
-#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 	struct nss_data_plane_ops *data_plane_ops;
 					/* nss_data_plane ops for this target platform */
-#endif
 };
 
 #if (NSS_PKT_STATS_ENABLED == 1)
@@ -919,12 +894,6 @@ struct nss_platform_data {
 				/* Does this core handle TLS Tunnel ? */
 	enum nss_feature_enabled mirror_enabled;
 				/* Does this core handle mirror? */
-	enum nss_feature_enabled udp_st_enabled;
-				/* Does this core handle udp st? */
-	enum nss_feature_enabled edma_lite_enabled;
-				/* Does this core handle EDMA lite? */
-	enum nss_feature_enabled trustsec_enabled;
-				/* Does this core handle TrustSec? */
 };
 #endif
 
@@ -975,8 +944,6 @@ extern uint32_t nss_core_unregister_hand
 extern void nss_core_init_handlers(struct nss_ctx_instance *nss_ctx);
 void nss_core_update_max_ipv4_conn(int conn);
 void nss_core_update_max_ipv6_conn(int conn);
-void nss_core_update_qos_mem_size(int size);
-int nss_core_get_qos_mem_size(void);
 extern void nss_core_register_subsys_dp(struct nss_ctx_instance *nss_ctx, uint32_t if_num,
 					nss_phys_if_rx_callback_t cb,
 					nss_phys_if_rx_ext_data_callback_t ext_cb,
@@ -984,11 +951,10 @@ extern void nss_core_register_subsys_dp(
 					uint32_t features);
 extern void nss_core_unregister_subsys_dp(struct nss_ctx_instance *nss_ctx, uint32_t if_num);
 void nss_core_set_subsys_dp_type(struct nss_ctx_instance *nss_ctx, struct net_device *ndev, uint32_t if_num, uint32_t type);
-extern bool nss_core_is_mq_enabled(void);
 
 static inline nss_if_rx_msg_callback_t nss_core_get_msg_handler(struct nss_ctx_instance *nss_ctx, uint32_t interface)
 {
-	return nss_ctx->nss_rx_interface_handlers[interface].msg_cb;
+	return nss_ctx->nss_rx_interface_handlers[nss_ctx->id][interface].msg_cb;
 }
 
 static inline uint32_t nss_core_get_max_buf_size(struct nss_ctx_instance *nss_ctx)
@@ -1056,6 +1022,5 @@ extern void nss_ppe_free(void);
  */
 extern nss_tx_status_t nss_n2h_cfg_empty_pool_size(struct nss_ctx_instance *nss_ctx, uint32_t pool_sz);
 extern nss_tx_status_t nss_n2h_paged_buf_pool_init(struct nss_ctx_instance *nss_ctx);
-extern nss_tx_status_t nss_n2h_cfg_qos_mem_size(struct nss_ctx_instance *nss_ctx, uint32_t pool_sz);
 
 #endif /* __NSS_CORE_H */
--- a/nss_coredump.c
+++ b/nss_coredump.c
@@ -25,7 +25,11 @@
 #include "nss_hal.h"
 #include "nss_log.h"
 #include <linux/kernel.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 14, 0))
 #include <linux/notifier.h>	/* for panic_notifier_list */
+#else
+#include <linux/panic_notifier.h>
+#endif
 #include <linux/jiffies.h>	/* for time */
 #include "nss_tx_rx_common.h"
 
--- a/nss_crypto_cmn.c
+++ b/nss_crypto_cmn.c
@@ -21,8 +21,6 @@
 
 #include "nss_tx_rx_common.h"
 #include "nss_crypto_cmn.h"
-#include "nss_crypto_cmn_strings.h"
-#include "nss_crypto_cmn_stats.h"
 #include "nss_crypto_cmn_log.h"
 
 /*
@@ -96,18 +94,6 @@ static void nss_crypto_cmn_msg_handler(s
 	 */
 	nss_crypto_cmn_log_rx_msg(nim);
 
-	switch (nim->cm.type) {
-	case NSS_CRYPTO_CMN_MSG_TYPE_SYNC_NODE_STATS:
-	case NSS_CRYPTO_CMN_MSG_TYPE_SYNC_ENG_STATS:
-	case NSS_CRYPTO_CMN_MSG_TYPE_SYNC_CTX_STATS:
-		/*
-		 * Update driver statistics and send statistics
-		 * notification to the registered modules.
-		 */
-		nss_crypto_cmn_stats_sync(nss_ctx, &nim->msg.stats);
-		nss_crypto_cmn_stats_notify(nss_ctx);
-		break;
-	}
 	/*
 	 * Load, Test & call
 	 */
@@ -226,12 +212,6 @@ nss_tx_status_t nss_crypto_cmn_tx_msg_sy
 	 * further details read Linux/Documentation/memory-barrier.txt
 	 */
 	smp_rmb();
-
-	if (msg->cm.response != NSS_CMN_RESPONSE_ACK) {
-		up(&pvt->sem);
-		return NSS_TX_FAILURE;
-	}
-
 	up(&pvt->sem);
 
 	return NSS_TX_SUCCESS;
@@ -377,9 +357,6 @@ void nss_crypto_cmn_register_handler(voi
 	sema_init(&g_nss_crypto_cmn.sem, 1);
 	init_completion(&g_nss_crypto_cmn.complete);
 	nss_core_register_handler(nss_ctx, NSS_CRYPTO_CMN_INTERFACE, nss_crypto_cmn_msg_handler, NULL);
-
-	nss_crypto_cmn_stats_dentry_create();
-	nss_crypto_cmn_strings_dentry_create();
 }
 
 /*
--- a/nss_crypto_cmn_stats.c
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
- **************************************************************************
- * Copyright (c) 2020, The Linux Foundation. All rights reserved.
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- **************************************************************************
- */
-
-#include "nss_core.h"
-#include "nss_crypto_cmn_stats.h"
-#include "nss_crypto_cmn_strings.h"
-
-/*
- * Declare atomic notifier data structure for statistics.
- */
-ATOMIC_NOTIFIER_HEAD(nss_crypto_cmn_stats_notifier);
-
-/*
- * Spinlock to protect CRYPTO_CMN statistics update/read
- */
-DEFINE_SPINLOCK(nss_crypto_cmn_stats_lock);
-
-/*
- * nss_crypto_cmn_stats
- *	crypto common statistics
- */
-uint64_t nss_crypto_cmn_stats[NSS_CRYPTO_CMN_STATS_MAX];
-
-/*
- * nss_crypto_cmn_stats_read()
- *	Read crypto common statistics
- */
-static ssize_t nss_crypto_cmn_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	int32_t i;
-
-	/*
-	 * Max output lines = #stats +
-	 * few blank lines for banner printing + Number of Extra outputlines
-	 * for future reference to add new stats
-	 */
-	uint32_t max_output_lines = NSS_CRYPTO_CMN_STATS_MAX + NSS_STATS_EXTRA_OUTPUT_LINES;
-	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
-	size_t size_wr = 0;
-	ssize_t bytes_read = 0;
-	uint64_t *stats_shadow;
-
-	char *lbuf = vzalloc(size_al);
-	if (unlikely(!lbuf)) {
-		nss_warning("Could not allocate memory for local statistics buffer");
-		return -ENOMEM;
-	}
-
-	stats_shadow = vzalloc(NSS_CRYPTO_CMN_STATS_MAX * 8);
-	if (unlikely(!stats_shadow)) {
-		nss_warning("Could not allocate memory for local shadow buffer");
-		vfree(lbuf);
-		return -ENOMEM;
-	}
-
-	/*
-	 * crypto common statistics
-	 */
-	spin_lock_bh(&nss_crypto_cmn_stats_lock);
-	for (i = 0; i < NSS_CRYPTO_CMN_STATS_MAX; i++)
-		stats_shadow[i] = nss_crypto_cmn_stats[i];
-
-	spin_unlock_bh(&nss_crypto_cmn_stats_lock);
-	size_wr += nss_stats_banner(lbuf, size_wr, size_al, "crypto_cmn", NSS_STATS_SINGLE_CORE);
-	size_wr += nss_stats_print("crypto_cmn", NULL, NSS_STATS_SINGLE_INSTANCE, nss_crypto_cmn_strings_stats,
-					stats_shadow, NSS_CRYPTO_CMN_STATS_MAX, lbuf, size_wr, size_al);
-
-	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
-	vfree(lbuf);
-	vfree(stats_shadow);
-
-	return bytes_read;
-}
-
-/*
- * nss_crypto_cmn_stats_ops
- */
-NSS_STATS_DECLARE_FILE_OPERATIONS(crypto_cmn);
-
-/*
- * nss_crypto_cmn_stats_dentry_create()
- *	Create crypto common statistics debug entry.
- */
-void nss_crypto_cmn_stats_dentry_create(void)
-{
-	nss_stats_create_dentry("crypto_cmn", &nss_crypto_cmn_stats_ops);
-}
-
-/*
- * nss_crypto_cmn_stats_sync()
- *	Handle the syncing of NSS crypto common statistics.
- */
-void nss_crypto_cmn_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_crypto_cmn_stats *nct)
-{
-	int j;
-
-	spin_lock_bh(&nss_crypto_cmn_stats_lock);
-
-	/*
-	 * Common node stats
-	 */
-	nss_crypto_cmn_stats[NSS_STATS_NODE_RX_PKTS] += nct->nstats.rx_packets;
-	nss_crypto_cmn_stats[NSS_STATS_NODE_RX_BYTES] += nct->nstats.rx_bytes;
-	nss_crypto_cmn_stats[NSS_STATS_NODE_TX_PKTS] += nct->nstats.tx_packets;
-	nss_crypto_cmn_stats[NSS_STATS_NODE_TX_BYTES] += nct->nstats.tx_bytes;
-
-	for (j = 0; j < NSS_MAX_NUM_PRI; j++)
-		nss_crypto_cmn_stats[NSS_STATS_NODE_RX_QUEUE_0_DROPPED + j] += nct->nstats.rx_dropped[j];
-
-	/*
-	 * crypto common statistics
-	 */
-	nss_crypto_cmn_stats[NSS_CRYPTO_CMN_STATS_FAIL_VERSION] += nct->fail_version;
-	nss_crypto_cmn_stats[NSS_CRYPTO_CMN_STATS_FAIL_CTX] += nct->fail_ctx;
-	nss_crypto_cmn_stats[NSS_CRYPTO_CMN_STATS_FAIL_DMA] += nct->fail_dma;
-
-	spin_unlock_bh(&nss_crypto_cmn_stats_lock);
-}
-
-/*
- * nss_crypto_cmn_stats_notify()
- *	Sends notifications to all the registered modules.
- *
- * Leverage NSS-FW statistics timing to update Netlink.
- */
-void nss_crypto_cmn_stats_notify(struct nss_ctx_instance *nss_ctx)
-{
-	struct nss_crypto_cmn_stats_notification crypto_cmn_stats;
-
-	crypto_cmn_stats.core_id = nss_ctx->id;
-	memcpy(crypto_cmn_stats.stats, nss_crypto_cmn_stats, sizeof(crypto_cmn_stats.stats));
-	atomic_notifier_call_chain(&nss_crypto_cmn_stats_notifier, NSS_STATS_EVENT_NOTIFY, &crypto_cmn_stats);
-}
-
-/*
- * nss_crypto_cmn_stats_register_notifier()
- *	Registers statistics notifier.
- */
-int nss_crypto_cmn_stats_register_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_register(&nss_crypto_cmn_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_crypto_cmn_stats_register_notifier);
-
-/*
- * nss_crypto_cmn_stats_unregister_notifier()
- *	Deregisters statistics notifier.
- */
-int nss_crypto_cmn_stats_unregister_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_unregister(&nss_crypto_cmn_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_crypto_cmn_stats_unregister_notifier);
--- a/nss_crypto_cmn_stats.h
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- ******************************************************************************
- * Copyright (c) 2020, The Linux Foundation. All rights reserved.
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- * ****************************************************************************
- */
-
-#ifndef __NSS_CRYPTO_CMN_STATS_H
-#define __NSS_CRYPTO_CMN_STATS_H
-
-#include <nss_cmn.h>
-
-/**
- * nss_crypto_cmn_stats_types
- *	crypto common transmission node statistics
- */
-enum nss_crypto_cmn_stats_types {
-	NSS_CRYPTO_CMN_STATS_FAIL_VERSION = NSS_STATS_NODE_MAX,	/* version mismatch failures */
-	NSS_CRYPTO_CMN_STATS_FAIL_CTX,				/* context related failures */
-	NSS_CRYPTO_CMN_STATS_FAIL_DMA,				/* dma descriptor full */
-	NSS_CRYPTO_CMN_STATS_MAX,				/* Maximum message type */
-};
-
-/**
- * nss_crypto_cmn_stats_notification
- *	crypto common transmission statistics structure
- */
-struct nss_crypto_cmn_stats_notification {
-	uint32_t core_id;				/* core ID */
-	uint64_t stats[NSS_CRYPTO_CMN_STATS_MAX];	/* transmission statistics */
-};
-
-/*
- * crypto common statistics APIs
- */
-extern void nss_crypto_cmn_stats_notify(struct nss_ctx_instance *nss_ctx);
-extern void nss_crypto_cmn_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_crypto_cmn_stats *nct);
-extern void nss_crypto_cmn_stats_dentry_create(void);
-
-/**
- * nss_crypto_cmn_stats_register_notifier
- *	Registers a statistics notifier.
- *
- * @datatypes
- * notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or -2 on failure.
- */
-extern int nss_crypto_cmn_stats_register_notifier(struct notifier_block *nb);
-
-/**
- * nss_crypto_cmn_stats_unregister_notifier
- *	Deregisters a statistics notifier.
- *
- * @datatypes
- * notifier_block
- *
- * @param[in] nb Notifier block.
- *
- * @return
- * 0 on success or -2 on failure.
- */
-extern int nss_crypto_cmn_stats_unregister_notifier(struct notifier_block *nb);
-
-#endif /* __NSS_CRYPTO_CMN_STATS_H */
--- a/nss_crypto_cmn_strings.c
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- **************************************************************************
- * Copyright (c) 2020, The Linux Foundation. All rights reserved.
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- **************************************************************************
- */
-
-#include "nss_stats.h"
-#include "nss_core.h"
-#include "nss_strings.h"
-#include "nss_crypto_cmn_strings.h"
-
-/*
- * nss_crypto_cmn_strings_stats
- *	crypto common statistics strings.
- */
-struct nss_stats_info nss_crypto_cmn_strings_stats[NSS_CRYPTO_CMN_STATS_MAX] = {
-	{"rx_pkts",		NSS_STATS_TYPE_COMMON},
-	{"rx_byts",		NSS_STATS_TYPE_COMMON},
-	{"tx_pkts",		NSS_STATS_TYPE_COMMON},
-	{"tx_byts",		NSS_STATS_TYPE_COMMON},
-	{"rx_queue[0]_drops",	NSS_STATS_TYPE_DROP},
-	{"rx_queue[1]_drops",	NSS_STATS_TYPE_DROP},
-	{"rx_queue[2]_drops",	NSS_STATS_TYPE_DROP},
-	{"rx_queue[3]_drops",	NSS_STATS_TYPE_DROP},
-	{"fail_version",	NSS_STATS_TYPE_SPECIAL},
-	{"fail_ctx",		NSS_STATS_TYPE_SPECIAL},
-	{"fail_dma",		NSS_STATS_TYPE_SPECIAL}
-};
-
-/*
- * nss_crypto_cmn_strings_read()
- *	Read crypto common node statistics names
- */
-static ssize_t nss_crypto_cmn_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_crypto_cmn_strings_stats, NSS_CRYPTO_CMN_STATS_MAX);
-}
-
-/*
- * nss_crypto_cmn_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(crypto_cmn);
-
-/*
- * nss_crypto_cmn_strings_dentry_create()
- *	Create crypto common statistics strings debug entry.
- */
-void nss_crypto_cmn_strings_dentry_create(void)
-{
-	nss_strings_create_dentry("crypto_cmn", &nss_crypto_cmn_strings_ops);
-}
--- a/nss_crypto_cmn_strings.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- **************************************************************************
- * Copyright (c) 2020, The Linux Foundation. All rights reserved.
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- **************************************************************************
- */
-
-#ifndef __NSS_CRYPTO_CMN_STRINGS_H
-#define __NSS_CRYPTO_CMN_STRINGS_H
-
-#include "nss_crypto_cmn_stats.h"
-
-extern struct nss_stats_info nss_crypto_cmn_strings_stats[NSS_CRYPTO_CMN_STATS_MAX];
-extern void nss_crypto_cmn_strings_dentry_create(void);
-
-#endif /* __NSS_CRYPTO_CMN_STRINGS_H */
--- a/nss_data_plane/hal/include/nss_data_plane_hal.h
+++ b/nss_data_plane/hal/include/nss_data_plane_hal.h
@@ -17,22 +17,6 @@
 #include "nss_phys_if.h"
 #include <nss_dp_api_if.h>
 
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0))
-#define NSS_DATA_PLANE_SUPPORTED_FEATURES (NETIF_F_HIGHDMA \
-					| NETIF_F_HW_CSUM \
-					| NETIF_F_RXCSUM \
-					| NETIF_F_SG \
-					| NETIF_F_FRAGLIST \
-					| (NETIF_F_TSO | NETIF_F_TSO6 | NETIF_F_UFO))
-#else
-#define NSS_DATA_PLANE_SUPPORTED_FEATURES (NETIF_F_HIGHDMA \
-					| NETIF_F_HW_CSUM \
-					| NETIF_F_RXCSUM \
-					| NETIF_F_SG \
-					| NETIF_F_FRAGLIST \
-					| (NETIF_F_TSO | NETIF_F_TSO6))
-#endif
-
 /*
  * nss_data_plane_param
  */
@@ -49,6 +33,5 @@ struct nss_data_plane_param {
 void nss_data_plane_hal_add_dp_ops(struct nss_dp_data_plane_ops *dp_ops);
 void nss_data_plane_hal_register(struct nss_ctx_instance *nss_ctx);
 void nss_data_plane_hal_unregister(struct nss_ctx_instance *nss_ctx);
-void nss_data_plane_hal_set_features(struct nss_dp_data_plane_ctx *dpc);
 uint16_t nss_data_plane_hal_get_mtu_sz(uint16_t mtu);
 void nss_data_plane_hal_stats_sync(struct nss_data_plane_param *ndpp, struct nss_phys_if_stats *stats);
--- a/nss_data_plane/hal/nss_ipq60xx.c
+++ b/nss_data_plane/hal/nss_ipq60xx.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -40,12 +40,25 @@ static int nss_data_plane_hal_vsi_unassi
 }
 
 /*
+ * nss_data_plane_hal_get_stats()
+ *	Called by nss-dp to get GMAC stats
+ */
+static void nss_data_plane_hal_get_stats(struct nss_dp_data_plane_ctx *dpc,
+						struct nss_dp_gmac_stats *stats)
+{
+	/*
+	 * EDMA doesn't send extended statistics.
+	 */
+}
+
+/*
  * nss_data_plane_hal_add_dp_ops()
  */
 void nss_data_plane_hal_add_dp_ops(struct nss_dp_data_plane_ops *dp_ops)
 {
 	dp_ops->vsi_assign = nss_data_plane_hal_vsi_assign;
 	dp_ops->vsi_unassign = nss_data_plane_hal_vsi_unassign;
+	dp_ops->get_stats = nss_data_plane_hal_get_stats;
 }
 
 /*
@@ -71,17 +84,6 @@ void nss_data_plane_hal_unregister(struc
 }
 
 /*
- * nss_data_plane_hal_set_features
- */
-void nss_data_plane_hal_set_features(struct nss_dp_data_plane_ctx *dpc)
-{
-	dpc->dev->features |= NSS_DATA_PLANE_SUPPORTED_FEATURES;
-	dpc->dev->hw_features |= NSS_DATA_PLANE_SUPPORTED_FEATURES;
-	dpc->dev->vlan_features |= NSS_DATA_PLANE_SUPPORTED_FEATURES;
-	dpc->dev->wanted_features |= NSS_DATA_PLANE_SUPPORTED_FEATURES;
-}
-
-/*
  * nss_data_plane_hal_stats_sync()
  */
 void nss_data_plane_hal_stats_sync(struct nss_data_plane_param *ndpp,
--- a/nss_data_plane/hal/nss_ipq807x.c
+++ b/nss_data_plane/hal/nss_ipq807x.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -40,12 +40,25 @@ static int nss_data_plane_hal_vsi_unassi
 }
 
 /*
+ * nss_data_plane_hal_get_stats()
+ *	Called by nss-dp to get GMAC stats
+ */
+static void nss_data_plane_hal_get_stats(struct nss_dp_data_plane_ctx *dpc,
+						struct nss_dp_gmac_stats *stats)
+{
+	/*
+	 * EDMA doesn't send extended statistics.
+	 */
+}
+
+/*
  * nss_data_plane_hal_add_dp_ops()
  */
 void nss_data_plane_hal_add_dp_ops(struct nss_dp_data_plane_ops *dp_ops)
 {
 	dp_ops->vsi_assign = nss_data_plane_hal_vsi_assign;
 	dp_ops->vsi_unassign = nss_data_plane_hal_vsi_unassign;
+	dp_ops->get_stats = nss_data_plane_hal_get_stats;
 }
 
 /*
@@ -71,17 +84,6 @@ void nss_data_plane_hal_unregister(struc
 }
 
 /*
- * nss_data_plane_hal_set_features
- */
-void nss_data_plane_hal_set_features(struct nss_dp_data_plane_ctx *dpc)
-{
-	dpc->dev->features |= NSS_DATA_PLANE_SUPPORTED_FEATURES;
-	dpc->dev->hw_features |= NSS_DATA_PLANE_SUPPORTED_FEATURES;
-	dpc->dev->vlan_features |= NSS_DATA_PLANE_SUPPORTED_FEATURES;
-	dpc->dev->wanted_features |= NSS_DATA_PLANE_SUPPORTED_FEATURES;
-}
-
-/*
  * nss_data_plane_hal_stats_sync()
  */
 void nss_data_plane_hal_stats_sync(struct nss_data_plane_param *ndpp,
--- a/nss_data_plane/include/nss_data_plane.h
+++ b/nss_data_plane/include/nss_data_plane.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2017,2020-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2017,2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -25,8 +25,6 @@
 #include <nss_api_if.h>
 #include "nss_phys_if.h"
 
-#define NSS_DATA_PLANE_MAX_PACKET_LEN	65535
-
 /*
  * nss_data_plane_schedule_registration()
  *	Called from nss_init to schedule a work to do data_plane register to data plane host driver
--- a/nss_data_plane/nss_data_plane.c
+++ b/nss_data_plane/nss_data_plane.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -19,6 +19,22 @@
 #include "nss_tx_rx_common.h"
 #include "nss_data_plane_hal.h"
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4, 5, 0))
+#define NSS_DATA_PLANE_SUPPORTED_FEATURES (NETIF_F_HIGHDMA \
+					| NETIF_F_HW_CSUM \
+					| NETIF_F_RXCSUM \
+					| NETIF_F_SG \
+					| NETIF_F_FRAGLIST \
+					| (NETIF_F_TSO | NETIF_F_TSO6 | NETIF_F_UFO))
+#else
+#define NSS_DATA_PLANE_SUPPORTED_FEATURES (NETIF_F_HIGHDMA \
+					| NETIF_F_HW_CSUM \
+					| NETIF_F_RXCSUM \
+					| NETIF_F_SG \
+					| NETIF_F_FRAGLIST \
+					| (NETIF_F_TSO | NETIF_F_TSO6))
+#endif
+
 /*
  * nss_data_plane_param
  */
@@ -101,6 +117,12 @@ static int __nss_data_plane_mac_addr(str
 static int __nss_data_plane_change_mtu(struct nss_dp_data_plane_ctx *dpc, uint32_t mtu)
 {
 	struct nss_data_plane_param *dp = (struct nss_data_plane_param *)dpc;
+
+	if (mtu > NSS_DP_MAX_MTU_SIZE) {
+		nss_warning("%px: MTU exceeds MAX size %d\n", dp, mtu);
+		return NSS_DP_FAILURE;
+	}
+
 	return nss_phys_if_change_mtu(dp->nss_ctx, mtu, dp->if_num);
 }
 
@@ -160,9 +182,8 @@ static netdev_tx_t __nss_data_plane_buf(
 		goto drop;
 	}
 
-	if (skb->len > NSS_DATA_PLANE_MAX_PACKET_LEN) {
-		nss_warning("skb->len ( %u ) > Maximum packet length ( %u ) \n",
-				skb->len, NSS_DATA_PLANE_MAX_PACKET_LEN);
+	if (skb->len > NSS_DP_MAX_PACKET_LEN) {
+		nss_warning("skb->len ( %u ) > Maximum packet length ( %u ) \n", skb->len, NSS_DP_MAX_PACKET_LEN);
 		goto drop;
 	}
 
@@ -207,7 +228,10 @@ drop:
  */
 static void __nss_data_plane_set_features(struct nss_dp_data_plane_ctx *dpc)
 {
-	nss_data_plane_hal_set_features(dpc);
+	dpc->dev->features |= NSS_DATA_PLANE_SUPPORTED_FEATURES;
+	dpc->dev->hw_features |= NSS_DATA_PLANE_SUPPORTED_FEATURES;
+	dpc->dev->vlan_features |= NSS_DATA_PLANE_SUPPORTED_FEATURES;
+	dpc->dev->wanted_features |= NSS_DATA_PLANE_SUPPORTED_FEATURES;
 }
 
 /*
--- a/nss_data_plane/nss_data_plane_common.c
+++ b/nss_data_plane/nss_data_plane_common.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2016,2020-2021 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2016,2020 The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -39,16 +39,9 @@ static void nss_data_plane_work_function
 	 */
 	ret = nss_n2h_update_queue_config_sync(nss_ctx, pn_mq_en, pn_qlimits);
 	if (ret != NSS_TX_SUCCESS) {
-		nss_warning("%px: Failed to send pnode queue config to core 0\n", nss_ctx);
-		goto data_plane_reg;
+		nss_warning("Failed to send pnode queue config to core 0\n");
 	}
 
-	ret = nss_project_pri_mq_map_configure(nss_ctx);
-	if (ret != NSS_TX_SUCCESS) {
-		nss_warning("%px: Failed to send pnode priority to multi-queue config to core 0\n", nss_ctx);
-	}
-
-data_plane_reg:
 	nss_top->data_plane_ops->data_plane_register(nss_ctx);
 }
 
--- a/nss_data_plane/nss_data_plane_gmac.c
+++ b/nss_data_plane/nss_data_plane_gmac.c
@@ -20,7 +20,7 @@
 #include "nss_tx_rx_common.h"
 #include <nss_gmac_api_if.h>
 
-#define NSS_DP_GMAC_SUPPORTED_FEATURES (NETIF_F_HIGHDMA | NETIF_F_HW_CSUM | NETIF_F_RXCSUM | NETIF_F_SG | NETIF_F_FRAGLIST | (NETIF_F_TSO | NETIF_F_TSO6 | NETIF_F_UFO))
+#define NSS_DP_GMAC_SUPPORTED_FEATURES (NETIF_F_HIGHDMA | NETIF_F_HW_CSUM | NETIF_F_RXCSUM | NETIF_F_SG | NETIF_F_FRAGLIST | (NETIF_F_TSO | NETIF_F_TSO6))
 #define NSS_DATA_PLANE_GMAC_MAX_INTERFACES 4
 
 static DEFINE_SPINLOCK(nss_data_plane_gmac_stats_lock);
--- a/nss_dma.c
+++ b/nss_dma.c
@@ -128,7 +128,7 @@ static void nss_dma_msg_handler(struct n
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
 		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
-		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[ncm->interface].app_data;
+		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[nss_ctx->id][ncm->interface].app_data;
 	}
 
 	/*
--- a/nss_dma_stats.h
+++ b/nss_dma_stats.h
@@ -1,6 +1,6 @@
 /*
  ******************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
@@ -21,10 +21,44 @@
 
 #include <nss_cmn.h>
 
+/**
+ * nss_dma_stats_types
+ *	DMA node statistics.
+ */
+enum nss_dma_stats_types {
+	NSS_DMA_STATS_NO_REQ = NSS_STATS_NODE_MAX,	/**< Request descriptor not available. */
+	NSS_DMA_STATS_NO_DESC,				/**< DMA descriptors not available. */
+	NSS_DMA_STATS_NEXTHOP,				/**< Failed to retrive next hop. */
+	NSS_DMA_STATS_FAIL_NEXTHOP_QUEUE,		/**< Failed to queue next hop. */
+	NSS_DMA_STATS_FAIL_LINEAR_SZ,			/**< Failed to get memory for linearization. */
+	NSS_DMA_STATS_FAIL_LINEAR_ALLOC,		/**< Failed to allocate buffer for linearization. */
+	NSS_DMA_STATS_FAIL_LINEAR_NO_SG,		/**< Skip linearization due to non-SG packet. */
+	NSS_DMA_STATS_FAIL_SPLIT_SZ,			/**< Failed to spliting buffer into multiple buffers. */
+	NSS_DMA_STATS_FAIL_SPLIT_ALLOC,			/**< Failed to allocate buffer for split. */
+	NSS_DMA_STATS_FAIL_SYNC_ALLOC,			/**< Failed to allocate buffer for sending statistics. */
+	NSS_DMA_STATS_FAIL_CTX_ACTIVE,			/**< Failed to queue as the node is not active. */
+	NSS_DMA_STATS_FAIL_HW_E0,			/**< Failed to process in HW, error code E0. */
+	NSS_DMA_STATS_FAIL_HW_E1,			/**< Failed to process in HW, error code E1. */
+	NSS_DMA_STATS_FAIL_HW_E2,			/**< Failed to process in HW, error code E2. */
+	NSS_DMA_STATS_FAIL_HW_E3,			/**< Failed to process in HW, error code E3. */
+	NSS_DMA_STATS_FAIL_HW_E4,			/**< Failed to process in HW, error code E4. */
+	NSS_DMA_STATS_FAIL_HW_E5,			/**< Failed to process in HW, error code E5. */
+	NSS_DMA_STATS_FAIL_HW_E6,			/**< Failed to process in HW, error code E6. */
+	NSS_DMA_STATS_FAIL_HW_E7,			/**< Failed to process in HW, error code E7. */
+	NSS_DMA_STATS_FAIL_HW_E8,			/**< Failed to process in HW, error code E8. */
+	NSS_DMA_STATS_FAIL_HW_E9,			/**< Failed to process in HW, error code E9. */
+	NSS_DMA_STATS_FAIL_HW_E10,			/**< Failed to process in HW, error code E10. */
+	NSS_DMA_STATS_FAIL_HW_E11,			/**< Failed to process in HW, error code E11. */
+	NSS_DMA_STATS_FAIL_HW_E12,			/**< Failed to process in HW, error code E12. */
+	NSS_DMA_STATS_FAIL_HW_E13,			/**< Failed to process in HW, error code E13. */
+	NSS_DMA_STATS_FAIL_HW_E14,			/**< Failed to process in HW, error code E14. */
+	NSS_DMA_STATS_FAIL_HW_E15,			/**< Failed to process in HW, error code E15. */
+	NSS_DMA_STATS_MAX,				/**< Maximum message type. */
+};
+
 /*
  * DMA statistics APIs
  */
-extern void nss_dma_stats_notify(struct nss_ctx_instance *nss_ctx);
 extern void nss_dma_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_dma_stats *nds);
 extern void nss_dma_stats_dentry_create(void);
 
--- a/nss_dtls_cmn.c
+++ b/nss_dtls_cmn.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -16,16 +16,15 @@
 
 #include "nss_tx_rx_common.h"
 #include "nss_dtls_cmn_log.h"
-#include "nss_dtls_cmn_stats.h"
-#include "nss_dtls_cmn_strings.h"
 
 #define NSS_DTLS_CMN_TX_TIMEOUT 3000 /* 3 Seconds */
 #define NSS_DTLS_CMN_INTERFACE_MAX_LONG BITS_TO_LONGS(NSS_MAX_NET_INTERFACES)
-
+#define NSS_DTLS_CMN_STATS_MAX_LINES (NSS_STATS_NODE_MAX + 32)
+#define NSS_DTLS_CMN_STATS_SIZE_PER_IF (NSS_STATS_MAX_STR_LENGTH * NSS_DTLS_CMN_STATS_MAX_LINES)
 /*
  * Private data structure.
  */
-static struct nss_dtls_cmn_pvt {
+static struct nss_dtls_cmn_cmn_pvt {
 	struct semaphore sem;
 	struct completion complete;
 	enum nss_dtls_cmn_error resp;
@@ -33,6 +32,91 @@ static struct nss_dtls_cmn_pvt {
 } dtls_cmn_pvt;
 
 /*
+ * nss_dtls_cmn_stats_sync()
+ *	Update dtls_cmn node statistics.
+ */
+static void nss_dtls_cmn_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_cmn_msg *ncm)
+{
+	struct nss_dtls_cmn_msg *ndcm = (struct nss_dtls_cmn_msg *)ncm;
+	struct nss_top_instance *nss_top = nss_ctx->nss_top;
+	struct nss_dtls_cmn_ctx_stats *msg_stats = &ndcm->msg.stats;
+	uint64_t *if_stats;
+
+	spin_lock_bh(&nss_top->stats_lock);
+
+	/*
+	 * Update common node stats,
+	 * Note: DTLS only supports a single queue for RX.
+	 */
+	if_stats = nss_top->stats_node[ncm->interface];
+	if_stats[NSS_STATS_NODE_RX_PKTS] += msg_stats->pkt.rx_packets;
+	if_stats[NSS_STATS_NODE_RX_BYTES] += msg_stats->pkt.rx_bytes;
+	if_stats[NSS_STATS_NODE_RX_QUEUE_0_DROPPED] += msg_stats->pkt.rx_dropped[0];
+
+	if_stats[NSS_STATS_NODE_TX_PKTS] += msg_stats->pkt.tx_packets;
+	if_stats[NSS_STATS_NODE_TX_BYTES] += msg_stats->pkt.tx_bytes;
+
+	spin_unlock_bh(&nss_top->stats_lock);
+}
+
+/*
+ * nss_dtls_cmn_stats_read()
+ *	Read dtls_cmn node statiistics.
+ */
+static ssize_t nss_dtls_cmn_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
+{
+	struct nss_ctx_instance *nss_ctx = nss_dtls_cmn_get_context();
+	enum nss_dynamic_interface_type type;
+	ssize_t bytes_read = 0;
+	size_t len = 0, size;
+	uint32_t if_num;
+	char *buf;
+
+	size = NSS_DTLS_CMN_STATS_SIZE_PER_IF * bitmap_weight(dtls_cmn_pvt.if_map, NSS_MAX_NET_INTERFACES);
+
+	buf = kzalloc(size, GFP_KERNEL);
+	if (!buf) {
+		nss_warning("Could not allocate memory for local statistics buffer");
+		return 0;
+	}
+
+	/*
+	 * Common node stats for each DTLS dynamic interface.
+	 */
+	for_each_set_bit(if_num, dtls_cmn_pvt.if_map, NSS_MAX_NET_INTERFACES) {
+
+		type = nss_dynamic_interface_get_type(nss_ctx, if_num);
+
+		switch (type) {
+		case NSS_DYNAMIC_INTERFACE_TYPE_DTLS_CMN_INNER:
+			len += scnprintf(buf + len, size - len, "\nInner if_num:%03u", if_num);
+			break;
+
+		case NSS_DYNAMIC_INTERFACE_TYPE_DTLS_CMN_OUTER:
+			len += scnprintf(buf + len, size - len, "\nOuter if_num:%03u", if_num);
+			break;
+
+		default:
+			len += scnprintf(buf + len, size - len, "\nUnknown(%d) if_num:%03u", type, if_num);
+			break;
+		}
+
+		len += scnprintf(buf + len, size - len, "\n-------------------\n");
+		len += nss_stats_fill_common_stats(if_num, NSS_STATS_SINGLE_INSTANCE, buf, len, size - len, "dtls_cmn");
+	}
+
+	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, buf, len);
+	kfree(buf);
+
+	return bytes_read;
+}
+
+/*
+ * nss_dtls_cmn_stats_ops.
+ */
+NSS_STATS_DECLARE_FILE_OPERATIONS(dtls_cmn)
+
+/*
  * nss_dtls_cmn_verify_ifnum()
  *	Verify if the interface number is a DTLS interface.
  */
@@ -78,17 +162,15 @@ static void nss_dtls_cmn_handler(struct
 		return;
 	}
 
-	if (ncm->type == NSS_DTLS_CMN_MSG_TYPE_SYNC_STATS) {
+	if (ncm->type == NSS_DTLS_CMN_MSG_TYPE_SYNC_STATS)
 		nss_dtls_cmn_stats_sync(nss_ctx, ncm);
-		nss_dtls_cmn_stats_notify(nss_ctx, ncm->interface);
-	}
 
 	/*
 	 * Update the callback and app_data for NOTIFY messages.
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
 		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
-		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[ncm->interface].app_data;
+		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[nss_ctx->id][ncm->interface].app_data;
 	}
 
 	/*
@@ -139,15 +221,6 @@ static void nss_dtls_cmn_callback(void *
 }
 
 /*
- * nss_dtls_cmn_ifmap_get()
- *	Return DTLS common active interfaces map.
- */
-unsigned long *nss_dtls_cmn_ifmap_get(void)
-{
-	return dtls_cmn_pvt.if_map;
-}
-
-/*
  * nss_dtls_cmn_tx_buf()
  *	Transmit buffer over DTLS interface.
  */
@@ -446,6 +519,5 @@ void nss_dtls_cmn_register_handler(void)
 {
 	sema_init(&dtls_cmn_pvt.sem, 1);
 	init_completion(&dtls_cmn_pvt.complete);
-	nss_dtls_cmn_stats_dentry_create();
-	nss_dtls_cmn_strings_dentry_create();
+	nss_stats_create_dentry("dtls_cmn", &nss_dtls_cmn_stats_ops);
 }
--- a/nss_dtls_cmn_log.c
+++ b/nss_dtls_cmn_log.c
@@ -1,12 +1,9 @@
 /*
  **************************************************************************
  * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
- *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
- *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -35,8 +32,7 @@ static int8_t *nss_dtls_cmn_log_message_
 	"DTLS_CMN Switch DTLS Transform",
 	"DTLS_CMN Deconfigure Context",
 	"DTLS_CMN Synchronize Stats",
-	"DTLS_CMN Node Statistics",
-	"DTLS_CMN Update VP"
+	"DTLS_CMN Node Statistics"
 };
 
 /*
@@ -57,9 +53,7 @@ static int8_t *nss_dtls_cmn_log_error_re
 	"DTLS_CMN Switch Hardware Context Fail",
 	"DTLS_CMN Already Configured",
 	"DTLS_CMN No Memory",
-	"DTLS_CMN Copy Nonce Failure",
-	"DTLS_CMN Update VP Failure",
-	"DTLS_CMN Destroy VP Failure"
+	"DTLS_CMN Copy Nonce Failure"
 };
 
 /*
--- a/nss_dtls_cmn_stats.c
+++ /dev/null
@@ -1,215 +0,0 @@
-/*
- ***************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ***************************************************************************
- */
-
-#include "nss_core.h"
-#include "nss_dtls_cmn.h"
-#include "nss_dtls_cmn_stats.h"
-#include "nss_dtls_cmn_strings.h"
-
-/*
- * Declare atomic notifier data structure for statistics.
- */
-ATOMIC_NOTIFIER_HEAD(nss_dtls_cmn_stats_notifier);
-
-/*
- * Spinlock to protect dtls common statistics update/read
- */
-DEFINE_SPINLOCK(nss_dtls_cmn_stats_lock);
-
-unsigned long *nss_dtls_cmn_ifmap_get(void);
-
-/*
- * nss_dtls_cmn_ctx_stats
- *	dtls common ctx statistics
- */
-uint64_t nss_dtls_cmn_ctx_stats[NSS_MAX_NET_INTERFACES][NSS_DTLS_CMN_CTX_STATS_MAX];
-
-/*
- * nss_dtls_cmn_stats_iface_type()
- *	Return a string for each interface type.
- */
-static const char *nss_dtls_cmn_stats_iface_type(enum nss_dynamic_interface_type type)
-{
-	switch (type) {
-	case NSS_DYNAMIC_INTERFACE_TYPE_DTLS_CMN_INNER:
-		return "dtls_cmn_inner";
-
-	case NSS_DYNAMIC_INTERFACE_TYPE_DTLS_CMN_OUTER:
-		return "dtls_cmn_outer";
-
-	default:
-		return "invalid_interface";
-
-	}
-}
-
-/*
- * nss_dtls_cmn_stats_read()
- *	Read dtls common node statistics.
- */
-static ssize_t nss_dtls_cmn_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	/*
-	 * Max output lines = #stats +
-	 * few blank lines for banner printing + Number of Extra outputlines
-	 * for future reference to add new stats
-	 */
-	uint32_t max_output_lines = NSS_DTLS_CMN_CTX_STATS_MAX + NSS_STATS_EXTRA_OUTPUT_LINES;
-	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
-	struct nss_ctx_instance *nss_ctx = nss_dtls_cmn_get_context();
-	enum nss_dynamic_interface_type type;
-	unsigned long *ifmap;
-	uint64_t *stats_shadow;
-	ssize_t bytes_read = 0;
-	size_t size_wr = 0;
-	uint32_t if_num;
-	int32_t i;
-	int count;
-	char *lbuf;
-
-	ifmap = nss_dtls_cmn_ifmap_get();
-	count = bitmap_weight(ifmap, NSS_MAX_NET_INTERFACES);
-	if (count) {
-		size_al = size_al * count;
-	}
-
-	lbuf = vzalloc(size_al);
-	if (unlikely(!lbuf)) {
-		nss_warning("Could not allocate memory for local statistics buffer");
-		return -ENOMEM;
-	}
-
-	stats_shadow = vzalloc(NSS_DTLS_CMN_CTX_STATS_MAX * 8);
-	if (unlikely(!stats_shadow)) {
-		nss_warning("Could not allocate memory for local shadow buffer");
-		vfree(lbuf);
-		return -ENOMEM;
-	}
-
-	/*
-	 * Common node stats for each DTLS dynamic interface.
-	 */
-	size_wr += nss_stats_banner(lbuf, size_wr, size_al, "dtls_cmn stats", NSS_STATS_SINGLE_CORE);
-	for_each_set_bit(if_num, ifmap, NSS_MAX_NET_INTERFACES) {
-
-		type = nss_dynamic_interface_get_type(nss_ctx, if_num);
-		if ((type != NSS_DYNAMIC_INTERFACE_TYPE_DTLS_CMN_INNER) &&
-			(type != NSS_DYNAMIC_INTERFACE_TYPE_DTLS_CMN_OUTER)) {
-			continue;
-		}
-
-		spin_lock_bh(&nss_dtls_cmn_stats_lock);
-		for (i = 0; i < NSS_DTLS_CMN_CTX_STATS_MAX; i++) {
-			stats_shadow[i] = nss_dtls_cmn_ctx_stats[if_num][i];
-		}
-		spin_unlock_bh(&nss_dtls_cmn_stats_lock);
-
-		size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\n%s if_num:%03u\n",
-					nss_dtls_cmn_stats_iface_type(type), if_num);
-		size_wr += nss_stats_print("dtls_cmn", NULL, NSS_STATS_SINGLE_INSTANCE, nss_dtls_cmn_ctx_stats_str,
-						stats_shadow, NSS_DTLS_CMN_CTX_STATS_MAX, lbuf, size_wr, size_al);
-	}
-
-	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
-	vfree(lbuf);
-	vfree(stats_shadow);
-
-	return bytes_read;
-}
-
-/*
- * nss_dtls_cmn_stats_ops.
- */
-NSS_STATS_DECLARE_FILE_OPERATIONS(dtls_cmn);
-
-/*
- * nss_dtls_cmn_stats_dentry_create()
- *	Create dtls common statistics debug entry.
- */
-void nss_dtls_cmn_stats_dentry_create(void)
-{
-	nss_stats_create_dentry("dtls_cmn", &nss_dtls_cmn_stats_ops);
-}
-
-/*
- * nss_dtls_cmn_stats_sync()
- *	Update dtls common node statistics.
- */
-void nss_dtls_cmn_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_cmn_msg *ncm)
-{
-	struct nss_dtls_cmn_msg *ndcm = (struct nss_dtls_cmn_msg *)ncm;
-	struct nss_dtls_cmn_ctx_stats *ndccs = &ndcm->msg.stats;
-	uint64_t *ctx_stats;
-	uint32_t *msg_stats;
-	uint16_t i = 0;
-
-	spin_lock_bh(&nss_dtls_cmn_stats_lock);
-
-	msg_stats = (uint32_t *)ndccs;
-	ctx_stats = nss_dtls_cmn_ctx_stats[ncm->interface];
-
-	for (i = 0; i < NSS_DTLS_CMN_CTX_STATS_MAX; i++, ctx_stats++, msg_stats++) {
-		*ctx_stats += *msg_stats;
-	}
-
-	spin_unlock_bh(&nss_dtls_cmn_stats_lock);
-}
-
-/*
- * nss_dtls_cmn_stats_notify()
- *	Sends notifications to all the registered modules.
- *
- * Leverage NSS-FW statistics timing to update Netlink.
- */
-void nss_dtls_cmn_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num)
-{
-	struct nss_dtls_cmn_stats_notification *dtls_cmn_stats;
-
-	dtls_cmn_stats = kmalloc(sizeof(struct nss_dtls_cmn_stats_notification), GFP_ATOMIC);
-	if (!dtls_cmn_stats) {
-		nss_warning("Unable to allocate memory for stats notification\n");
-		return;
-	}
-
-	spin_lock_bh(&nss_dtls_cmn_stats_lock);
-	dtls_cmn_stats->core_id = nss_ctx->id;
-	dtls_cmn_stats->if_num = if_num;
-	memcpy(dtls_cmn_stats->stats_ctx, nss_dtls_cmn_ctx_stats[if_num], sizeof(dtls_cmn_stats->stats_ctx));
-	spin_unlock_bh(&nss_dtls_cmn_stats_lock);
-
-	atomic_notifier_call_chain(&nss_dtls_cmn_stats_notifier, NSS_STATS_EVENT_NOTIFY, dtls_cmn_stats);
-	kfree(dtls_cmn_stats);
-}
-
-/*
- * nss_dtls_cmn_stats_unregister_notifier()
- *	Deregisters statistics notifier.
- */
-int nss_dtls_cmn_stats_unregister_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_unregister(&nss_dtls_cmn_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_dtls_cmn_stats_unregister_notifier);
-
-/*
- * nss_dtls_cmn_stats_register_notifier()
- *	Registers statistics notifier.
- */
-int nss_dtls_cmn_stats_register_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_register(&nss_dtls_cmn_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_dtls_cmn_stats_register_notifier);
--- a/nss_dtls_cmn_stats.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- ****************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ****************************************************************************
- */
-
-#ifndef __NSS_DTLS_CMN_STATS_H
-#define __NSS_DTLS_CMN_STATS_H
-
-#include <nss_cmn.h>
-
-extern void nss_dtls_cmn_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num);
-extern void nss_dtls_cmn_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_cmn_msg *ncm);
-extern void nss_dtls_cmn_stats_dentry_create(void);
-
-#endif /* __NSS_DTLS_CMN_STATS_H */
--- a/nss_dtls_cmn_strings.c
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
- ****************************************************************************
- * Copyright (c) 2020, The Linux Foundation. All rights reserved.
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ****************************************************************************
- */
-
-#include "nss_stats.h"
-#include "nss_core.h"
-#include "nss_strings.h"
-#include "nss_dtls_cmn_strings.h"
-
-/*
- * nss_dtls_cmn_ctx_stats_str
- *	 dtls common ctx statistics strings.
- */
-struct nss_stats_info nss_dtls_cmn_ctx_stats_str[NSS_DTLS_CMN_CTX_STATS_MAX] = {
-	{"rx_pkts",			NSS_STATS_TYPE_COMMON},
-	{"rx_byts",			NSS_STATS_TYPE_COMMON},
-	{"tx_pkts",			NSS_STATS_TYPE_COMMON},
-	{"tx_byts",			NSS_STATS_TYPE_COMMON},
-	{"rx_queue[0]_drops",		NSS_STATS_TYPE_DROP},
-	{"rx_queue[1]_drops",		NSS_STATS_TYPE_DROP},
-	{"rx_queue[2]_drops",		NSS_STATS_TYPE_DROP},
-	{"rx_queue[3]_drops",		NSS_STATS_TYPE_DROP},
-	{"rx_single_rec",		NSS_STATS_TYPE_SPECIAL},
-	{"rx_multi_rec",		NSS_STATS_TYPE_SPECIAL},
-	{"fail_crypto_resource",	NSS_STATS_TYPE_DROP},
-	{"fail_crypto_enqueue",		NSS_STATS_TYPE_DROP},
-	{"fail_headroom",		NSS_STATS_TYPE_DROP},
-	{"fail_tailroom",		NSS_STATS_TYPE_DROP},
-	{"fail_ver",			NSS_STATS_TYPE_DROP},
-	{"fail_epoch",			NSS_STATS_TYPE_DROP},
-	{"fail_dtls_record",		NSS_STATS_TYPE_DROP},
-	{"fail_capwap",			NSS_STATS_TYPE_DROP},
-	{"fail_replay",			NSS_STATS_TYPE_DROP},
-	{"fail_replay_dup",		NSS_STATS_TYPE_DROP},
-	{"fail_replay_win",		NSS_STATS_TYPE_DROP},
-	{"fail_queue",			NSS_STATS_TYPE_DROP},
-	{"fail_queue_nexthop",		NSS_STATS_TYPE_DROP},
-	{"fail_pbuf_alloc",		NSS_STATS_TYPE_DROP},
-	{"fail_pbuf_linear",		NSS_STATS_TYPE_DROP},
-	{"fail_pbuf_stats",		NSS_STATS_TYPE_DROP},
-	{"fail_pbuf_align",		NSS_STATS_TYPE_DROP},
-	{"fail_ctx_active",		NSS_STATS_TYPE_DROP},
-	{"fail_hwctx_active",		NSS_STATS_TYPE_DROP},
-	{"fail_cipher",			NSS_STATS_TYPE_EXCEPTION},
-	{"fail_auth",			NSS_STATS_TYPE_EXCEPTION},
-	{"fail_seq_ovf",		NSS_STATS_TYPE_DROP},
-	{"fail_blk_len",		NSS_STATS_TYPE_DROP},
-	{"fail_hash_len",		NSS_STATS_TYPE_DROP},
-	{"len_error",			NSS_STATS_TYPE_DROP},
-	{"token_error",			NSS_STATS_TYPE_DROP},
-	{"bypass_error",		NSS_STATS_TYPE_DROP},
-	{"config_error",		NSS_STATS_TYPE_DROP},
-	{"algo_error",			NSS_STATS_TYPE_DROP},
-	{"hash_ovf_error",		NSS_STATS_TYPE_DROP},
-	{"ttl_error",			NSS_STATS_TYPE_DROP},
-	{"csum_error",			NSS_STATS_TYPE_DROP},
-	{"timeout_error",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[0]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[1]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[2]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[3]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[4]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[5]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[6]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[7]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[8]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[9]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[10]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[11]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[12]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[13]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[14]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[15]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[16]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[17]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[18]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[19]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[20]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[21]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[22]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[23]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[24]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[25]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[26]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[27]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[28]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[29]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[30]",		NSS_STATS_TYPE_DROP},
-	{"fail_cle_[31]",		NSS_STATS_TYPE_DROP},
-	{"seq_low",			NSS_STATS_TYPE_SPECIAL},
-	{"seq_high",			NSS_STATS_TYPE_SPECIAL},
-	{"epoch",			NSS_STATS_TYPE_SPECIAL}
-};
-
-/*
- * nss_dtls_cmn_ctx_stats_str_strings_read()
- *	Read dtls common ctx statistics names
- */
-static ssize_t nss_dtls_cmn_ctx_stats_str_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_dtls_cmn_ctx_stats_str, NSS_DTLS_CMN_CTX_STATS_MAX);
-}
-
-/*
- * nss_dtls_cmn_ctx_stats_str_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(dtls_cmn_ctx_stats_str);
-
-/*
- * nss_dtls_cmn_strings_dentry_create()
- *	Create dtls common statistics strings debug entry.
- */
-void nss_dtls_cmn_strings_dentry_create(void)
-{
-	nss_strings_create_dentry("dtls_cmn_ctx_stats_str", &nss_dtls_cmn_ctx_stats_str_strings_ops);
-}
--- a/nss_dtls_cmn_strings.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- ****************************************************************************
- * Copyright (c) 2020, The Linux Foundation. All rights reserved.
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ****************************************************************************
- */
-
-#ifndef __NSS_DTLS_CMN_STRINGS_H
-#define __NSS_DTLS_CMN_STRINGS_H
-
-#include "nss_dtls_cmn_stats.h"
-
-extern struct nss_stats_info nss_dtls_cmn_ctx_stats_str[NSS_DTLS_CMN_CTX_STATS_MAX];
-extern void nss_dtls_cmn_strings_dentry_create(void);
-
-#endif /* __NSS_DTLS_CMN_STRINGS_H */
--- a/nss_dynamic_interface_stats.c
+++ b/nss_dynamic_interface_stats.c
@@ -26,10 +26,10 @@
 const char *nss_dynamic_interface_type_names[NSS_DYNAMIC_INTERFACE_TYPE_MAX] = {
 	"NSS_DYNAMIC_INTERFACE_TYPE_NONE",
 	"NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR",
-	"NSS_DYNAMIC_INTERFACE_TYPE_RESERVED_5",
+	"NSS_DYNAMIC_INTERFACE_TYPE_CAPWAP",
 	"NSS_DYNAMIC_INTERFACE_TYPE_TUNIPIP6_INNER",
 	"NSS_DYNAMIC_INTERFACE_TYPE_TUNIPIP6_OUTER",
-	"NSS_DYNAMIC_INTERFACE_TYPE_RESERVED",
+	"NSS_DYNAMIC_INTERFACE_TYPE_WIFI",
 	"NSS_DYNAMIC_INTERFACE_TYPE_VAP",
 	"NSS_DYNAMIC_INTERFACE_TYPE_RESERVED_0",
 	"NSS_DYNAMIC_INTERFACE_TYPE_PPPOE",
@@ -43,7 +43,11 @@ const char *nss_dynamic_interface_type_n
 	"NSS_DYNAMIC_INTERFACE_TYPE_BRIDGE",
 	"NSS_DYNAMIC_INTERFACE_TYPE_VLAN",
 	"NSS_DYNAMIC_INTERFACE_TYPE_RESERVED_3",
+#if (NSS_FW_VERSION_CODE <= NSS_FW_VERSION(11,0))
+	"NSS_DYNAMIC_INTERFACE_TYPE_WIFILI",
+#else
 	"NSS_DYNAMIC_INTERFACE_TYPE_WIFILI_INTERNAL",
+#endif
 	"NSS_DYNAMIC_INTERFACE_TYPE_MAP_T_INNER",
 	"NSS_DYNAMIC_INTERFACE_TYPE_MAP_T_OUTER",
 	"NSS_DYNAMIC_INTERFACE_TYPE_GRE_TUNNEL_INNER",
@@ -80,15 +84,22 @@ const char *nss_dynamic_interface_type_n
 	"NSS_DYNAMIC_INTERFACE_TYPE_IGS",
 	"NSS_DYNAMIC_INTERFACE_TYPE_CLMAP_US",
 	"NSS_DYNAMIC_INTERFACE_TYPE_CLMAP_DS",
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,0))
 	"NSS_DYNAMIC_INTERFACE_TYPE_VXLAN_INNER",
 	"NSS_DYNAMIC_INTERFACE_TYPE_VXLAN_OUTER",
 	"NSS_DYNAMIC_INTERFACE_TYPE_MATCH",
+#endif
 	"NSS_DYNAMIC_INTERFACE_TYPE_RMNET_RX_N2H",
 	"NSS_DYNAMIC_INTERFACE_TYPE_RMNET_RX_H2N",
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,0))
 	"NSS_DYNAMIC_INTERFACE_TYPE_WIFILI_EXTERNAL0",
 	"NSS_DYNAMIC_INTERFACE_TYPE_WIFILI_EXTERNAL1",
-	"NSS_DYNAMIC_INTERFACE_TYPE_CAPWAP_HOST_INNER",
-	"NSS_DYNAMIC_INTERFACE_TYPE_CAPWAP_OUTER",
+#endif
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,1))
+	"NSS_DYNAMIC_INTERFACE_TYPE_TLS_INNER",
+	"NSS_DYNAMIC_INTERFACE_TYPE_TLS_OUTER",
+	"NSS_DYNAMIC_INTERFACE_TYPE_MIRROR",
+#endif
 };
 
 /*
--- a/nss_edma_lite.c
+++ /dev/null
@@ -1,243 +0,0 @@
-/*
- * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-/*
- * nss_edma_lite.c
- *	NSS EDMA APIs
- */
-#include "nss_edma_lite_stats.h"
-#include "nss_edma_lite_strings.h"
-#include <nss_dp_api_if.h>
-
-/*
- **********************************
- Rx APIs
- **********************************
- */
-static bool is_map_configured = false;
-
-/*
- * nss_edma_lite_interface_handler()
- *	Handle NSS -> HLOS messages for EDMA node
- */
-static void nss_edma_lite_interface_handler(struct nss_ctx_instance *nss_ctx, struct nss_cmn_msg *ncm, __attribute__((unused))void *app_data)
-{
-	struct nss_edma_lite_msg *nelm = (struct nss_edma_lite_msg *)ncm;
-	nss_edma_lite_msg_callback_t cb;
-
-	/*
-	 * Is this a valid request/response packet?
-	 */
-	if (nelm->cm.type >= NSS_EDMA_LITE_MSG_TYPE_MAX) {
-		nss_warning("%px: received invalid message %d for edma_lite interface", nss_ctx, nelm->cm.type);
-		return;
-	}
-
-	/*
-	 * Handle different types of messages
-	 */
-	switch (nelm->cm.type) {
-	case NSS_EDMA_LITE_MSG_NODE_STATS_SYNC:
-		nss_edma_lite_node_stats_sync(nss_ctx, &nelm->msg.node_stats);
-		break;
-	case NSS_EDMA_LITE_MSG_RING_STATS_SYNC:
-		nss_edma_lite_ring_stats_sync(nss_ctx, &nelm->msg.ring_stats);
-		break;
-	case NSS_EDMA_LITE_MSG_ERR_STATS_SYNC:
-		nss_edma_lite_err_stats_sync(nss_ctx, &nelm->msg.err_stats);
-		break;
-	default:
-		if (ncm->response != NSS_CMN_RESPONSE_ACK) {
-			/*
-			 * Check response
-			 */
-			nss_info("%px: Received response %d for type %d, interface %d",
-						nss_ctx, ncm->response, ncm->type, ncm->interface);
-		}
-	}
-
-	/*
-	 * Update the callback and app_data for NOTIFY messages, edma_lite sends all notify messages
-	 * to the same callback/app_data.
-	 */
-	if (nelm->cm.response == NSS_CMN_RESPONSE_NOTIFY) {
-		ncm->cb = (nss_ptr_t)nss_ctx->edma_lite_callback;
-		ncm->app_data = (nss_ptr_t)nss_ctx->edma_lite_ctx;
-	}
-
-	/*
-	 * Do we have a callback?
-	 */
-	if (!ncm->cb) {
-		return;
-	}
-
-	/*
-	 * Callback
-	 */
-	cb = (nss_edma_lite_msg_callback_t)ncm->cb;
-	cb((void *)ncm->app_data, nelm);
-}
-
-/*
- * nss_edma_lite_msg_cfg_map_callback()
- */
-static void nss_edma_lite_msg_cfg_map_callback(void *app_data, struct nss_edma_lite_msg *nelm)
-{
-	struct nss_ctx_instance *nss_ctx __attribute__((unused)) = (struct nss_ctx_instance *)app_data;
-	if (nelm->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_warning("%px: nss edma_lite_map configuration failed: %d for NSS core %d\n",
-				nss_ctx, nelm->cm.error, nss_ctx->id);
-		return;
-	}
-
-	/* TODO: SHould we protect this with some lock */
-	if (nelm->cm.type == NSS_EDMA_LITE_MSG_TYPE_RING_MAP) {
-		is_map_configured = true;
-	}
-
-	nss_info("%px: nss edma_lite_map configuration succeeded for NSS core %d\n", nss_ctx, nss_ctx->id);
-}
-
-/*
- * nss_edma_lite_tx_msg()
- *	Transmit an EDMA lite config message to the FW with a specified size.
- */
-nss_tx_status_t nss_edma_lite_tx_msg(struct nss_ctx_instance *nss_ctx, struct nss_edma_lite_msg *nelm)
-{
-	struct nss_cmn_msg *ncm = &nelm->cm;
-
-	if (ncm->type >= NSS_EDMA_LITE_MSG_TYPE_MAX) {
-		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
-		return NSS_TX_FAILURE;
-	}
-
-	return nss_core_send_cmd(nss_ctx, nelm, sizeof(*nelm), NSS_NBUF_PAYLOAD_SIZE);
-}
-EXPORT_SYMBOL(nss_edma_lite_tx_msg);
-
-bool nss_edma_lite_is_configured(void)
-{
-	return is_map_configured;
-}
-EXPORT_SYMBOL(nss_edma_lite_is_configured);
-
-/*
- * nss_edma_lite_msg_cfg_map()
- *	Send ring number to EDMA lite.
- */
-nss_tx_status_t nss_edma_lite_msg_cfg_map(struct nss_ctx_instance *nss_ctx)
-{
-	int32_t status;
-	struct nss_edma_lite_msg nelm;
-	struct nss_edma_lite_ring_map *cfg_map;
-	uint32_t txdesc_num, txcmpl_num, rxfill_num, rxdesc_num;
-
-	nss_edma_lite_msg_init(&nelm, NSS_EDMA_LITE_INTERFACE, NSS_EDMA_LITE_MSG_TYPE_RING_MAP,
-		sizeof(struct nss_edma_lite_ring_map), nss_edma_lite_msg_cfg_map_callback, (void *)nss_ctx);
-
-	/*
-	 * Invoke DP API to get point offload information
-	 */
-	nss_dp_point_offload_info_get(&txdesc_num, &txcmpl_num, &rxfill_num, &rxdesc_num);
-
-	cfg_map = &nelm.msg.map;
-	cfg_map->txdesc_num = txdesc_num;
-	cfg_map->txcmpl_num = txcmpl_num;
-	cfg_map->rxfill_num = rxfill_num;
-	cfg_map->rxdesc_num = rxdesc_num;
-
-	status = nss_edma_lite_tx_msg(nss_ctx, &nelm);
-	if (unlikely(status != NSS_TX_SUCCESS)) {
-		return status;
-	}
-
-	return NSS_TX_SUCCESS;
-}
-
-/*
- * nss_edma_lite_msg_init()
- *	Initialize EDMA LITE message.
- */
-void nss_edma_lite_msg_init(struct nss_edma_lite_msg *nelm, uint16_t if_num, uint32_t type, uint32_t len,
-			nss_edma_lite_msg_callback_t cb, void *app_data)
-{
-	nss_cmn_msg_init(&nelm->cm, if_num, type, len, (void *)cb, app_data);
-}
-EXPORT_SYMBOL(nss_edma_lite_msg_init);
-
-/*
- * nss_edma_lite_notify_register()
- *	Register to received EDMA events.
- */
-void nss_edma_lite_notify_register(nss_edma_lite_msg_callback_t cb, void *app_data)
-{
-	struct nss_ctx_instance *nss_ctx;
-	int i = 0;
-
-	for (i = 0; i < NSS_MAX_CORES; i++) {
-		int id = nss_top_main.edma_lite_handler_id[i];
-		if (id >= 0) {
-			nss_ctx = &nss_top_main.nss[id];
-			nss_ctx->edma_lite_callback = cb;
-			nss_ctx->edma_lite_ctx = app_data;
-		}
-	}
-}
-EXPORT_SYMBOL(nss_edma_lite_notify_register);
-
-/*
- * nss_edma_lite_notify_unregister()
- *	Unregister to received EDMA events.
- */
-void nss_edma_lite_notify_unregister(void)
-{
-	struct nss_ctx_instance *nss_ctx;
-	int i = 0;
-
-	for (i = 0; i < NSS_MAX_CORES; i++) {
-		int id = nss_top_main.edma_lite_handler_id[i];
-		if (id >= 0) {
-			nss_ctx = &nss_top_main.nss[id];
-			nss_ctx->edma_lite_callback = NULL;
-		}
-	}
-}
-EXPORT_SYMBOL(nss_edma_lite_notify_unregister);
-
-/*
- * nss_edma_lite_enabled()
- */
-bool nss_edma_lite_enabled(struct nss_ctx_instance *nss_ctx)
-{
-	int id = nss_top_main.edma_lite_handler_id[nss_ctx->id];
-	if (id == nss_ctx->id)
-		return true;
-
-	return false;
-}
-EXPORT_SYMBOL(nss_edma_lite_enabled);
-
-/*
- * nss_edma_lite_register_handler()
- */
-void nss_edma_lite_register_handler(struct nss_ctx_instance *nss_ctx)
-{
-	nss_core_register_handler(nss_ctx, NSS_EDMA_LITE_INTERFACE, nss_edma_lite_interface_handler, NULL);
-
-	nss_edma_lite_stats_dentry_create();
-	nss_edma_lite_strings_dentry_create();
-}
--- a/nss_edma_lite_stats.c
+++ /dev/null
@@ -1,579 +0,0 @@
-/*
- * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-/*
- * nss_edma_lite_stats.c
- *	NSS EDMA statistics APIs
- */
-
-#include "nss_edma_lite_stats.h"
-#include "nss_edma_lite_strings.h"
-
-/*
- * Declare atomic notifier data structure for statistics.
- */
-ATOMIC_NOTIFIER_HEAD(nss_edma_lite_stats_notifier);
-
-struct nss_edma_lite_stats edma_stats;
-
-/*
- **********************************
- EDMA statistics APIs
- **********************************
- */
-
-/*
- * nss_edma_lite_node_stats_read()
- *      Read EDMA node stats
- */
-static ssize_t nss_edma_lite_node_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	int32_t i;
-
-	/*
-	 * max output lines = #stats + start tag line + end tag line + three blank lines
-	 */
-	uint32_t max_output_lines = (NSS_STATS_NODE_MAX + 2) + 3;
-	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
-	size_t size_wr = 0;
-	ssize_t bytes_read = 0;
-	uint64_t *stats_shadow;
-
-	char *lbuf = kzalloc(size_al, GFP_KERNEL);
-	if (unlikely(lbuf == NULL)) {
-		nss_warning("Could not allocate memory for local statistics buffer");
-		return 0;
-	}
-
-	stats_shadow = kzalloc(NSS_STATS_NODE_MAX * sizeof(uint64_t), GFP_KERNEL);
-	if (unlikely(stats_shadow == NULL)) {
-		nss_warning("Could not allocate memory for local shadow buffer");
-		kfree(lbuf);
-		return 0;
-	}
-
-	size_wr += nss_stats_banner(lbuf, size_wr, size_al, "edma", NSS_STATS_SINGLE_CORE);
-
-	/*
-	 * Common node stats
-	 */
-	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "Node stats:\n\n");
-	spin_lock_bh(&nss_top_main.stats_lock);
-
-	for (i = 0; (i < NSS_STATS_NODE_MAX); i++)
-		stats_shadow[i] = edma_stats.node_stats[i];
-
-	spin_unlock_bh(&nss_top_main.stats_lock);
-	size_wr += nss_stats_print("edma_node", NULL, NSS_STATS_SINGLE_INSTANCE
-					, nss_edma_lite_strings_stats_node
-					, stats_shadow
-					, NSS_STATS_NODE_MAX
-					, lbuf, size_wr, size_al);
-	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
-	kfree(lbuf);
-	kfree(stats_shadow);
-
-	return bytes_read;
-}
-
-/*
- * nss_edma_lite_txring_stats_read()
- *	Read EDMA Tx ring stats
- */
-static ssize_t nss_edma_lite_txring_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	int32_t i = 0;
-
-	/*
-	 * max output lines = #stats + start tag line + end tag line + three blank lines
-	 */
-	uint32_t max_output_lines = (NSS_EDMA_LITE_STATS_TX_MAX + 2) + 3;
-	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
-	size_t size_wr = 0;
-	ssize_t bytes_read = 0;
-	uint64_t *stats_shadow;
-
-	char *lbuf = kzalloc(size_al, GFP_KERNEL);
-	if (unlikely(lbuf == NULL)) {
-		nss_warning("Could not allocate memory for local statistics buffer");
-		return 0;
-	}
-
-	stats_shadow = kzalloc(NSS_EDMA_LITE_STATS_TX_MAX * sizeof(uint64_t), GFP_KERNEL);
-	if (unlikely(stats_shadow == NULL)) {
-		nss_warning("Could not allocate memory for local shadow buffer");
-		kfree(lbuf);
-		return 0;
-	}
-
-	size_wr = scnprintf(lbuf, size_al, "edma Tx ring stats start:\n\n");
-
-	/*
-	 * Tx ring stats
-	 */
-	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "Tx ring stats:\n\n");
-	spin_lock_bh(&nss_top_main.stats_lock);
-	for (i = 0; (i < NSS_EDMA_LITE_STATS_TX_MAX); i++)
-		stats_shadow[i] = edma_stats.tx_stats[i];
-
-	spin_unlock_bh(&nss_top_main.stats_lock);
-
-	size_wr += nss_stats_print("edma_tx_ring", NULL, NSS_STATS_SINGLE_INSTANCE
-					, nss_edma_lite_strings_stats_tx
-					, stats_shadow
-					, NSS_EDMA_LITE_STATS_TX_MAX
-					, lbuf, size_wr, size_al);
-	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
-	kfree(lbuf);
-	kfree(stats_shadow);
-
-	return bytes_read;
-}
-
-/*
- * nss_edma_lite_rxring_stats_read()
- *	Read EDMA rxring stats
- */
-static ssize_t nss_edma_lite_rxring_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	int32_t i= 0;
-
-	/*
-	 * max output lines = #stats + start tag line + end tag line + three blank lines
-	 */
-	uint32_t max_output_lines = (NSS_EDMA_LITE_STATS_RX_MAX + 2) + 3;
-	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
-	size_t size_wr = 0;
-	ssize_t bytes_read = 0;
-	uint64_t *stats_shadow;
-
-	char *lbuf = kzalloc(size_al, GFP_KERNEL);
-	if (unlikely(lbuf == NULL)) {
-		nss_warning("Could not allocate memory for local statistics buffer");
-		return 0;
-	}
-
-	stats_shadow = kzalloc(NSS_EDMA_LITE_STATS_RX_MAX * sizeof(uint64_t), GFP_KERNEL);
-	if (unlikely(stats_shadow == NULL)) {
-		nss_warning("Could not allocate memory for local shadow buffer");
-		kfree(lbuf);
-		return 0;
-	}
-
-	/*
-	 * RX ring stats
-	 */
-	spin_lock_bh(&nss_top_main.stats_lock);
-	for (i = 0; (i < NSS_EDMA_LITE_STATS_RX_MAX); i++)
-		stats_shadow[i] = edma_stats.rx_stats[i];
-
-	spin_unlock_bh(&nss_top_main.stats_lock);
-	size_wr += nss_stats_print("edma_rx_ring", NULL, NSS_STATS_SINGLE_INSTANCE
-					, nss_edma_lite_strings_stats_rx
-					, stats_shadow
-					, NSS_EDMA_LITE_STATS_RX_MAX
-					, lbuf, size_wr, size_al);
-	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
-	kfree(lbuf);
-	kfree(stats_shadow);
-
-	return bytes_read;
-}
-
-/*
- * nss_edma_lite_txcmplring_stats_read()
- *	Read EDMA txcmplring stats
- */
-static ssize_t nss_edma_lite_txcmplring_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	int32_t i = 0;
-
-	/*
-	 * max output lines = #stats + start tag line + end tag line + three blank lines
-	 */
-	uint32_t max_output_lines = (NSS_EDMA_LITE_STATS_TXCMPL_MAX + 2) + 3;
-	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
-	size_t size_wr = 0;
-	ssize_t bytes_read = 0;
-	uint64_t *stats_shadow;
-
-	char *lbuf = kzalloc(size_al, GFP_KERNEL);
-	if (unlikely(lbuf == NULL)) {
-		nss_warning("Could not allocate memory for local statistics buffer");
-		return 0;
-	}
-
-	stats_shadow = kzalloc(NSS_EDMA_LITE_STATS_TXCMPL_MAX * sizeof(uint64_t), GFP_KERNEL);
-	if (unlikely(stats_shadow == NULL)) {
-		nss_warning("Could not allocate memory for local shadow buffer");
-		kfree(lbuf);
-		return 0;
-	}
-
-	size_wr = scnprintf(lbuf, size_al, "edma Tx cmpl ring stats start:\n\n");
-
-	/*
-	 * Tx cmpl ring stats
-	 */
-	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "Tx cmpl ring stats:\n\n");
-	spin_lock_bh(&nss_top_main.stats_lock);
-	for (i = 0; (i < NSS_EDMA_LITE_STATS_TXCMPL_MAX); i++)
-		stats_shadow[i] = edma_stats.txcmpl_stats[i];
-
-	spin_unlock_bh(&nss_top_main.stats_lock);
-	size_wr += nss_stats_print("edma_tx_cmpl_ring", NULL, NSS_STATS_SINGLE_INSTANCE
-					, nss_edma_lite_strings_stats_txcmpl
-					, stats_shadow
-					, NSS_EDMA_LITE_STATS_TXCMPL_MAX
-					, lbuf, size_wr, size_al);
-	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\nedma Tx cmpl ring stats end\n\n");
-	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
-	kfree(lbuf);
-	kfree(stats_shadow);
-
-	return bytes_read;
-}
-
-/*
- * nss_edma_lite_rxfillring_stats_read()
- *	Read EDMA rxfillring stats
- */
-static ssize_t nss_edma_lite_rxfillring_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	int32_t i = 0;
-
-	/*
-	 * max output lines = #stats + start tag line + end tag line + three blank lines
-	 */
-	uint32_t max_output_lines = (NSS_EDMA_LITE_STATS_RXFILL_MAX + 2) + 3;
-	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
-	size_t size_wr = 0;
-	ssize_t bytes_read = 0;
-	uint64_t *stats_shadow;
-
-	char *lbuf = kzalloc(size_al, GFP_KERNEL);
-	if (unlikely(lbuf == NULL)) {
-		nss_warning("Could not allocate memory for local statistics buffer");
-		return 0;
-	}
-
-	stats_shadow = kzalloc(NSS_EDMA_LITE_STATS_RXFILL_MAX * sizeof(uint64_t), GFP_KERNEL);
-	if (unlikely(stats_shadow == NULL)) {
-		nss_warning("Could not allocate memory for local shadow buffer");
-		kfree(lbuf);
-		return 0;
-	}
-
-	size_wr = scnprintf(lbuf, size_al, "edma Rx fill ring stats start:\n\n");
-
-	/*
-	 * Rx fill ring stats
-	 */
-	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "Rx fill ring stats:\n\n");
-	spin_lock_bh(&nss_top_main.stats_lock);
-	for (i = 0; i < NSS_EDMA_LITE_STATS_RXFILL_MAX; i++) {
-		stats_shadow[i] = edma_stats.rxfill_stats[i];
-	}
-
-	spin_unlock_bh(&nss_top_main.stats_lock);
-	size_wr += nss_stats_print("edma_rx_fill_ring", NULL
-					, NSS_STATS_SINGLE_INSTANCE
-					, nss_edma_lite_strings_stats_rxfill
-					, stats_shadow
-					, NSS_EDMA_LITE_STATS_RXFILL_MAX
-					, lbuf, size_wr, size_al);
-	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
-	kfree(lbuf);
-	kfree(stats_shadow);
-
-	return bytes_read;
-}
-
-/*
- * nss_edma_lite_err_stats_read()
- *      Read EDMA err stats
- */
-static ssize_t nss_edma_lite_err_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	int32_t i;
-
-	/*
-	 * max output lines = #stats + start tag line + end tag line + three blank lines
-	 */
-	uint32_t max_output_lines = (NSS_EDMA_LITE_ERR_STATS_MAX + 2) + 3;
-	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
-	size_t size_wr = 0;
-	ssize_t bytes_read = 0;
-	uint64_t *stats_shadow;
-
-	char *lbuf = kzalloc(size_al, GFP_KERNEL);
-	if (unlikely(lbuf == NULL)) {
-		nss_warning("Could not allocate memory for local statistics buffer");
-		return 0;
-	}
-
-	stats_shadow = kzalloc(NSS_EDMA_LITE_ERR_STATS_MAX * sizeof(uint64_t), GFP_KERNEL);
-	if (unlikely(stats_shadow == NULL)) {
-		nss_warning("Could not allocate memory for local shadow buffer");
-		kfree(lbuf);
-		return 0;
-	}
-
-	size_wr = scnprintf(lbuf, size_al, "edma error stats start:\n\n");
-
-	/*
-	 * Common node stats
-	 */
-	spin_lock_bh(&nss_top_main.stats_lock);
-
-	for (i = 0; (i < NSS_EDMA_LITE_ERR_STATS_MAX); i++)
-		stats_shadow[i] = edma_stats.err[i];
-
-	spin_unlock_bh(&nss_top_main.stats_lock);
-	size_wr += nss_stats_print("edma_err", NULL, NSS_STATS_SINGLE_INSTANCE
-					, nss_edma_lite_strings_stats_err_map
-					, stats_shadow
-					, NSS_EDMA_LITE_ERR_STATS_MAX
-					, lbuf, size_wr, size_al);
-	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
-	kfree(lbuf);
-	kfree(stats_shadow);
-
-	return bytes_read;
-}
-
-/*
- * edma_node_stats_ops
- */
-NSS_STATS_DECLARE_FILE_OPERATIONS(edma_lite_node);
-
-/*
- * edma_txring_stats_ops
- */
-NSS_STATS_DECLARE_FILE_OPERATIONS(edma_lite_txring);
-
-/*
- * edma_rxring_stats_ops
- */
-NSS_STATS_DECLARE_FILE_OPERATIONS(edma_lite_rxring);
-
-/*
- * edma_txcmplring_stats_ops
- */
-NSS_STATS_DECLARE_FILE_OPERATIONS(edma_lite_txcmplring);
-
-/*
- * edma_rxfillring_stats_ops
- */
-NSS_STATS_DECLARE_FILE_OPERATIONS(edma_lite_rxfillring);
-
-/*
- * edma_err_stats_ops
- */
-NSS_STATS_DECLARE_FILE_OPERATIONS(edma_lite_err);
-
-/*
- * nss_edma_lite_stats_dentry_create()
- *	Create edma statistics debug entry.
- */
-void nss_edma_lite_stats_dentry_create(void)
-{
-	struct dentry *edma_d = NULL;
-	struct dentry *edma_rings_dir_d = NULL;
-	struct dentry *edma_tx_d = NULL;
-	struct dentry *edma_rx_d = NULL;
-	struct dentry *edma_txcmpl_d = NULL;
-	struct dentry *edma_rxfill_d = NULL;
-	struct dentry *edma_err_stats_d = NULL;
-	struct dentry *edma_node_stats_d = NULL;
-
-	edma_d = debugfs_create_dir("edma_lite", nss_top_main.stats_dentry);
-	if (unlikely(edma_d == NULL)) {
-		nss_warning("Failed to create qca-nss-drv/stats/edma directory");
-		return;
-	}
-
-	/*
-	 *  edma node stats
-	 */
-	edma_node_stats_d = debugfs_create_file("node_stats", 0400, edma_d, &nss_top_main, &nss_edma_lite_node_stats_ops);
-	if (unlikely(edma_node_stats_d == NULL)) {
-		nss_warning("Failed to create qca-nss-drv/stats/edma/node_stats file");
-		return;
-	}
-
-	/*
-	 *  edma error stats
-	 */
-	edma_err_stats_d = debugfs_create_file("err_stats", 0400, edma_d, &nss_top_main, &nss_edma_lite_err_stats_ops);
-	if (unlikely(edma_err_stats_d == NULL)) {
-		nss_warning("Failed to create qca-nss-drv/stats/edma/err_stats file");
-		return;
-	}
-
-	/*
-	 * edma ring stats
-	 */
-	edma_rings_dir_d = debugfs_create_dir("rings", edma_d);
-	if (unlikely(edma_rings_dir_d == NULL)) {
-		nss_warning("Failed to create qca-nss-drv/stats/edma/rings directory");
-		return;
-	}
-
-	/*
-	 * edma tx ring stats
-	 */
-	edma_tx_d = debugfs_create_file("tx", 0400, edma_rings_dir_d, &nss_top_main, &nss_edma_lite_txring_stats_ops);
-	if (unlikely(edma_tx_d == NULL)) {
-		nss_warning("Failed to create qca-nss-drv/stats/edma/rings/tx file");
-		return;
-	}
-
-	/*
-	 * edma rx ring stats
-	 */
-	edma_rx_d = debugfs_create_file("rx", 0400, edma_rings_dir_d, &nss_top_main, &nss_edma_lite_rxring_stats_ops);
-	if (unlikely(edma_rx_d == NULL)) {
-		nss_warning("Failed to create qca-nss-drv/stats/edma/rings/rx file");
-		return;
-	}
-
-	/*
-	 * edma tx cmpl ring stats
-	 */
-	edma_txcmpl_d = debugfs_create_file("txcmpl", 0400, edma_rings_dir_d, &nss_top_main, &nss_edma_lite_txcmplring_stats_ops);
-	if (unlikely(edma_txcmpl_d == NULL)) {
-		nss_warning("Failed to create qca-nss-drv/stats/edma/rings/txcmpl file");
-		return;
-	}
-
-	/*
-	 * edma rx fill ring stats
-	 */
-	edma_rxfill_d = debugfs_create_file("rxfill", 0400, edma_rings_dir_d, &nss_top_main, &nss_edma_lite_rxfillring_stats_ops);
-	if (unlikely(edma_rxfill_d == NULL)) {
-		nss_warning("Failed to create qca-nss-drv/stats/edma/rings/rxfill file");
-		return;
-	}
-}
-
-/*
- * nss_edma_lite_node_stats_sync()
- *	Handle the syncing of EDMA node statistics.
- */
-void nss_edma_lite_node_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_edma_lite_node_stats_sync *nerss)
-{
-	int32_t i;
-	struct nss_top_instance *nss_top = nss_ctx->nss_top;
-
-	spin_lock_bh(&nss_top->stats_lock);
-
-	/*
-	 * edma node stats
-	 */
-	edma_stats.node_stats[NSS_STATS_NODE_RX_PKTS] += nerss->node_stats.rx_packets;
-	edma_stats.node_stats[NSS_STATS_NODE_RX_BYTES] += nerss->node_stats.rx_bytes;
-	edma_stats.node_stats[NSS_STATS_NODE_TX_PKTS] += nerss->node_stats.tx_packets;
-	edma_stats.node_stats[NSS_STATS_NODE_TX_BYTES] += nerss->node_stats.tx_bytes;
-
-	for (i = 0; i < NSS_MAX_NUM_PRI; i++) {
-		edma_stats.node_stats[NSS_STATS_NODE_RX_QUEUE_0_DROPPED + i] += nerss->node_stats.rx_dropped[i];
-	}
-
-	spin_unlock_bh(&nss_top->stats_lock);
-}
-
-/*
- * nss_edma_lite_ring_stats_sync()
- *	Handle the syncing of EDMA ring statistics.
- */
-void nss_edma_lite_ring_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_edma_lite_ring_stats_sync *nerss)
-{
-	struct nss_top_instance *nss_top = nss_ctx->nss_top;
-
-	spin_lock_bh(&nss_top->stats_lock);
-
-	/*
-	 * edma tx ring stats
-	 */
-	edma_stats.tx_stats[NSS_EDMA_LITE_STATS_TX_ERR] += nerss->tx_ring.tx_err;
-	edma_stats.tx_stats[NSS_EDMA_LITE_STATS_TX_DROPPED] += nerss->tx_ring.tx_dropped;
-	edma_stats.tx_stats[NSS_EDMA_LITE_STATS_TX_DESC] += nerss->tx_ring.desc_cnt;
-
-	/*
-	 * edma rx ring stats
-	 */
-	edma_stats.rx_stats[NSS_EDMA_LITE_STATS_RX_DESC] += nerss->rx_ring.desc_cnt;
-
-	/*
-	 * edma tx cmpl ring stats
-	 */
-	edma_stats.txcmpl_stats[NSS_EDMA_LITE_STATS_TXCMPL_DESC] += nerss->txcmpl_ring.desc_cnt;
-
-	/*
-	 * edma rx fill ring stats
-	 */
-	edma_stats.rxfill_stats[NSS_EDMA_LITE_STATS_RXFILL_DESC] += nerss->rxfill_ring.desc_cnt;
-
-	spin_unlock_bh(&nss_top->stats_lock);
-}
-
-/*
- * nss_edma_lite_err_stats_sync()
- *	Handle the syncing of EDMA error statistics.
- */
-void nss_edma_lite_err_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_edma_lite_err_stats_sync *nerss)
-{
-
-	struct nss_top_instance *nss_top = nss_ctx->nss_top;
-
-	spin_lock_bh(&nss_top->stats_lock);
-	edma_stats.err[NSS_EDMA_LITE_ALLOC_FAIL_CNT] += nerss->alloc_fail_cnt;
-	spin_unlock_bh(&nss_top->stats_lock);
-}
-
-/*
- * nss_edma_lite_stats_notify()
- *	Calls statistics notifier.
- *
- * Leverage NSS-FW statistics timing to update Netlink.
- */
-void nss_edma_lite_stats_notify(struct nss_ctx_instance *nss_ctx)
-{
-	uint32_t core_id = nss_ctx->id;
-
-	atomic_notifier_call_chain(&nss_edma_lite_stats_notifier, NSS_STATS_EVENT_NOTIFY, (void *)&core_id);
-}
-
-/*
- * nss_edma_lite_stats_register_notifier()
- *	Registers statistics notifier.
- */
-int nss_edma_lite_stats_register_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_register(&nss_edma_lite_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_edma_lite_stats_register_notifier);
-
-/*
- * nss_edma_lite_stats_unregister_notifier()
- *	Deregisters stats notifier.
- */
-int nss_edma_lite_stats_unregister_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_unregister(&nss_edma_lite_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_edma_lite_stats_unregister_notifier);
--- a/nss_edma_lite_stats.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-/*
- * nss_edma_lite_stats.h
- *	NSS EDMA statistics header file.
- */
-
-#ifndef __NSS_EDMA_LITE_STATS_H
-#define __NSS_EDMA_LITE_STATS_H
-
-#include "nss_core.h"
-
-/*
- * NSS EDMA statistics APIs
- */
-extern void nss_edma_lite_stats_notify(struct nss_ctx_instance *nss_ctx);
-extern void nss_edma_lite_node_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_edma_lite_node_stats_sync *nerss);
-extern void nss_edma_lite_ring_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_edma_lite_ring_stats_sync *nerss);
-extern void nss_edma_lite_err_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_edma_lite_err_stats_sync *nerss);
-extern void nss_edma_lite_stats_dentry_create(void);
-
-#endif /* __NSS_EDMA_LITE_STATS_H */
--- a/nss_edma_lite_strings.c
+++ /dev/null
@@ -1,246 +0,0 @@
-/*
- * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#include "nss_stats.h"
-#include "nss_core.h"
-#include <nss_edma_lite.h>
-#include "nss_strings.h"
-
-/*
- * nss_edma_lite_strings_stats_node
- *	EDMA statistics strings.
- */
-struct nss_stats_info nss_edma_lite_strings_stats_node[NSS_STATS_NODE_MAX] = {
-	{"rx_pkts"		, NSS_STATS_TYPE_COMMON},
-	{"rx_byts"		, NSS_STATS_TYPE_COMMON},
-	{"tx_pkts"		, NSS_STATS_TYPE_COMMON},
-	{"tx_byts"		, NSS_STATS_TYPE_COMMON},
-	{"rx_queue[0]_drops"	, NSS_STATS_TYPE_DROP},
-	{"rx_queue[1]_drops"	, NSS_STATS_TYPE_DROP},
-	{"rx_queue[2]_drops"	, NSS_STATS_TYPE_DROP},
-	{"rx_queue[3]_drops"	, NSS_STATS_TYPE_DROP}
-};
-
-/*
- * nss_edma_lite_node_stats_strings_read()
- *	Read EDMA node statistics names.
- */
-static ssize_t nss_edma_lite_node_stats_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_edma_lite_strings_stats_node, NSS_STATS_NODE_MAX);
-}
-
-/*
- * nss_edma_lite_node_stats_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(edma_lite_node_stats);
-
-/*
- * nss_edma_lite_strings_stats_tx
- */
-struct nss_stats_info nss_edma_lite_strings_stats_tx[NSS_EDMA_LITE_STATS_TX_MAX] = {
-	{"tx_err"	, NSS_STATS_TYPE_ERROR},
-	{"tx_drops"	, NSS_STATS_TYPE_DROP},
-	{"desc_cnt"	, NSS_STATS_TYPE_SPECIAL}
-};
-
-/*
- * nss_edma_lite_txring_strings_read()
- *      Read EDMA txring names.
- */
-static ssize_t nss_edma_lite_txring_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_edma_lite_strings_stats_tx, NSS_EDMA_LITE_STATS_TX_MAX);
-}
-
-/*
- * edma_txring_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(edma_lite_txring);
-
-/*
- * nss_edma_lite_strings_stats_rx
- */
-struct nss_stats_info nss_edma_lite_strings_stats_rx[NSS_EDMA_LITE_STATS_RX_MAX] = {
-	{"desc_cnt"		, NSS_STATS_TYPE_SPECIAL}
-};
-
-/*
- * nss_edma_lite_rxring_strings_read()
- *      Read EDMA rxring names.
- */
-static ssize_t nss_edma_lite_rxring_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_edma_lite_strings_stats_rx, NSS_EDMA_LITE_STATS_RX_MAX);
-}
-
-/*
- * edma_rxring_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(edma_lite_rxring);
-
-/*
- * nss_edma_lite_strings_stats_txcmpl
- */
-struct nss_stats_info nss_edma_lite_strings_stats_txcmpl[NSS_EDMA_LITE_STATS_TXCMPL_MAX] = {
-	{"desc_cnt"	, NSS_STATS_TYPE_SPECIAL}
-};
-
-/*
- * nss_edma_lite_txcmplring_strings_read()
- *      Read EDMA txcmplring names.
- */
-static ssize_t nss_edma_lite_txcmplring_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_edma_lite_strings_stats_txcmpl, NSS_EDMA_LITE_STATS_TXCMPL_MAX);
-}
-
-/*
- * edma_txcmplring_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(edma_lite_txcmplring);
-
-/*
- * nss_edma_lite_strings_stats_rxfill
- */
-struct nss_stats_info nss_edma_lite_strings_stats_rxfill[NSS_EDMA_LITE_STATS_RXFILL_MAX] = {
-	{"desc_cnt"	, NSS_STATS_TYPE_SPECIAL}
-};
-
-/*
- * nss_edma_lite_rxfillring_strings_read()
- *      Read EDMA rxfillring names.
- */
-static ssize_t nss_edma_lite_rxfillring_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_edma_lite_strings_stats_rxfill, NSS_EDMA_LITE_STATS_RXFILL_MAX);
-}
-
-/*
- * edma_rxfillring_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(edma_lite_rxfillring);
-
-/*
- * nss_edma_lite_strings_stats_err_map
- */
-struct nss_stats_info nss_edma_lite_strings_stats_err_map[NSS_EDMA_LITE_ERR_STATS_MAX] = {
-	{"alloc_fail_cnt"	, NSS_STATS_TYPE_ERROR},
-	{"unknown_pkt_cnt"	, NSS_STATS_TYPE_ERROR},
-};
-
-/*
- * nss_edma_lite_err_strings_read()
- *      Read EDMA error names.
- */
-static ssize_t nss_edma_lite_err_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_edma_lite_strings_stats_err_map, NSS_EDMA_LITE_ERR_STATS_MAX);
-}
-
-/*
- * edma_err_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(edma_lite_err);
-
-/*
- * nss_edma_lite_strings_dentry_create()
- *      Create EDMA statistics strings debug entry.
- */
-void nss_edma_lite_strings_dentry_create(void)
-{
-	struct dentry *edma_d;
-	struct dentry *edma_rings_dir_d;
-	struct dentry *file_d;
-
-	if (!nss_top_main.strings_dentry) {
-		nss_warning("qca-nss-drv/strings is not present");
-		return;
-	}
-
-	edma_d = debugfs_create_dir("edma", nss_top_main.strings_dentry);
-	if (!edma_d) {
-		nss_warning("Failed to create qca-nss-drv/strings/edma directory");
-		return;
-	}
-
-	/*
-	 *  edma node stats
-	 */
-	file_d = debugfs_create_file("node_stats", 0400, edma_d, &nss_top_main, &nss_edma_lite_node_stats_strings_ops);
-	if (!file_d) {
-		nss_warning("Failed to create qca-nss-drv/strings/edma/node_stats file");
-		goto fail;
-	}
-
-	/*
-	 *  edma error stats
-	 */
-	file_d = debugfs_create_file("err_stats", 0400, edma_d, &nss_top_main, &nss_edma_lite_err_strings_ops);
-	if (!file_d) {
-		nss_warning("Failed to create qca-nss-drv/strings/edma/err_stats file");
-		goto fail;
-	}
-
-	/*
-	 * edma ring stats
-	 */
-	edma_rings_dir_d = debugfs_create_dir("rings", edma_d);
-	if (!edma_rings_dir_d) {
-		nss_warning("Failed to create qca-nss-drv/strings/edma/rings directory");
-		goto fail;
-	}
-
-	/*
-	 * edma tx ring stats
-	 */
-	file_d = debugfs_create_file("tx", 0400, edma_rings_dir_d, &nss_top_main, &nss_edma_lite_txring_strings_ops);
-	if (!file_d) {
-		nss_warning("Failed to create qca-nss-drv/strings/edma/rings/tx file");
-		goto fail;
-	}
-
-	/*
-	 * edma rx ring stats
-	 */
-	file_d = debugfs_create_file("rx", 0400, edma_rings_dir_d, &nss_top_main, &nss_edma_lite_rxring_strings_ops);
-	if (!file_d) {
-		nss_warning("Failed to create qca-nss-drv/strings/edma/rings/rx file");
-		goto fail;
-	}
-
-	/*
-	 * edma tx cmpl ring stats
-	 */
-	file_d = debugfs_create_file("txcmpl", 0400, edma_rings_dir_d, &nss_top_main, &nss_edma_lite_txcmplring_strings_ops);
-	if (!file_d) {
-		nss_warning("Failed to create qca-nss-drv/strings/edma/rings/txcmpl file");
-		goto fail;
-	}
-
-	/*
-	 * edma rx fill ring stats
-	 */
-	file_d = debugfs_create_file("rxfill", 0400, edma_rings_dir_d, &nss_top_main, &nss_edma_lite_rxfillring_strings_ops);
-	if (!file_d) {
-		nss_warning("Failed to create qca-nss-drv/strings/edma/rings/rxfill file");
-		goto fail;
-	}
-
-	return;
-fail:
-	debugfs_remove_recursive(edma_d);
-}
--- a/nss_edma_lite_strings.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#ifndef __NSS_EDMA_LITE_LITE_STRINGS_H
-#define __NSS_EDMA_LITE_LITE_STRINGS_H
-
-extern struct nss_stats_info nss_edma_lite_strings_stats_node[NSS_STATS_NODE_MAX];
-extern struct nss_stats_info nss_edma_lite_strings_stats_tx[NSS_EDMA_LITE_STATS_TX_MAX];
-extern struct nss_stats_info nss_edma_lite_strings_stats_rx[NSS_EDMA_LITE_STATS_RX_MAX];
-extern struct nss_stats_info nss_edma_lite_strings_stats_txcmpl[NSS_EDMA_LITE_STATS_TXCMPL_MAX];
-extern struct nss_stats_info nss_edma_lite_strings_stats_rxfill[NSS_EDMA_LITE_STATS_RXFILL_MAX];
-extern struct nss_stats_info nss_edma_lite_strings_stats_err_map[NSS_EDMA_LITE_ERR_STATS_MAX];
-extern void nss_edma_lite_strings_dentry_create(void);
-
-#endif /* __NSS_EDMA_LITE_STRINGS_H */
--- a/nss_edma_stats.c
+++ b/nss_edma_stats.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -732,7 +732,6 @@ void nss_edma_metadata_ring_stats_sync(s
 		edma_stats.rx_stats[i][NSS_EDMA_STATS_RX_DESC] += nerss->rx_ring[i].desc_cnt;
 		edma_stats.rx_stats[i][NSS_EDMA_STATS_RX_QOS_ERR] += nerss->rx_ring[i].qos_err;
 		edma_stats.rx_stats[i][NSS_EDMA_STATS_RX_SRC_PORT_INVALID] += nerss->rx_ring[i].rx_src_port_invalid;
-		edma_stats.rx_stats[i][NSS_EDMA_STATS_RX_SRC_IF_INVALID] += nerss->rx_ring[i].rx_src_if_invalid;
 	}
 
 	/*
--- a/nss_edma_strings.c
+++ b/nss_edma_strings.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -78,8 +78,7 @@ struct nss_stats_info nss_edma_strings_s
 	{"rx_csum_err"		, NSS_STATS_TYPE_ERROR},
 	{"desc_cnt"		, NSS_STATS_TYPE_SPECIAL},
 	{"qos_err"		, NSS_STATS_TYPE_DROP},
-	{"rx_src_port_invalid"	, NSS_STATS_TYPE_DROP},
-	{"rx_src_interface_invalid"	, NSS_STATS_TYPE_DROP}
+	{"rx_src_port_invalid"	, NSS_STATS_TYPE_DROP}
 };
 
 /*
--- a/nss_freq.c
+++ b/nss_freq.c
@@ -299,12 +299,7 @@ void nss_freq_scale_frequency(struct nss
 
 	if (nss_runtime_samples.freq_scale_rate_limit_down++ >= NSS_FREQUENCY_SCALE_RATE_LIMIT_DOWN) {
 		minimum = nss_runtime_samples.freq_scale[index].minimum;
-
-		/*
-		 * Check if we need to lower the frequency. For some SoC like IPQ50xx, low frequency
-		 * is not supported. So check if the next lower frequency is configured before shifting down
-		 */
-		if ((nss_runtime_samples.average < minimum) && (index > 0) && nss_runtime_samples.freq_scale[index - 1].maximum) {
+		if ((nss_runtime_samples.average < minimum) && (index > 0)) {
 			nss_runtime_samples.freq_scale_index--;
 			nss_runtime_samples.freq_scale_ready = 0;
 
--- a/nss_gre.c
+++ b/nss_gre.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -17,7 +17,6 @@
 #include "nss_tx_rx_common.h"
 #include "nss_gre_stats.h"
 #include "nss_gre_log.h"
-#include "nss_gre_strings.h"
 
 #define NSS_GRE_TX_TIMEOUT 3000 /* 3 Seconds */
 
@@ -116,13 +115,11 @@ static void nss_gre_msg_handler(struct n
 		/*
 		 * debug stats embedded in stats msg
 		 */
-		nss_gre_stats_session_sync(nss_ctx, &ntm->msg.sstats, ncm->interface);
-		nss_gre_stats_session_notify(nss_ctx, ncm->interface);
+		nss_gre_stats_session_debug_sync(nss_ctx, &ntm->msg.sstats, ncm->interface);
 		break;
 
 	case NSS_GRE_MSG_BASE_STATS:
-		nss_gre_stats_base_sync(nss_ctx, &ntm->msg.bstats);
-		nss_gre_stats_base_notify(nss_ctx);
+		nss_gre_stats_base_debug_sync(nss_ctx, &ntm->msg.bstats);
 		break;
 
 	default:
@@ -407,5 +404,4 @@ void nss_gre_register_handler(void)
 	init_completion(&nss_gre_pvt.complete);
 	nss_core_register_handler(nss_ctx, NSS_GRE_INTERFACE, nss_gre_msg_handler, NULL);
 	nss_gre_stats_dentry_create();
-	nss_gre_strings_dentry_create();
 }
--- a/nss_gre_redir.c
+++ b/nss_gre_redir.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -16,7 +16,6 @@
 
 #include "nss_tx_rx_common.h"
 #include "nss_gre_redir_stats.h"
-#include "nss_gre_redir_strings.h"
 #include "nss_gre_redir_log.h"
 #define NSS_GRE_REDIR_TX_TIMEOUT 3000 /* 3 Seconds */
 
@@ -32,9 +31,14 @@ static struct {
 } nss_gre_redir_pvt;
 
 /*
+ * Spinlock to update tunnel stats.
+ */
+static DEFINE_SPINLOCK(nss_gre_redir_stats_lock);
+
+/*
  * Array to hold tunnel stats along with if_num
  */
-struct nss_gre_redir_tunnel_stats tun_stats[NSS_GRE_REDIR_MAX_INTERFACES];
+static struct nss_gre_redir_tunnel_stats tun_stats[NSS_GRE_REDIR_MAX_INTERFACES];
 
 /*
  * nss_gre_callback()
@@ -55,7 +59,7 @@ static void nss_gre_redir_msg_sync_callb
  * nss_gre_redir_verify_ifnum()
  *	Verify interface type.
  */
-bool nss_gre_redir_verify_ifnum(uint32_t if_num)
+static bool nss_gre_redir_verify_ifnum(uint32_t if_num)
 {
 	uint32_t type;
 
@@ -69,6 +73,92 @@ bool nss_gre_redir_verify_ifnum(uint32_t
 }
 
 /*
+ * nss_gre_redir_tunnel_update_stats()
+ *	Update gre_redir tunnel stats.
+ */
+static void nss_gre_redir_tunnel_update_stats(struct nss_ctx_instance *nss_ctx, int if_num, struct nss_gre_redir_stats_sync_msg *ngss)
+{
+	int i, j;
+	uint32_t type;
+	struct net_device *dev;
+
+	type = nss_dynamic_interface_get_type(nss_ctx, if_num);
+	dev = nss_cmn_get_interface_dev(nss_ctx, if_num);
+	if (!dev) {
+		nss_warning("%px: Unable to find net device for the interface %d\n", nss_ctx, if_num);
+		return;
+	}
+
+	if (!nss_gre_redir_verify_ifnum(if_num)) {
+		nss_warning("%px: Unknown type for interface %d\n", nss_ctx, if_num);
+		return;
+	}
+
+	spin_lock_bh(&nss_gre_redir_stats_lock);
+	for (i = 0; i < NSS_GRE_REDIR_MAX_INTERFACES; i++) {
+		if (tun_stats[i].dev == dev) {
+			break;
+		}
+	}
+
+	if (i == NSS_GRE_REDIR_MAX_INTERFACES) {
+		nss_warning("%px: Unable to find tunnel stats instance for interface %d\n", nss_ctx, if_num);
+		return;
+	}
+
+	nss_assert(tun_stats[i].ref_count);
+	switch (type) {
+	case NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_WIFI_HOST_INNER:
+	case NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_WIFI_OFFL_INNER:
+	case NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_SJACK_INNER:
+		tun_stats[i].node_stats.tx_packets += ngss->node_stats.tx_packets;
+		tun_stats[i].node_stats.tx_bytes += ngss->node_stats.tx_bytes;
+		tun_stats[i].sjack_tx_packets += ngss->sjack_rx_packets;
+		tun_stats[i].encap_sg_alloc_drop += ngss->encap_sg_alloc_drop;
+		tun_stats[i].tx_dropped += nss_cmn_rx_dropped_sum(&(ngss->node_stats));
+		for (j = 0; j < NSS_GRE_REDIR_MAX_RADIO; j++) {
+			tun_stats[i].offl_tx_pkts[j] += ngss->offl_rx_pkts[j];
+		}
+
+		break;
+
+	case NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_OUTER:
+		tun_stats[i].node_stats.rx_packets += ngss->node_stats.rx_packets;
+		tun_stats[i].node_stats.rx_bytes += ngss->node_stats.rx_bytes;
+		tun_stats[i].sjack_rx_packets += ngss->sjack_rx_packets;
+		tun_stats[i].decap_fail_drop += ngss->decap_fail_drop;
+		tun_stats[i].decap_split_drop += ngss->decap_split_drop;
+		tun_stats[i].split_sg_alloc_fail += ngss->split_sg_alloc_fail;
+		tun_stats[i].split_linear_copy_fail += ngss->split_linear_copy_fail;
+		tun_stats[i].split_not_enough_tailroom += ngss->split_not_enough_tailroom;
+		tun_stats[i].decap_eapol_frames += ngss->decap_eapol_frames;
+		tun_stats[i].node_stats.rx_dropped[0] += nss_cmn_rx_dropped_sum(&(ngss->node_stats));
+		for (j = 0; j < NSS_GRE_REDIR_MAX_RADIO; j++) {
+			tun_stats[i].offl_rx_pkts[j] += ngss->offl_rx_pkts[j];
+		}
+
+		break;
+
+	case NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_EXCEPTION_US:
+		tun_stats[i].exception_us_rx += ngss->node_stats.rx_packets;
+		tun_stats[i].exception_us_tx += ngss->node_stats.tx_packets;
+		break;
+
+	case NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_EXCEPTION_DS:
+		tun_stats[i].exception_ds_rx += ngss->node_stats.rx_packets;
+		tun_stats[i].exception_ds_tx += ngss->node_stats.tx_packets;
+		tun_stats[i].exception_ds_invalid_dst_drop += ngss->exception_ds_invalid_dst_drop;
+		tun_stats[i].exception_ds_inv_appid += ngss->exception_ds_inv_appid;
+		tun_stats[i].headroom_unavail += ngss->headroom_unavail;
+		tun_stats[i].tx_completion_success += ngss->tx_completion_success;
+		tun_stats[i].tx_completion_drop += ngss->tx_completion_drop;
+		break;
+	}
+
+	spin_unlock_bh(&nss_gre_redir_stats_lock);
+}
+
+/*
  * nss_gre_redir_handler()
  *	Handle NSS -> HLOS messages for GRE tunnel.
  */
@@ -109,7 +199,7 @@ static void nss_gre_redir_msg_handler(st
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
 		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
-		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[ncm->interface].app_data;
+		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[nss_ctx->id][ncm->interface].app_data;
 	}
 
 	/*
@@ -119,8 +209,7 @@ static void nss_gre_redir_msg_handler(st
 
 	switch (ncm->type) {
 	case NSS_GRE_REDIR_RX_STATS_SYNC_MSG:
-		nss_gre_redir_stats_sync(nss_ctx, ncm->interface, &ngrm->msg.stats_sync);
-		nss_gre_redir_stats_notify(nss_ctx, ncm->interface);
+		nss_gre_redir_tunnel_update_stats(nss_ctx, ncm->interface, &ngrm->msg.stats_sync);
 		break;
 	}
 
@@ -452,6 +541,24 @@ nss_tx_status_t nss_gre_redir_configure_
 EXPORT_SYMBOL(nss_gre_redir_configure_outer_node);
 
 /*
+ * nss_gre_redir_get_stats()
+ *	Get gre_redir tunnel stats.
+ */
+bool nss_gre_redir_get_stats(int index, struct nss_gre_redir_tunnel_stats *stats)
+{
+	spin_lock_bh(&nss_gre_redir_stats_lock);
+	if (tun_stats[index].ref_count == 0) {
+		spin_unlock_bh(&nss_gre_redir_stats_lock);
+		return false;
+	}
+
+	memcpy(stats, &tun_stats[index], sizeof(struct nss_gre_redir_tunnel_stats));
+	spin_unlock_bh(&nss_gre_redir_stats_lock);
+	return true;
+}
+EXPORT_SYMBOL(nss_gre_redir_get_stats);
+
+/*
  * nss_gre_redir_tx_msg()
  *	Transmit a GRE message to NSS FW.
  */
@@ -668,6 +775,4 @@ void nss_gre_redir_register_handler(void
 		nss_warning("%px: Not able to register handler for gre_redir base interface with NSS core\n", nss_ctx);
 		return;
 	}
-
-	nss_gre_redir_strings_dentry_create();
 }
--- a/nss_gre_redir_lag_ds.c
+++ b/nss_gre_redir_lag_ds.c
@@ -1,6 +1,6 @@
 /*
- ****************************************************************************
- * Copyright (c) 2018, 2020-2021, The Linux Foundation. All rights reserved.
+ **************************************************************************
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -11,18 +11,17 @@
  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
  * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ****************************************************************************
+ **************************************************************************
  */
 
 #include "nss_tx_rx_common.h"
-#include "nss_gre_redir_lag.h"
 #include "nss_gre_redir_lag_ds_stats.h"
 #include "nss_gre_redir_lag_ds_log.h"
-#include "nss_gre_redir_lag_ds_strings.h"
 
 #define NSS_GRE_REDIR_LAG_DS_TX_TIMEOUT 3000 /* 3 Seconds */
 
-struct nss_gre_redir_lag_ds_tun_stats tun_ds_stats[NSS_GRE_REDIR_LAG_MAX_NODE];
+static struct nss_gre_redir_lag_ds_tun_stats tun_stats[NSS_GRE_REDIR_LAG_MAX_NODE];
+static DEFINE_SPINLOCK(nss_gre_redir_lag_ds_stats_lock);
 
 /*
  * Private data structure
@@ -65,11 +64,11 @@ static void nss_gre_redir_lag_ds_callbac
  * nss_gre_redir_lag_ds_get_node_idx()
  *	Returns index of statistics context.
  */
-bool nss_gre_redir_lag_ds_get_node_idx(uint32_t ifnum, uint32_t *idx)
+static inline bool nss_gre_redir_lag_ds_get_node_idx(uint32_t ifnum, uint32_t *idx)
 {
 	uint32_t node_idx;
 	for (node_idx = 0; node_idx < NSS_GRE_REDIR_LAG_MAX_NODE; node_idx++) {
-		if ((tun_ds_stats[node_idx].valid) && (tun_ds_stats[node_idx].ifnum == ifnum)) {
+		if ((tun_stats[node_idx].valid) && (tun_stats[node_idx].ifnum == ifnum)) {
 			*idx = node_idx;
 			return true;
 		}
@@ -79,10 +78,37 @@ bool nss_gre_redir_lag_ds_get_node_idx(u
 }
 
 /*
+ * nss_gre_redir_lag_ds_update_sync_stats()
+ *	Update synchonized statistics.
+ */
+static void nss_gre_redir_lag_ds_update_sync_stats(struct nss_ctx_instance *nss_ctx, struct nss_gre_redir_lag_ds_sync_stats_msg *ngss, uint32_t ifnum)
+{
+	int idx, j;
+
+	spin_lock_bh(&nss_gre_redir_lag_ds_stats_lock);
+	if (!nss_gre_redir_lag_ds_get_node_idx(ifnum, &idx)) {
+		spin_unlock_bh(&nss_gre_redir_lag_ds_stats_lock);
+		nss_warning("%px: Unable to update hash stats msg. Stats context not found.\n", nss_ctx);
+		return;
+	}
+
+	tun_stats[idx].tx_packets += ngss->node_stats.tx_packets;
+	tun_stats[idx].tx_bytes += ngss->node_stats.tx_bytes;
+	tun_stats[idx].rx_packets += ngss->node_stats.rx_packets;
+	tun_stats[idx].rx_bytes += ngss->node_stats.rx_bytes;
+	for (j = 0; j < NSS_MAX_NUM_PRI; j++) {
+		tun_stats[idx].rx_dropped[j] += ngss->node_stats.rx_dropped[j];
+	}
+	tun_stats[idx].dst_invalid += ngss->ds_stats.dst_invalid;
+	tun_stats[idx].exception_cnt += ngss->ds_stats.exception_cnt;
+	spin_unlock_bh(&nss_gre_redir_lag_ds_stats_lock);
+}
+
+/*
  * nss_gre_redir_lag_ds_verify_ifnum()
  *	Verify interface type.
  */
-bool nss_gre_redir_lag_ds_verify_ifnum(uint32_t if_num)
+static bool nss_gre_redir_lag_ds_verify_ifnum(uint32_t if_num)
 {
 	return nss_dynamic_interface_get_type(nss_gre_redir_lag_ds_get_context(), if_num) == NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_LAG_DS;
 }
@@ -121,7 +147,7 @@ static void nss_gre_redir_lag_ds_msg_han
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
 		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
-		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[ncm->interface].app_data;
+		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[nss_ctx->id][ncm->interface].app_data;
 	}
 
 	/*
@@ -136,8 +162,7 @@ static void nss_gre_redir_lag_ds_msg_han
 
 	switch (ncm->type) {
 	case NSS_GRE_REDIR_LAG_DS_STATS_SYNC_MSG:
-		nss_gre_redir_lag_ds_stats_sync(nss_ctx, &ngrm->msg.ds_sync_stats, ncm->interface);
-		nss_gre_redir_lag_ds_stats_notify(nss_ctx, ncm->interface);
+		nss_gre_redir_lag_ds_update_sync_stats(nss_ctx, &ngrm->msg.ds_sync_stats, ncm->interface);
 		break;
 	}
 
@@ -192,7 +217,7 @@ static enum nss_gre_redir_lag_err_types
 		return NSS_GRE_REDIR_LAG_ERR_STATS_INDEX_NOT_FOUND;
 	}
 
-	tun_ds_stats[idx].valid = false;
+	tun_stats[idx].valid = false;
 	spin_unlock_bh(&nss_gre_redir_lag_ds_stats_lock);
 	return NSS_GRE_REDIR_LAG_SUCCESS;
 }
@@ -233,9 +258,9 @@ static struct nss_ctx_instance *nss_gre_
 	nss_core_set_subsys_dp_type(nss_ctx, netdev, if_num, type);
 	spin_lock_bh(&nss_gre_redir_lag_ds_stats_lock);
 	for (i = 0; i < NSS_GRE_REDIR_LAG_MAX_NODE; i++) {
-		if (!tun_ds_stats[i].valid) {
-			tun_ds_stats[i].ifnum = if_num;
-			tun_ds_stats[i].valid = true;
+		if (!tun_stats[i].valid) {
+			tun_stats[i].ifnum = if_num;
+			tun_stats[i].valid = true;
 			break;
 		}
 	}
@@ -256,6 +281,26 @@ struct nss_ctx_instance *nss_gre_redir_l
 EXPORT_SYMBOL(nss_gre_redir_lag_ds_get_context);
 
 /*
+ * nss_gre_redir_lag_ds_get_cmn_stats()
+ *	Get statistics for downstream LAG node.
+ */
+bool nss_gre_redir_lag_ds_get_cmn_stats(struct nss_gre_redir_lag_ds_tun_stats *cmn_stats, uint32_t index)
+{
+	if (index >= NSS_GRE_REDIR_LAG_MAX_NODE) {
+		return false;
+	}
+
+	spin_lock_bh(&nss_gre_redir_lag_ds_stats_lock);
+	if (!tun_stats[index].valid) {
+		spin_unlock_bh(&nss_gre_redir_lag_ds_stats_lock);
+		return false;
+	}
+	memcpy((void *)cmn_stats, (void *)&tun_stats[index], sizeof(*cmn_stats));
+	spin_unlock_bh(&nss_gre_redir_lag_ds_stats_lock);
+	return true;
+}
+
+/*
  * nss_gre_redir_lag_ds_tx_msg()
  *	Transmit a gre message to NSS.
  */
@@ -396,7 +441,6 @@ void nss_gre_redir_lag_ds_register_handl
 		return;
 	}
 
-	nss_gre_redir_lag_ds_strings_dentry_create();
 	nss_gre_redir_lag_ds_pvt.cb = NULL;
 	nss_gre_redir_lag_ds_pvt.app_data = NULL;
 	sema_init(&nss_gre_redir_lag_ds_pvt.sem, 1);
--- a/nss_gre_redir_lag_ds_stats.c
+++ b/nss_gre_redir_lag_ds_stats.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, 2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -17,38 +17,69 @@
 #include "nss_core.h"
 #include "nss_gre_redir_lag.h"
 #include "nss_gre_redir_lag_ds_stats.h"
-#include "nss_gre_redir_lag_ds_strings.h"
 
 /*
- * Declare atomic notifier data structure for statistics.
+ * nss_gre_redir_lag_ds_stats_str
+ *	GRE REDIR LAG DS common statistics strings.
  */
-ATOMIC_NOTIFIER_HEAD(nss_gre_redir_lag_ds_stats_notifier);
+static uint8_t *nss_gre_redir_lag_ds_stats_str[NSS_GRE_REDIR_LAG_DS_STATS_MAX] = {
+	"rx_packets",
+	"rx_bytes",
+	"tx_packets",
+	"tx_bytes",
+	"rx_queue_0_dropped",
+	"rx_queue_1_dropped",
+	"rx_queue_2_dropped",
+	"rx_queue_3_dropped",
+	"dst_invalid",
+	"exception_packets"
+};
+
+/*
+ * nss_gre_redir_lag_ds_tunnel_stats()
+ *	Make a row for GRE_REDIR LAG DS stats.
+ */
+static ssize_t nss_gre_redir_lag_ds_cmn_stats_read_entry(char *line, int len, int type, struct nss_gre_redir_lag_ds_tun_stats *s)
+{
+	uint64_t tcnt = 0;
+
+	switch (type) {
+	case NSS_STATS_NODE_RX_PKTS:
+		tcnt = s->rx_packets;
+		return snprintf(line, len, "Common node stats start:\n\n%s = %llu\n", nss_gre_redir_lag_ds_stats_str[type], tcnt);
+	case NSS_STATS_NODE_RX_BYTES:
+		tcnt = s->rx_bytes;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_ds_stats_str[type], tcnt);
+	case NSS_STATS_NODE_TX_PKTS:
+		tcnt = s->tx_packets;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_ds_stats_str[type], tcnt);
+	case NSS_STATS_NODE_TX_BYTES:
+		tcnt = s->tx_bytes;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_ds_stats_str[type], tcnt);
+	case NSS_STATS_NODE_RX_QUEUE_0_DROPPED:
+		tcnt = s->rx_dropped[0];
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_ds_stats_str[type], tcnt);
+#if (NSS_MAX_NUM_PRI > 1)
+	case NSS_STATS_NODE_RX_QUEUE_1_DROPPED:
+		tcnt = s->rx_dropped[1];
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_ds_stats_str[type], tcnt);
+	case NSS_STATS_NODE_RX_QUEUE_2_DROPPED:
+		tcnt = s->rx_dropped[2];
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_ds_stats_str[type], tcnt);
+	case NSS_STATS_NODE_RX_QUEUE_3_DROPPED:
+		tcnt = s->rx_dropped[3];
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_ds_stats_str[type], tcnt);
+#endif
+	case NSS_GRE_REDIR_LAG_DS_STATS_DST_INVALID:
+		tcnt = s->dst_invalid;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_ds_stats_str[type], tcnt);
+	case NSS_GRE_REDIR_LAG_DS_STATS_EXCEPTION_PKT:
+		tcnt = s->exception_cnt;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_ds_stats_str[type], tcnt);
 
-/*
- * Spinlock to protect GRE redirect lag ds statistics update/read
- */
-DEFINE_SPINLOCK(nss_gre_redir_lag_ds_stats_lock);
-
-extern struct nss_gre_redir_lag_ds_tun_stats tun_ds_stats[NSS_GRE_REDIR_LAG_MAX_NODE];
-
-/*
- * nss_gre_redir_lag_ds_stats_get()
- *	Get statistics for downstream LAG node.
- */
-bool nss_gre_redir_lag_ds_stats_get(struct nss_gre_redir_lag_ds_tun_stats *cmn_stats, uint32_t index)
-{
-	if (index >= NSS_GRE_REDIR_LAG_MAX_NODE)
-		return false;
-
-	spin_lock_bh(&nss_gre_redir_lag_ds_stats_lock);
-	if (!tun_ds_stats[index].valid) {
-		spin_unlock_bh(&nss_gre_redir_lag_ds_stats_lock);
-		return false;
+	default:
+		return 0;
 	}
-
-	memcpy((void *)cmn_stats, (void *)&tun_ds_stats[index], sizeof(*cmn_stats));
-	spin_unlock_bh(&nss_gre_redir_lag_ds_stats_lock);
-	return true;
 }
 
 /*
@@ -57,45 +88,47 @@ bool nss_gre_redir_lag_ds_stats_get(stru
  */
 static ssize_t nss_gre_redir_lag_ds_cmn_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
 {
-	/*
-	 * Max output lines = #stats +
-	 * few blank lines for banner printing + Number of Extra outputlines
-	 * for future reference to add new stats
-	 */
-	uint32_t max_output_lines = NSS_GRE_REDIR_LAG_DS_STATS_MAX + NSS_STATS_EXTRA_OUTPUT_LINES;
-	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
+	ssize_t bytes_read = 0;
 	struct nss_stats_data *data = fp->private_data;
 	struct nss_gre_redir_lag_ds_tun_stats stats;
-	ssize_t bytes_read = 0;
-	size_t size_wr = 0;
-
-	char *lbuf = kzalloc(size_al, GFP_KERNEL);
-	if (unlikely(!lbuf)) {
-		nss_warning("Could not allocate memory for local statistics buffer");
-		return 0;
-	}
+	size_t bytes;
+	char line[80];
+	int start;
 
 	while (data->index < NSS_GRE_REDIR_LAG_MAX_NODE) {
-		if (nss_gre_redir_lag_ds_stats_get(&stats, data->index)) {
+		if (nss_gre_redir_lag_ds_get_cmn_stats(&stats, data->index)) {
 			break;
 		}
 
 		data->index++;
 	}
 
-	if (data->index >= NSS_GRE_REDIR_LAG_MAX_NODE) {
-		kfree(lbuf);
+	if (data->index == NSS_GRE_REDIR_LAG_MAX_NODE) {
 		return 0;
 	}
 
-	size_wr += nss_stats_banner(lbuf, size_wr, size_al, "gre_redir_lag_ds stats", NSS_STATS_SINGLE_CORE);
-	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\nTunnel stats for %03u\n", stats.ifnum);
-	size_wr += nss_stats_print("gre_redir_lag_ds", NULL, NSS_STATS_SINGLE_INSTANCE, nss_gre_redir_lag_ds_strings_stats,
-					&stats.rx_packets, NSS_GRE_REDIR_LAG_DS_STATS_MAX, lbuf, size_wr, size_al);
+	bytes = snprintf(line, sizeof(line), "\nTunnel stats for \n");
+	if (copy_to_user(ubuf, line, bytes) != 0) {
+		return -EFAULT;
+	}
+
+	bytes_read += bytes;
+	start = NSS_STATS_NODE_RX_PKTS;
+	while (bytes_read < sz && start < NSS_GRE_REDIR_LAG_DS_STATS_MAX) {
+		bytes = nss_gre_redir_lag_ds_cmn_stats_read_entry(line, sizeof(line), start, &stats);
+
+		if ((bytes_read + bytes) > sz)
+			break;
+
+		if (copy_to_user(ubuf + bytes_read, line, bytes) != 0) {
+			return -EFAULT;
+		}
+
+		bytes_read += bytes;
+		start++;
+	}
 
-	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
 	data->index++;
-	kfree(lbuf);
 	return bytes_read;
 }
 
@@ -128,84 +161,3 @@ struct dentry *nss_gre_redir_lag_ds_stat
 
 	return cmn_stats;
 }
-
-/*
- * nss_gre_redir_lag_ds_stats_sync()
- *	Update synchonized statistics.
- */
-void nss_gre_redir_lag_ds_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_gre_redir_lag_ds_sync_stats_msg *ngss, uint32_t ifnum)
-{
-	int idx, j;
-
-	spin_lock_bh(&nss_gre_redir_lag_ds_stats_lock);
-	if (!nss_gre_redir_lag_ds_get_node_idx(ifnum, &idx)) {
-		spin_unlock_bh(&nss_gre_redir_lag_ds_stats_lock);
-		nss_warning("%px: Unable to update hash stats msg. Stats context not found.\n", nss_ctx);
-		return;
-	}
-
-	tun_ds_stats[idx].tx_packets += ngss->node_stats.tx_packets;
-	tun_ds_stats[idx].tx_bytes += ngss->node_stats.tx_bytes;
-	tun_ds_stats[idx].rx_packets += ngss->node_stats.rx_packets;
-	tun_ds_stats[idx].rx_bytes += ngss->node_stats.rx_bytes;
-	for (j = 0; j < NSS_MAX_NUM_PRI; j++) {
-		tun_ds_stats[idx].rx_dropped[j] += ngss->node_stats.rx_dropped[j];
-	}
-
-	tun_ds_stats[idx].dst_invalid += ngss->ds_stats.dst_invalid;
-	tun_ds_stats[idx].exception_cnt += ngss->ds_stats.exception_cnt;
-	spin_unlock_bh(&nss_gre_redir_lag_ds_stats_lock);
-}
-
-/*
- * nss_gre_redir_lag_ds_stats_notify()
- *	Sends notifications to all the registered modules.
- *
- * Leverage NSS-FW statistics timing to update Netlink.
- */
-void nss_gre_redir_lag_ds_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num)
-{
-	struct nss_gre_redir_lag_ds_stats_notification *stats_notify;
-	int idx;
-
-	stats_notify = kzalloc(sizeof(struct nss_gre_redir_lag_ds_stats_notification), GFP_ATOMIC);
-	if (!stats_notify) {
-		nss_warning("Unable to allocate memory for stats notification\n");
-		return;
-	}
-
-	spin_lock_bh(&nss_gre_redir_lag_ds_stats_lock);
-	if (!nss_gre_redir_lag_ds_get_node_idx(if_num, &idx)) {
-		spin_unlock_bh(&nss_gre_redir_lag_ds_stats_lock);
-		nss_warning("%px: Unable to update hash stats msg. Stats context not found.\n", nss_ctx);
-		kfree(stats_notify);
-		return;
-	}
-
-	stats_notify->core_id = nss_ctx->id;
-	stats_notify->if_num = if_num;
-	memcpy(&(stats_notify->stats_ctx), &(tun_ds_stats[idx]), sizeof(stats_notify->stats_ctx));
-	spin_unlock_bh(&nss_gre_redir_lag_ds_stats_lock);
-	atomic_notifier_call_chain(&nss_gre_redir_lag_ds_stats_notifier, NSS_STATS_EVENT_NOTIFY, stats_notify);
-	kfree(stats_notify);
-}
-
-/*
- * nss_gre_redir_lag_ds_stats_unregister_notifier()
- *	Deregisters statistics notifier.
- */
-int nss_gre_redir_lag_ds_stats_unregister_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_unregister(&nss_gre_redir_lag_ds_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_gre_redir_lag_ds_stats_unregister_notifier);
-
-/*
- * nss_gre_redir_lag_ds_stats_register_notifier()
- *	Registers statistics notifier.
- */
-int nss_gre_redir_lag_ds_stats_register_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_register(&nss_gre_redir_lag_ds_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_gre_redir_lag_ds_stats_register_notifier);
--- a/nss_gre_redir_lag_ds_stats.h
+++ b/nss_gre_redir_lag_ds_stats.h
@@ -1,6 +1,6 @@
 /*
- **************************************************************************
- * Copyright (c) 2018, 2021, The Linux Foundation. All rights reserved.
+ ******************************************************************************
+ * Copyright (c) 2018, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -11,18 +11,20 @@
  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
  * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- * ************************************************************************
+ * ****************************************************************************
  */
 
 #ifndef __NSS_GRE_REDIR_LAG_DS_STATS_H__
 #define __NSS_GRE_REDIR_LAG_DS_STATS_H__
 
-extern spinlock_t nss_gre_redir_lag_ds_stats_lock;
-extern void nss_gre_redir_lag_ds_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num);
-extern bool nss_gre_redir_lag_ds_verify_ifnum(uint32_t if_num);
-extern bool nss_gre_redir_lag_ds_get_node_idx(uint32_t ifnum, uint32_t *idx);
-extern void nss_gre_redir_lag_ds_stats_sync(struct nss_ctx_instance *nss_ctx,
-					struct nss_gre_redir_lag_ds_sync_stats_msg *ngss, uint32_t ifnum);
-extern struct dentry *nss_gre_redir_lag_ds_stats_dentry_create(void);
+/*
+ * GRE redirect LAG downstream statistics
+ */
+enum nss_gre_redir_lag_ds_stats_types {
+	NSS_GRE_REDIR_LAG_DS_STATS_DST_INVALID = NSS_STATS_NODE_MAX,
+	NSS_GRE_REDIR_LAG_DS_STATS_EXCEPTION_PKT,
+	NSS_GRE_REDIR_LAG_DS_STATS_MAX,
+};
 
+extern struct dentry *nss_gre_redir_lag_ds_stats_dentry_create(void);
 #endif
--- a/nss_gre_redir_lag_ds_strings.c
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- ***************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ***************************************************************************
- */
-
-#include "nss_stats.h"
-#include "nss_core.h"
-#include "nss_strings.h"
-#include "nss_gre_redir_lag_ds_strings.h"
-
-/*
- * nss_gre_redir_lag_ds_strings_stats
- *	GRE REDIR LAG DS common statistics strings.
- */
-struct nss_stats_info nss_gre_redir_lag_ds_strings_stats[NSS_GRE_REDIR_LAG_DS_STATS_MAX] = {
-	{"rx_packets",		NSS_STATS_TYPE_COMMON},
-	{"rx_bytes",		NSS_STATS_TYPE_COMMON},
-	{"tx_packets",		NSS_STATS_TYPE_COMMON},
-	{"tx_bytes",		NSS_STATS_TYPE_COMMON},
-	{"rx_dropped_0",	NSS_STATS_TYPE_DROP},
-	{"rx_dropped_1",	NSS_STATS_TYPE_DROP},
-	{"rx_dropped_2",	NSS_STATS_TYPE_DROP},
-	{"rx_dropped_3",	NSS_STATS_TYPE_DROP},
-	{"dst_invalid",		NSS_STATS_TYPE_EXCEPTION},
-	{"exception_packets",	NSS_STATS_TYPE_SPECIAL}
-};
-
-/*
- * nss_gre_redir_lag_ds_strings_read()
- *	Read gre_redir_lag_ds statistics names
- */
-static ssize_t nss_gre_redir_lag_ds_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_gre_redir_lag_ds_strings_stats, NSS_GRE_REDIR_LAG_DS_STATS_MAX);
-}
-
-/*
- * nss_gre_redir_lag_ds_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(gre_redir_lag_ds);
-
-/*
- * nss_gre_redir_lag_ds_strings_dentry_create()
- *	Create gre_redir_lag_ds statistics strings debug entry.
- */
-void nss_gre_redir_lag_ds_strings_dentry_create(void)
-{
-	nss_strings_create_dentry("gre_redir_lag_ds", &nss_gre_redir_lag_ds_strings_ops);
-}
--- a/nss_gre_redir_lag_ds_strings.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- ***************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ***************************************************************************
- */
-
-#ifndef __NSS_GRE_REDIR_LAG_DS_STRINGS_H
-#define __NSS_GRE_REDIR_LAG_DS_STRINGS_H
-
-#include "nss_gre_redir_lag_ds_stats.h"
-
-extern struct nss_stats_info nss_gre_redir_lag_ds_strings_stats[NSS_GRE_REDIR_LAG_DS_STATS_MAX];
-extern void nss_gre_redir_lag_ds_strings_dentry_create(void);
-
-#endif /* __NSS_GRE_REDIR_LAG_DS_STRINGS_H */
--- a/nss_gre_redir_lag_us.c
+++ b/nss_gre_redir_lag_us.c
@@ -1,6 +1,6 @@
 /*
- ****************************************************************************
- * Copyright (c) 2018, 2020-2021, The Linux Foundation. All rights reserved.
+ **************************************************************************
+ * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -11,19 +11,39 @@
  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
  * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ****************************************************************************
+ **************************************************************************
  */
 
 #include "nss_tx_rx_common.h"
 #include "nss_gre_redir_lag_us_stats.h"
 #include "nss_gre_redir_lag_us_log.h"
-#include "nss_gre_redir_lag_us_strings.h"
 
 #define NSS_GRE_REDIR_LAG_US_TX_TIMEOUT 3000 /* 3 Seconds */
 #define NSS_GRE_REDIR_LAG_US_STATS_SYNC_PERIOD msecs_to_jiffies(4000)
 #define NSS_GRE_REDIR_LAG_US_STATS_SYNC_UDELAY 4000
 
-struct nss_gre_redir_lag_us_cmn_ctx cmn_ctx;
+/*
+ * nss_gre_redir_lag_us_pvt_sync_stats
+ *	Hash statistics synchronization context.
+ */
+struct nss_gre_redir_lag_us_pvt_sync_stats {
+	struct delayed_work nss_gre_redir_lag_us_work;			/**< Delayed work per LAG US node. */
+	struct nss_gre_redir_lag_us_msg db_sync_msg;			/**< Hash statistics message. */
+	struct nss_gre_redir_lag_us_tunnel_stats tun_stats;		/**< GRE redirect LAG common statistics. */
+	nss_gre_redir_lag_us_msg_callback_t cb;				/**< Callback for hash query message. */
+	void *app_data;							/**< app_data for hash query message. */
+	uint32_t ifnum;							/**< NSS interface number. */
+	bool valid;							/**< Valid flag. */
+};
+
+/*
+ * Common context for stats update.
+ */
+static struct nss_gre_redir_lag_us_cmn_ctx {
+	spinlock_t nss_gre_redir_lag_us_stats_lock;			/**< Spin lock. */
+	struct workqueue_struct *nss_gre_redir_lag_us_wq;		/**< Work queue. */
+	struct nss_gre_redir_lag_us_pvt_sync_stats stats_ctx[NSS_GRE_REDIR_LAG_MAX_NODE];
+} cmn_ctx;
 
 /*
  * Sync response context.
@@ -63,6 +83,61 @@ static void nss_gre_redir_lag_us_callbac
 }
 
 /*
+ * nss_gre_redir_lag_us_get_node_idx()
+ *	Returns index of statistics context.
+ */
+static bool nss_gre_redir_lag_us_get_node_idx(uint32_t ifnum, uint32_t *idx)
+{
+	uint32_t node_idx;
+	for (node_idx = 0; node_idx < NSS_GRE_REDIR_LAG_MAX_NODE; node_idx++) {
+		if ((cmn_ctx.stats_ctx[node_idx].valid) && (cmn_ctx.stats_ctx[node_idx].ifnum == ifnum)) {
+			*idx = node_idx;
+			return true;
+		}
+	}
+
+	return false;
+}
+
+/*
+ * nss_gre_redir_lag_us_update_sync_stats()
+ *	Update synchonized statistics.
+ */
+static void nss_gre_redir_lag_us_update_sync_stats(struct nss_ctx_instance *nss_ctx, struct nss_gre_redir_lag_us_cmn_sync_stats_msg *ngss,
+		uint32_t ifnum)
+{
+	int idx, j;
+
+	spin_lock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
+	if (!nss_gre_redir_lag_us_get_node_idx(ifnum, &idx)) {
+		spin_unlock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
+		nss_warning("%px: Unable to update hash stats msg. Stats context not found.\n", nss_ctx);
+		return;
+	}
+
+	cmn_ctx.stats_ctx[idx].tun_stats.tx_packets += ngss->node_stats.tx_packets;
+	cmn_ctx.stats_ctx[idx].tun_stats.tx_bytes += ngss->node_stats.tx_bytes;
+	cmn_ctx.stats_ctx[idx].tun_stats.rx_packets += ngss->node_stats.rx_packets;
+	cmn_ctx.stats_ctx[idx].tun_stats.rx_bytes += ngss->node_stats.rx_bytes;
+	for (j = 0; j < NSS_MAX_NUM_PRI; j++) {
+		cmn_ctx.stats_ctx[idx].tun_stats.rx_dropped[j] += ngss->node_stats.rx_dropped[j];
+	}
+	cmn_ctx.stats_ctx[idx].tun_stats.us_stats.amsdu_pkts += ngss->us_stats.amsdu_pkts;
+	cmn_ctx.stats_ctx[idx].tun_stats.us_stats.amsdu_pkts_enqueued += ngss->us_stats.amsdu_pkts_enqueued;
+	cmn_ctx.stats_ctx[idx].tun_stats.us_stats.amsdu_pkts_exceptioned += ngss->us_stats.amsdu_pkts_exceptioned;
+	cmn_ctx.stats_ctx[idx].tun_stats.us_stats.exceptioned += ngss->us_stats.exceptioned;
+	cmn_ctx.stats_ctx[idx].tun_stats.us_stats.freed += ngss->us_stats.freed;
+	cmn_ctx.stats_ctx[idx].tun_stats.db_stats.add_attempt += ngss->db_stats.add_attempt;
+	cmn_ctx.stats_ctx[idx].tun_stats.db_stats.add_success += ngss->db_stats.add_success;
+	cmn_ctx.stats_ctx[idx].tun_stats.db_stats.add_fail_table_full += ngss->db_stats.add_fail_table_full;
+	cmn_ctx.stats_ctx[idx].tun_stats.db_stats.add_fail_exists += ngss->db_stats.add_fail_exists;
+	cmn_ctx.stats_ctx[idx].tun_stats.db_stats.del_attempt += ngss->db_stats.del_attempt;
+	cmn_ctx.stats_ctx[idx].tun_stats.db_stats.del_success += ngss->db_stats.del_success;
+	cmn_ctx.stats_ctx[idx].tun_stats.db_stats.del_fail_not_found += ngss->db_stats.del_fail_not_found;
+	spin_unlock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
+}
+
+/*
  * nss_gre_redir_lag_us_hash_update_stats_req()
  *	Update query hash message's index for next request.
  */
@@ -92,14 +167,25 @@ static void nss_gre_redir_lag_us_hash_up
 	 * If more hash entries are to be fetched from FW, queue work with delay of one eighth of
 	 * the polling period. Else, schedule work with a delay of polling period.
 	 */
-	if (cmn_ctx.stats_ctx[idx].db_sync_msg.msg.hash_stats.db_entry_idx)
+	if (cmn_ctx.stats_ctx[idx].db_sync_msg.msg.hash_stats.db_entry_idx) {
 		sync_delay = NSS_GRE_REDIR_LAG_US_STATS_SYNC_PERIOD / 8;
+	}
 
-	queue_delayed_work(cmn_ctx.nss_gre_redir_lag_us_wq, &(cmn_ctx.stats_ctx[idx].nss_gre_redir_lag_us_work), sync_delay);
+	queue_delayed_work(cmn_ctx.nss_gre_redir_lag_us_wq, &(cmn_ctx.stats_ctx[idx].nss_gre_redir_lag_us_work),
+				sync_delay);
 	spin_unlock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
 }
 
 /*
+ * nss_gre_redir_lag_us_verify_ifnum()
+ *	Verify interface type.
+ */
+static bool nss_gre_redir_lag_us_verify_ifnum(uint32_t if_num)
+{
+	return nss_dynamic_interface_get_type(nss_gre_redir_lag_us_get_context(), if_num) == NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_LAG_US;
+}
+
+/*
  * nss_gre_redir_lag_us_handler()
  *	Handle NSS -> HLOS messages for gre tunnel
  */
@@ -138,7 +224,7 @@ static void nss_gre_redir_lag_us_msg_han
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
 		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
-		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[ncm->interface].app_data;
+		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[nss_ctx->id][ncm->interface].app_data;
 	}
 
 	/*
@@ -148,8 +234,7 @@ static void nss_gre_redir_lag_us_msg_han
 
 	switch (ncm->type) {
 	case NSS_GRE_REDIR_LAG_US_CMN_STATS_SYNC_MSG:
-		nss_gre_redir_lag_us_stats_sync(nss_ctx, &ngrm->msg.us_sync_stats, ncm->interface);
-		nss_gre_redir_lag_us_stats_notify(nss_ctx, ncm->interface);
+		nss_gre_redir_lag_us_update_sync_stats(nss_ctx, &ngrm->msg.us_sync_stats, ncm->interface);
 		break;
 
 	case NSS_GRE_REDIR_LAG_US_DB_HASH_NODE_MSG:
@@ -429,32 +514,6 @@ static struct nss_ctx_instance *nss_gre_
 }
 
 /*
- * nss_gre_redir_lag_us_get_node_idx()
- *	Returns index of statistics context.
- */
-bool nss_gre_redir_lag_us_get_node_idx(uint32_t ifnum, uint32_t *idx)
-{
-	uint32_t node_idx;
-	for (node_idx = 0; node_idx < NSS_GRE_REDIR_LAG_MAX_NODE; node_idx++) {
-		if ((cmn_ctx.stats_ctx[node_idx].valid) && (cmn_ctx.stats_ctx[node_idx].ifnum == ifnum)) {
-			*idx = node_idx;
-			return true;
-		}
-	}
-
-	return false;
-}
-
-/*
- * nss_gre_redir_lag_us_verify_ifnum()
- *	Verify interface type.
- */
-bool nss_gre_redir_lag_us_verify_ifnum(uint32_t if_num)
-{
-	return nss_dynamic_interface_get_type(nss_gre_redir_lag_us_get_context(), if_num) == NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_LAG_US;
-}
-
-/*
  * nss_gre_redir_lag_us_get_context()
  *	Retrieve context for GRE redirect LAG upstream node.
  */
@@ -547,6 +606,29 @@ bool nss_gre_redir_lag_us_configure_node
 EXPORT_SYMBOL(nss_gre_redir_lag_us_configure_node);
 
 /*
+ * nss_gre_redir_lag_us_get_cmn_stats()
+ *	Common upstream statistics.
+ */
+bool nss_gre_redir_lag_us_get_cmn_stats(struct nss_gre_redir_lag_us_tunnel_stats *cmn_stats, uint32_t index)
+{
+	if (index >= NSS_GRE_REDIR_LAG_MAX_NODE) {
+		nss_warning("Index is out of valid range %u\n", index);
+		return false;
+	}
+
+	spin_lock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
+	if (!cmn_ctx.stats_ctx[index].valid) {
+		spin_unlock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
+		nss_warning("Common context not found for the index %u\n", index);
+		return false;
+	}
+
+	memcpy((void *)cmn_stats, (void *)&(cmn_ctx.stats_ctx[index].tun_stats), sizeof(*cmn_stats));
+	spin_unlock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
+	return true;
+}
+
+/*
  * nss_gre_redir_lag_us_tx_msg()
  *	Transmit a GRE LAG message to NSS firmware asynchronously.
  */
@@ -656,7 +738,6 @@ void nss_gre_redir_lag_us_register_handl
 		return;
 	}
 
-	nss_gre_redir_lag_us_strings_dentry_create();
 	nss_gre_redir_lag_us_sync_ctx.cb = NULL;
 	nss_gre_redir_lag_us_sync_ctx.app_data = NULL;
 	sema_init(&nss_gre_redir_lag_us_sync_ctx.sem, 1);
--- a/nss_gre_redir_lag_us_stats.c
+++ b/nss_gre_redir_lag_us_stats.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, 2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -17,39 +17,109 @@
 #include "nss_core.h"
 #include "nss_gre_redir_lag.h"
 #include "nss_gre_redir_lag_us_stats.h"
-#include "nss_gre_redir_lag_us_strings.h"
-
-#define NSS_GRE_REDIR_LAG_US_STATS_SYNC_PERIOD msecs_to_jiffies(4000)
-#define NSS_GRE_REDIR_LAG_US_STATS_SYNC_UDELAY 4000
-
-/*
- * Declare atomic notifier data structure for statistics.
- */
-ATOMIC_NOTIFIER_HEAD(nss_gre_redir_lag_us_stats_notifier);
-
-extern struct nss_gre_redir_lag_us_cmn_ctx cmn_ctx;
 
 /*
- * nss_gre_redir_lag_us_stats_get
- *	Get the common upstream statistics.
+ * nss_gre_redir_lag_us_stats_str
+ *	GRE REDIR LAG US common statistics strings.
  */
-bool nss_gre_redir_lag_us_stats_get(struct nss_gre_redir_lag_us_tunnel_stats *cmn_stats, uint32_t index)
-{
-	if (index >= NSS_GRE_REDIR_LAG_MAX_NODE) {
-		nss_warning("Index is out of valid range %u\n", index);
-		return false;
-	}
-
-	spin_lock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
-	if (!cmn_ctx.stats_ctx[index].valid) {
-		spin_unlock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
-		nss_warning("Common context not found for the index %u\n", index);
-		return false;
+static uint8_t *nss_gre_redir_lag_us_stats_str[NSS_GRE_REDIR_LAG_US_STATS_MAX] = {
+	"rx_packets",
+	"rx_bytes",
+	"tx_packets",
+	"tx_bytes",
+	"rx_queue_0_dropped",
+	"rx_queue_1_dropped",
+	"rx_queue_2_dropped",
+	"rx_queue_3_dropped",
+	"Amsdu pkts",
+	"Amsdu pkts enqueued",
+	"Amsdu pkts exceptioned",
+	"Exceptioned",
+	"Freed",
+	"add attempt",
+	"add success",
+	"add fail table full",
+	"add fail exists",
+	"del attempt",
+	"del success",
+	"del fail not found",
+};
+
+/*
+ * nss_gre_redir_lag_us_tunnel_stats()
+ *	Make a row for GRE_REDIR LAG US stats.
+ */
+static ssize_t nss_gre_redir_lag_us_cmn_stats_read_entry(char *line, int len, int type, struct nss_gre_redir_lag_us_tunnel_stats *s)
+{
+	uint64_t tcnt = 0;
+
+	switch (type) {
+	case NSS_STATS_NODE_RX_PKTS:
+		tcnt = s->rx_packets;
+		return snprintf(line, len, "Common node stats start:\n\n%s = %llu\n", nss_gre_redir_lag_us_stats_str[type], tcnt);
+	case NSS_STATS_NODE_RX_BYTES:
+		tcnt = s->rx_bytes;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_us_stats_str[type], tcnt);
+	case NSS_STATS_NODE_TX_PKTS:
+		tcnt = s->tx_packets;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_us_stats_str[type], tcnt);
+	case NSS_STATS_NODE_TX_BYTES:
+		tcnt = s->tx_bytes;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_us_stats_str[type], tcnt);
+	case NSS_STATS_NODE_RX_QUEUE_0_DROPPED:
+		tcnt = s->rx_dropped[0];
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_us_stats_str[type], tcnt);
+#if (NSS_MAX_NUM_PRI > 1)
+	case NSS_STATS_NODE_RX_QUEUE_1_DROPPED:
+		tcnt = s->rx_dropped[1];
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_us_stats_str[type], tcnt);
+	case NSS_STATS_NODE_RX_QUEUE_2_DROPPED:
+		tcnt = s->rx_dropped[2];
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_us_stats_str[type], tcnt);
+	case NSS_STATS_NODE_RX_QUEUE_3_DROPPED:
+		tcnt = s->rx_dropped[3];
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_us_stats_str[type], tcnt);
+#endif
+	case NSS_GRE_REDIR_LAG_US_STATS_AMSDU_PKTS:
+		tcnt = s->us_stats.amsdu_pkts;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_us_stats_str[type], tcnt);
+	case NSS_GRE_REDIR_LAG_US_STATS_AMSDU_PKTS_ENQUEUED:
+		tcnt = s->us_stats.amsdu_pkts_enqueued;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_us_stats_str[type], tcnt);
+	case NSS_GRE_REDIR_LAG_US_STATS_AMSDU_PKTS_EXCEPTIONED:
+		tcnt = s->us_stats.amsdu_pkts_exceptioned;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_us_stats_str[type], tcnt);
+	case NSS_GRE_REDIR_LAG_US_STATS_EXCEPTIONED:
+		tcnt = s->us_stats.exceptioned;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_us_stats_str[type], tcnt);
+	case NSS_GRE_REDIR_LAG_US_STATS_FREED:
+		tcnt = s->us_stats.freed;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_us_stats_str[type], tcnt);
+	case NSS_GRE_REDIR_LAG_US_STATS_ADD_ATTEMPT:
+		tcnt = s->db_stats.add_attempt;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_us_stats_str[type], tcnt);
+	case NSS_GRE_REDIR_LAG_US_STATS_ADD_SUCCESS:
+		tcnt = s->db_stats.add_success;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_us_stats_str[type], tcnt);
+	case NSS_GRE_REDIR_LAG_US_STATS_ADD_FAIL_TABLE_FULL:
+		tcnt = s->db_stats.add_fail_table_full;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_us_stats_str[type], tcnt);
+	case NSS_GRE_REDIR_LAG_US_STATS_ADD_FAIL_EXISTS:
+		tcnt = s->db_stats.add_fail_exists;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_us_stats_str[type], tcnt);
+	case NSS_GRE_REDIR_LAG_US_STATS_DEL_ATTEMPT:
+		tcnt = s->db_stats.del_attempt;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_us_stats_str[type], tcnt);
+	case NSS_GRE_REDIR_LAG_US_STATS_DEL_SUCCESS:
+		tcnt = s->db_stats.del_success;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_us_stats_str[type], tcnt);
+	case NSS_GRE_REDIR_LAG_US_STATS_DEL_FAIL_NOT_FOUND:
+		tcnt = s->db_stats.del_fail_not_found;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_lag_us_stats_str[type], tcnt);
+	default:
+		nss_warning("Unknown tunnel stats type.\n");
+		return 0;
 	}
-
-	memcpy((void *)cmn_stats, (void *)&(cmn_ctx.stats_ctx[index].tun_stats), sizeof(*cmn_stats));
-	spin_unlock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
-	return true;
 }
 
 /*
@@ -58,26 +128,15 @@ bool nss_gre_redir_lag_us_stats_get(stru
  */
 static ssize_t nss_gre_redir_lag_us_cmn_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
 {
-	/*
-	 * Max output lines = #stats +
-	 * few blank lines for banner printing + Number of Extra outputlines
-	 * for future reference to add new stats
-	 */
-	uint32_t max_output_lines = NSS_GRE_REDIR_LAG_US_STATS_MAX + NSS_STATS_EXTRA_OUTPUT_LINES;
-	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
+	ssize_t bytes_read = 0;
 	struct nss_stats_data *data = fp->private_data;
 	struct nss_gre_redir_lag_us_tunnel_stats stats;
-	ssize_t bytes_read = 0;
-	size_t size_wr = 0;
-
-	char *lbuf = kzalloc(size_al, GFP_KERNEL);
-	if (unlikely(!lbuf)) {
-		nss_warning("Could not allocate memory for local statistics buffer");
-		return 0;
-	}
+	size_t bytes;
+	char line[80];
+	int start;
 
 	while (data->index < NSS_GRE_REDIR_LAG_MAX_NODE) {
-		if (nss_gre_redir_lag_us_stats_get(&stats, data->index)) {
+		if (nss_gre_redir_lag_us_get_cmn_stats(&stats, data->index)) {
 			break;
 		}
 
@@ -85,17 +144,31 @@ static ssize_t nss_gre_redir_lag_us_cmn_
 	}
 
 	if (data->index == NSS_GRE_REDIR_LAG_MAX_NODE) {
-		kfree(lbuf);
 		return 0;
 	}
 
-	size_wr += nss_stats_banner(lbuf, size_wr, size_al, "gre_redir_lag_us stats", NSS_STATS_SINGLE_CORE);
-	size_wr += nss_stats_print("gre_redir_lag_us", NULL, NSS_STATS_SINGLE_INSTANCE, nss_gre_redir_lag_us_strings_stats,
-					&stats.rx_packets, NSS_GRE_REDIR_LAG_US_STATS_MAX, lbuf, size_wr, size_al);
+	bytes = snprintf(line, sizeof(line), "\nTunnel stats");
+	if (copy_to_user(ubuf, line, bytes) != 0) {
+		return -EFAULT;
+	}
+
+	bytes_read += bytes;
+	start = NSS_STATS_NODE_RX_PKTS;
+	while (bytes_read < sz && start <= NSS_GRE_REDIR_LAG_US_STATS_DEL_FAIL_NOT_FOUND) {
+		bytes = nss_gre_redir_lag_us_cmn_stats_read_entry(line, sizeof(line), start, &stats);
+		if ((bytes_read + bytes) > sz) {
+			break;
+		}
+
+		if (copy_to_user(ubuf + bytes_read, line, bytes) != 0) {
+			return -EFAULT;
+		}
+
+		bytes_read += bytes;
+		start++;
+	}
 
-	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
 	data->index++;
-	kfree(lbuf);
 	return bytes_read;
 }
 
@@ -128,99 +201,3 @@ struct dentry *nss_gre_redir_lag_us_stat
 
 	return cmn_stats;
 }
-
-/*
- * nss_gre_redir_lag_us_stats_sync()
- *	Update synchonized statistics.
- */
-void nss_gre_redir_lag_us_stats_sync(struct nss_ctx_instance *nss_ctx,
-				struct nss_gre_redir_lag_us_cmn_sync_stats_msg *ngss, uint32_t ifnum)
-{
-	int idx, j;
-	struct nss_gre_redir_lag_us_tunnel_stats *node_stats;
-
-	spin_lock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
-	if (!nss_gre_redir_lag_us_get_node_idx(ifnum, &idx)) {
-		spin_unlock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
-		nss_warning("%px: Unable to update hash stats msg. Stats context not found.\n", nss_ctx);
-		return;
-	}
-
-	node_stats = &cmn_ctx.stats_ctx[idx].tun_stats;
-
-	node_stats->tx_packets += ngss->node_stats.tx_packets;
-	node_stats->tx_bytes += ngss->node_stats.tx_bytes;
-	node_stats->rx_packets += ngss->node_stats.rx_packets;
-	node_stats->rx_bytes += ngss->node_stats.rx_bytes;
-	for (j = 0; j < NSS_MAX_NUM_PRI; j++) {
-		node_stats->rx_dropped[j] += ngss->node_stats.rx_dropped[j];
-	}
-
-	node_stats->us_stats.amsdu_pkts += ngss->us_stats.amsdu_pkts;
-	node_stats->us_stats.amsdu_pkts_enqueued += ngss->us_stats.amsdu_pkts_enqueued;
-	node_stats->us_stats.amsdu_pkts_exceptioned += ngss->us_stats.amsdu_pkts_exceptioned;
-	node_stats->us_stats.exceptioned += ngss->us_stats.exceptioned;
-	node_stats->us_stats.freed += ngss->us_stats.freed;
-	node_stats->db_stats.add_attempt += ngss->db_stats.add_attempt;
-	node_stats->db_stats.add_success += ngss->db_stats.add_success;
-	node_stats->db_stats.add_fail_table_full += ngss->db_stats.add_fail_table_full;
-	node_stats->db_stats.add_fail_exists += ngss->db_stats.add_fail_exists;
-	node_stats->db_stats.del_attempt += ngss->db_stats.del_attempt;
-	node_stats->db_stats.del_success += ngss->db_stats.del_success;
-	node_stats->db_stats.del_fail_not_found += ngss->db_stats.del_fail_not_found;
-	spin_unlock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
-}
-
-/*
- * nss_gre_redir_lag_us_stats_notify()
- *	Sends notifications to all the registered modules.
- *
- * Leverage NSS-FW statistics timing to update Netlink.
- */
-void nss_gre_redir_lag_us_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num)
-{
-	struct nss_gre_redir_lag_us_stats_notification *stats_notify;
-	int idx;
-
-	stats_notify = kzalloc(sizeof(struct nss_gre_redir_lag_us_stats_notification), GFP_ATOMIC);
-	if (!stats_notify) {
-		nss_warning("Unable to allocate memory for stats notification\n");
-		return;
-	}
-
-	spin_lock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
-	if (!nss_gre_redir_lag_us_get_node_idx(if_num, &idx)) {
-		spin_unlock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
-		nss_warning("%px: Unable to update hash stats msg. Stats context not found.\n", nss_ctx);
-		kfree(stats_notify);
-		return;
-	}
-
-	stats_notify->core_id = nss_ctx->id;
-	stats_notify->if_num = if_num;
-	memcpy(&(stats_notify->stats_ctx), &(cmn_ctx.stats_ctx[idx].tun_stats), sizeof(stats_notify->stats_ctx));
-	spin_unlock_bh(&cmn_ctx.nss_gre_redir_lag_us_stats_lock);
-	atomic_notifier_call_chain(&nss_gre_redir_lag_us_stats_notifier, NSS_STATS_EVENT_NOTIFY, stats_notify);
-	kfree(stats_notify);
-}
-
-/*
- * nss_gre_redir_lag_us_stats_unregister_notifier()
- *	Deregisters statistics notifier.
- */
-int nss_gre_redir_lag_us_stats_unregister_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_unregister(&nss_gre_redir_lag_us_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_gre_redir_lag_us_stats_unregister_notifier);
-
-/*
- * nss_gre_redir_lag_us_stats_register_notifier()
- *	Registers statistics notifier.
- */
-int nss_gre_redir_lag_us_stats_register_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_register(&nss_gre_redir_lag_us_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_gre_redir_lag_us_stats_register_notifier);
-
--- a/nss_gre_redir_lag_us_stats.h
+++ b/nss_gre_redir_lag_us_stats.h
@@ -1,6 +1,6 @@
 /*
  ******************************************************************************
- * Copyright (c) 2018, 2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -18,33 +18,23 @@
 #define __NSS_GRE_REDIR_LAG_US_STATS_H__
 
 /*
- * nss_gre_redir_lag_us_pvt_sync_stats
- *	Hash statistics synchronization context.
+ * GRE redirect LAG upstream statistics
  */
-struct nss_gre_redir_lag_us_pvt_sync_stats {
-	struct delayed_work nss_gre_redir_lag_us_work;		/**< Delayed work per LAG US node. */
-	struct nss_gre_redir_lag_us_msg db_sync_msg;		/**< Hash statistics message. */
-	struct nss_gre_redir_lag_us_tunnel_stats tun_stats;	/**< GRE redirect LAG common statistics. */
-	nss_gre_redir_lag_us_msg_callback_t cb;			/**< Callback for hash query message. */
-	void *app_data;						/**< app_data for hash query message. */
-	uint32_t ifnum;						/**< NSS interface number. */
-	bool valid;						/**< Valid flag. */
+enum nss_gre_redir_lag_us_stats_types {
+	NSS_GRE_REDIR_LAG_US_STATS_AMSDU_PKTS = NSS_STATS_NODE_MAX,
+	NSS_GRE_REDIR_LAG_US_STATS_AMSDU_PKTS_ENQUEUED,
+	NSS_GRE_REDIR_LAG_US_STATS_AMSDU_PKTS_EXCEPTIONED,
+	NSS_GRE_REDIR_LAG_US_STATS_EXCEPTIONED,
+	NSS_GRE_REDIR_LAG_US_STATS_FREED,
+	NSS_GRE_REDIR_LAG_US_STATS_ADD_ATTEMPT,
+	NSS_GRE_REDIR_LAG_US_STATS_ADD_SUCCESS,
+	NSS_GRE_REDIR_LAG_US_STATS_ADD_FAIL_TABLE_FULL,
+	NSS_GRE_REDIR_LAG_US_STATS_ADD_FAIL_EXISTS,
+	NSS_GRE_REDIR_LAG_US_STATS_DEL_ATTEMPT,
+	NSS_GRE_REDIR_LAG_US_STATS_DEL_SUCCESS,
+	NSS_GRE_REDIR_LAG_US_STATS_DEL_FAIL_NOT_FOUND,
+	NSS_GRE_REDIR_LAG_US_STATS_MAX,
 };
 
-/*
- * Common context for stats update.
- */
-struct nss_gre_redir_lag_us_cmn_ctx {
-	struct workqueue_struct *nss_gre_redir_lag_us_wq;		/**< Work queue. */
-	spinlock_t nss_gre_redir_lag_us_stats_lock;			/**< Spin lock. */
-	struct nss_gre_redir_lag_us_pvt_sync_stats stats_ctx[NSS_GRE_REDIR_LAG_MAX_NODE];
-};
-
-extern void nss_gre_redir_lag_us_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num);
-extern bool nss_gre_redir_lag_us_get_node_idx(uint32_t ifnum, uint32_t *idx);
-extern bool nss_gre_redir_lag_us_verify_ifnum(uint32_t if_num);
-extern void nss_gre_redir_lag_us_stats_sync(struct nss_ctx_instance *nss_ctx,
-					struct nss_gre_redir_lag_us_cmn_sync_stats_msg *ngss, uint32_t ifnum);
 extern struct dentry *nss_gre_redir_lag_us_stats_dentry_create(void);
-
 #endif
--- a/nss_gre_redir_lag_us_strings.c
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- ***************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ***************************************************************************
- */
-
-#include "nss_stats.h"
-#include "nss_core.h"
-#include "nss_strings.h"
-#include "nss_gre_redir_lag_us_strings.h"
-
-/*
- * nss_gre_redir_lag_us_strings_stats
- *	GRE REDIR LAG US common statistics strings.
- */
-struct nss_stats_info nss_gre_redir_lag_us_strings_stats[NSS_GRE_REDIR_LAG_US_STATS_MAX] = {
-	{"rx_packets",			NSS_STATS_TYPE_COMMON},
-	{"rx_bytes",			NSS_STATS_TYPE_COMMON},
-	{"tx_packets",			NSS_STATS_TYPE_COMMON},
-	{"tx_bytes",			NSS_STATS_TYPE_COMMON},
-	{"rx_dropped_0",		NSS_STATS_TYPE_DROP},
-	{"rx_dropped_1",		NSS_STATS_TYPE_DROP},
-	{"rx_dropped_2",		NSS_STATS_TYPE_DROP},
-	{"rx_dropped_3",		NSS_STATS_TYPE_DROP},
-	{"Amsdu pkts",			NSS_STATS_TYPE_SPECIAL},
-	{"Amsdu pkts enqueued",		NSS_STATS_TYPE_SPECIAL},
-	{"Amsdu pkts exceptioned",	NSS_STATS_TYPE_EXCEPTION},
-	{"Exceptioned",			NSS_STATS_TYPE_EXCEPTION},
-	{"Freed",			NSS_STATS_TYPE_SPECIAL},
-	{"add attempt",			NSS_STATS_TYPE_SPECIAL},
-	{"add success",			NSS_STATS_TYPE_SPECIAL},
-	{"add fail table full",		NSS_STATS_TYPE_SPECIAL},
-	{"add fail exists",		NSS_STATS_TYPE_SPECIAL},
-	{"del attempt",			NSS_STATS_TYPE_SPECIAL},
-	{"del success",			NSS_STATS_TYPE_SPECIAL},
-	{"del fail not found",		NSS_STATS_TYPE_SPECIAL}
-};
-
-/*
- * nss_gre_redir_lag_us_strings_read()
- *	Read gre_redir_lag_us statistics names
- */
-static ssize_t nss_gre_redir_lag_us_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_gre_redir_lag_us_strings_stats, NSS_GRE_REDIR_LAG_US_STATS_MAX);
-}
-
-/*
- * nss_gre_redir_lag_us_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(gre_redir_lag_us);
-
-/*
- * nss_gre_redir_lag_us_strings_dentry_create()
- *	Create gre_redir_lag_us statistics strings debug entry.
- */
-void nss_gre_redir_lag_us_strings_dentry_create(void)
-{
-	nss_strings_create_dentry("gre_redir_lag_us", &nss_gre_redir_lag_us_strings_ops);
-}
-
--- a/nss_gre_redir_lag_us_strings.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- ***************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ***************************************************************************
- */
-
-#ifndef __NSS_GRE_REDIR_LAG_US_STRINGS_H
-#define __NSS_GRE_REDIR_LAG_US_STRINGS_H
-
-#include "nss_gre_redir_lag_us_stats.h"
-
-extern struct nss_stats_info nss_gre_redir_lag_us_strings_stats[NSS_GRE_REDIR_LAG_US_STATS_MAX];
-extern void nss_gre_redir_lag_us_strings_dentry_create(void);
-
-#endif /* __NSS_GRE_REDIR_LAG_US_STRINGS_H */
--- a/nss_gre_redir_mark.c
+++ b/nss_gre_redir_mark.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -15,7 +15,6 @@
  */
 
 #include "nss_tx_rx_common.h"
-#include "nss_gre_redir_mark_strings.h"
 #include "nss_gre_redir_mark_stats.h"
 #include "nss_gre_redir_mark_log.h"
 #define NSS_GRE_REDIR_MARK_TX_TIMEOUT 3000 /* 3 Seconds */
@@ -30,6 +29,16 @@ static struct {
 } nss_gre_redir_mark_pvt;
 
 /*
+ * Spinlock to update GRE redir mark stats.
+ */
+static DEFINE_SPINLOCK(nss_gre_redir_mark_stats_lock);
+
+/*
+ * Global GRE redir mark stats structure.
+ */
+static struct nss_gre_redir_mark_stats gre_mark_stats;
+
+/*
  * nss_gre_redir_mark_msg_sync_callback()
  *	Callback to handle the completion of HLOS-->NSS messages.
  */
@@ -45,6 +54,54 @@ static void nss_gre_redir_mark_msg_sync_
 }
 
 /*
+ * nss_gre_redir_mark_stats_sync()
+ *	Update GRE redir mark stats.
+ */
+static void nss_gre_redir_mark_stats_sync(struct nss_ctx_instance *nss_ctx, int if_num, struct nss_gre_redir_mark_stats_sync_msg *ngss)
+{
+	struct net_device *dev;
+	dev = nss_cmn_get_interface_dev(nss_ctx, if_num);
+	if (!dev) {
+		nss_warning("%px: Unable to find net device for the interface %d\n", nss_ctx, if_num);
+		return;
+	}
+
+	if (if_num != NSS_GRE_REDIR_MARK_INTERFACE) {
+		nss_warning("%px: Unknown type for interface %d\n", nss_ctx, if_num);
+		return;
+	}
+
+	/*
+	 * Update the stats in exclusive mode to prevent the read from the process
+	 * context through debug fs.
+	 */
+	spin_lock_bh(&nss_gre_redir_mark_stats_lock);
+
+	/*
+	 * Update the common node stats
+	 */
+	gre_mark_stats.stats[NSS_GRE_REDIR_MARK_STATS_TX_PKTS] += ngss->node_stats.tx_packets;
+	gre_mark_stats.stats[NSS_GRE_REDIR_MARK_STATS_TX_BYTES] += ngss->node_stats.tx_bytes;
+	gre_mark_stats.stats[NSS_GRE_REDIR_MARK_STATS_RX_PKTS] += ngss->node_stats.rx_packets;
+	gre_mark_stats.stats[NSS_GRE_REDIR_MARK_STATS_RX_BYTES] += ngss->node_stats.rx_bytes;
+	gre_mark_stats.stats[NSS_GRE_REDIR_MARK_STATS_RX_DROPS] += nss_cmn_rx_dropped_sum(&(ngss->node_stats));
+
+	/*
+	 * Update the GRE redir mark specific stats
+	 */
+	gre_mark_stats.stats[NSS_GRE_REDIR_MARK_STATS_HLOS_MAGIC_FAILED] += ngss->hlos_magic_fail;
+	gre_mark_stats.stats[NSS_GRE_REDIR_MARK_STATS_INV_DST_IF_DROPS] += ngss->invalid_dst_drop;
+	gre_mark_stats.stats[NSS_GRE_REDIR_MARK_STATS_DST_IF_ENQUEUE] += ngss->dst_enqueue_success;
+	gre_mark_stats.stats[NSS_GRE_REDIR_MARK_STATS_DST_IF_ENQUEUE_DROPS] += ngss->dst_enqueue_drop;
+	gre_mark_stats.stats[NSS_GRE_REDIR_MARK_STATS_INV_APPID] += ngss->inv_appid;
+	gre_mark_stats.stats[NSS_GRE_REDIR_MARK_STATS_HEADROOM_UNAVAILABLE] += ngss->headroom_unavail;
+	gre_mark_stats.stats[NSS_GRE_REDIR_MARK_STATS_TX_COMPLETION_SUCCESS] += ngss->tx_completion_success;
+	gre_mark_stats.stats[NSS_GRE_REDIR_MARK_STATS_TX_COMPLETION_DROPS] += ngss->tx_completion_drop;
+
+	spin_unlock_bh(&nss_gre_redir_mark_stats_lock);
+}
+
+/*
  * nss_gre_redir_mark_handler()
  *	Handle NSS to HLOS messages for GRE redir mark
  */
@@ -80,7 +137,6 @@ static void nss_gre_redir_mark_handler(s
 
 	if (ncm->type == NSS_GRE_REDIR_MARK_STATS_SYNC_MSG) {
 		nss_gre_redir_mark_stats_sync(nss_ctx, ncm->interface, &ngrm->msg.stats_sync);
-		nss_gre_redir_mark_stats_notify(nss_ctx, ncm->interface);
 	}
 
 	/*
@@ -105,6 +161,28 @@ static void nss_gre_redir_mark_handler(s
 }
 
 /*
+ * nss_gre_redir_mark_get_stats()
+ *	Get gre_redir tunnel stats.
+ */
+bool nss_gre_redir_mark_get_stats(void *stats_mem)
+{
+	struct nss_gre_redir_mark_stats *stats = (struct nss_gre_redir_mark_stats *)stats_mem;
+	if (!stats) {
+		nss_warning("No memory to copy GRE redir mark stats");
+		return false;
+	}
+
+	/*
+	 * Copy the GRE redir mark stats in the memory.
+	 */
+	spin_lock_bh(&nss_gre_redir_mark_stats_lock);
+	memcpy(stats, &gre_mark_stats, sizeof(struct nss_gre_redir_mark_stats));
+	spin_unlock_bh(&nss_gre_redir_mark_stats_lock);
+	return true;
+}
+EXPORT_SYMBOL(nss_gre_redir_mark_get_stats);
+
+/*
  * nss_gre_redir_mark_reg_cb()
  *	Configure a callback on VAP.
  */
@@ -262,7 +340,7 @@ bool nss_gre_redir_mark_unregister_if(ui
 		return false;
 	}
 
-	nss_ctx->nss_rx_interface_handlers[if_num].msg_cb = NULL;
+	nss_ctx->nss_rx_interface_handlers[nss_ctx->id][if_num].msg_cb = NULL;
 	return true;
 }
 EXPORT_SYMBOL(nss_gre_redir_mark_unregister_if);
@@ -326,7 +404,6 @@ void nss_gre_redir_mark_register_handler
 		return;
 	}
 
-	nss_gre_redir_mark_strings_dentry_create();
 	sema_init(&nss_gre_redir_mark_pvt.sem, 1);
 	init_completion(&nss_gre_redir_mark_pvt.complete);
 
--- a/nss_gre_redir_mark_stats.c
+++ b/nss_gre_redir_mark_stats.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, 2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -18,64 +18,95 @@
 #include "nss_stats.h"
 #include "nss_gre_redir_mark.h"
 #include "nss_gre_redir_mark_stats.h"
-#include "nss_gre_redir_mark_strings.h"
 
 #define NSS_GRE_REDIR_MARK_STATS_STR_LEN 50
 #define NSS_GRE_REDIR_MARK_STATS_LEN ((NSS_GRE_REDIR_MARK_STATS_MAX + 7 ) * NSS_GRE_REDIR_MARK_STATS_STR_LEN)
-
-/*
- * Declare atomic notifier data structure for statistics.
- */
-ATOMIC_NOTIFIER_HEAD(nss_gre_redir_mark_stats_notifier);
-
 /*
- * Spinlock to protect GRE redirect mark statistics update/read
+ * nss_gre_redir_mark_stats_str
+ *	GRE redir mark statistics string
  */
-DEFINE_SPINLOCK(nss_gre_redir_mark_stats_lock);
-
-/*
- * Global GRE redirect mark stats structure.
- */
-struct nss_gre_redir_mark_stats gre_mark_stats;
-
-/*
- * nss_gre_redir_mark_stats_get()
- *	Get gre_redir tunnel stats.
- */
-bool nss_gre_redir_mark_stats_get(struct nss_gre_redir_mark_stats *stats_mem)
-{
-	if (!stats_mem) {
-		nss_warning("No memory to copy GRE redir mark stats");
-		return false;
+static int8_t *nss_gre_redir_mark_stats_str[NSS_GRE_REDIR_MARK_STATS_MAX] = {
+	"TX Packets",
+	"TX Bytes",
+	"RX Packets",
+	"RX Bytes",
+	"RX Drops",
+	"HLOS Magic Failed",
+	"Tx Inv_dst_if Drops",
+	"Tx Dst_if Enqueue",
+	"Tx Dst_if Enqueue Drops",
+	"Invalid Appid",
+	"Headroom Unavailable",
+	"Tx Completion Host Enqueue Success",
+	"Tx Completion Host Enqueue Drops",
+};
+
+/*
+ * nss_gre_redir_mark_stats_cpy()
+ *	Fill the stats.
+ */
+static ssize_t nss_gre_redir_mark_stats_cpy(char *lbuf, int len, int i, struct nss_gre_redir_mark_stats *s)
+{
+	uint64_t tcnt = 0;
+
+	switch (i) {
+	case NSS_GRE_REDIR_MARK_STATS_TX_PKTS:
+		tcnt = s->stats[NSS_GRE_REDIR_MARK_STATS_TX_PKTS];
+		return scnprintf(lbuf, len, "Common node stats start:\n\n%s = %llu\n", nss_gre_redir_mark_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_MARK_STATS_TX_BYTES:
+		tcnt = s->stats[NSS_GRE_REDIR_MARK_STATS_TX_BYTES];
+		return scnprintf(lbuf, len, "%s = %llu\n", nss_gre_redir_mark_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_MARK_STATS_RX_PKTS:
+		tcnt = s->stats[NSS_GRE_REDIR_MARK_STATS_RX_PKTS];
+		return scnprintf(lbuf, len, "%s = %llu\n", nss_gre_redir_mark_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_MARK_STATS_RX_BYTES:
+		tcnt = s->stats[NSS_GRE_REDIR_MARK_STATS_RX_BYTES];
+		return scnprintf(lbuf, len, "%s = %llu\n", nss_gre_redir_mark_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_MARK_STATS_RX_DROPS:
+		tcnt = s->stats[NSS_GRE_REDIR_MARK_STATS_RX_DROPS];
+		return scnprintf(lbuf, len, "%s = %llu\nCommon node stats end.\n", nss_gre_redir_mark_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_MARK_STATS_HLOS_MAGIC_FAILED:
+		tcnt = s->stats[NSS_GRE_REDIR_MARK_STATS_HLOS_MAGIC_FAILED];
+		return scnprintf(lbuf, len, "Offload stats start:\n\n%s = %llu\n", nss_gre_redir_mark_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_MARK_STATS_INV_DST_IF_DROPS:
+		tcnt = s->stats[NSS_GRE_REDIR_MARK_STATS_INV_DST_IF_DROPS];
+		return scnprintf(lbuf, len, "%s = %llu\n", nss_gre_redir_mark_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_MARK_STATS_DST_IF_ENQUEUE:
+		tcnt = s->stats[NSS_GRE_REDIR_MARK_STATS_DST_IF_ENQUEUE];
+		return scnprintf(lbuf, len, "%s = %llu\n", nss_gre_redir_mark_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_MARK_STATS_DST_IF_ENQUEUE_DROPS:
+		tcnt = s->stats[NSS_GRE_REDIR_MARK_STATS_DST_IF_ENQUEUE_DROPS];
+		return scnprintf(lbuf, len, "%s = %llu\n", nss_gre_redir_mark_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_MARK_STATS_INV_APPID:
+		tcnt = s->stats[NSS_GRE_REDIR_MARK_STATS_INV_APPID];
+		return scnprintf(lbuf, len, "%s = %llu\n", nss_gre_redir_mark_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_MARK_STATS_HEADROOM_UNAVAILABLE:
+		tcnt = s->stats[NSS_GRE_REDIR_MARK_STATS_HEADROOM_UNAVAILABLE];
+		return scnprintf(lbuf, len, "%s = %llu\n", nss_gre_redir_mark_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_MARK_STATS_TX_COMPLETION_SUCCESS:
+		tcnt = s->stats[NSS_GRE_REDIR_MARK_STATS_TX_COMPLETION_SUCCESS];
+		return scnprintf(lbuf, len, "%s = %llu\n", nss_gre_redir_mark_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_MARK_STATS_TX_COMPLETION_DROPS:
+		tcnt = s->stats[NSS_GRE_REDIR_MARK_STATS_TX_COMPLETION_DROPS];
+		return scnprintf(lbuf, len, "%s = %llu\nOffload stats end.\n", nss_gre_redir_mark_stats_str[i], tcnt);
+	default:
+		nss_warning("Unknown stats type %d.\n", i);
+		return 0;
 	}
-
-	/*
-	 * Copy the GRE redir mark stats in the memory.
-	 */
-	spin_lock_bh(&nss_gre_redir_mark_stats_lock);
-	memcpy(stats_mem, &gre_mark_stats, sizeof(struct nss_gre_redir_mark_stats));
-	spin_unlock_bh(&nss_gre_redir_mark_stats_lock);
-	return true;
 }
-EXPORT_SYMBOL(nss_gre_redir_mark_stats_get);
 
-/**
+/*
  * nss_gre_redir_mark_stats_read()
  *	READ GRE redir mark stats.
  */
 static ssize_t nss_gre_redir_mark_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
 {
-	/*
-	 * Max output lines = #stats +
-	 * few blank lines for banner printing + Number of Extra outputlines
-	 * for future reference to add new stats
-	 */
-	uint32_t max_output_lines = NSS_GRE_REDIR_MARK_STATS_MAX + NSS_STATS_EXTRA_OUTPUT_LINES;
-	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
 	struct nss_gre_redir_mark_stats stats;
 	size_t size_wr = 0;
+	int start, end;
 	ssize_t bytes_read = 0;
 	bool isthere;
+	size_t size_al = ((NSS_GRE_REDIR_MARK_STATS_MAX + 7 ) * NSS_GRE_REDIR_MARK_STATS_STR_LEN);
 
 	char *lbuf = kzalloc(size_al, GFP_KERNEL);
 	if (unlikely(!lbuf)) {
@@ -86,16 +117,21 @@ static ssize_t nss_gre_redir_mark_stats_
 	/*
 	 * If GRE redir mark does not exists, then (isthere) will be false.
 	 */
-	isthere = nss_gre_redir_mark_stats_get(&stats);
+	isthere = nss_gre_redir_mark_get_stats((void*)&stats);
 	if (!isthere) {
 		nss_warning("Could not get GRE redirect stats");
 		kfree(lbuf);
 		return 0;
 	}
 
-	size_wr += nss_stats_banner(lbuf, size_wr, size_al, "gre_redir_mark stats", NSS_STATS_SINGLE_CORE);
-	size_wr += nss_stats_print("gre_redir_mark", NULL, NSS_STATS_SINGLE_INSTANCE, nss_gre_redir_mark_strings_stats,
-					stats.stats, NSS_GRE_REDIR_MARK_STATS_MAX, lbuf, size_wr, size_al);
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\nGRE redir mark stats\n");
+
+	start = NSS_GRE_REDIR_MARK_STATS_TX_PKTS;
+	end = NSS_GRE_REDIR_MARK_STATS_MAX;
+	while (start < end) {
+		size_wr += nss_gre_redir_mark_stats_cpy(lbuf + size_wr, size_al - size_wr, start, &stats);
+		start++;
+	}
 
 	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, size_wr);
 
@@ -125,106 +161,3 @@ struct dentry *nss_gre_redir_mark_stats_
 
 	return gre_redir_mark;
 }
-
-/*
- * nss_gre_redir_mark_stats_sync()
- *	Update GRE redir mark stats.
- */
-void nss_gre_redir_mark_stats_sync(struct nss_ctx_instance *nss_ctx, int if_num, struct nss_gre_redir_mark_stats_sync_msg *ngss)
-{
-	int i;
-	struct net_device *dev;
-	dev = nss_cmn_get_interface_dev(nss_ctx, if_num);
-	if (!dev) {
-		nss_warning("%px: Unable to find net device for the interface %d\n", nss_ctx, if_num);
-		return;
-	}
-
-	if (if_num != NSS_GRE_REDIR_MARK_INTERFACE) {
-		nss_warning("%px: Unknown type for interface %d\n", nss_ctx, if_num);
-		return;
-	}
-
-	/*
-	 * Update the stats in exclusive mode to prevent the read from the process
-	 * context through debug fs.
-	 */
-	spin_lock_bh(&nss_gre_redir_mark_stats_lock);
-
-	/*
-	 * Update the common node stats
-	 */
-	gre_mark_stats.stats[NSS_STATS_NODE_TX_PKTS] += ngss->node_stats.tx_packets;
-	gre_mark_stats.stats[NSS_STATS_NODE_TX_BYTES] += ngss->node_stats.tx_bytes;
-	gre_mark_stats.stats[NSS_STATS_NODE_RX_PKTS] += ngss->node_stats.rx_packets;
-	gre_mark_stats.stats[NSS_STATS_NODE_RX_BYTES] += ngss->node_stats.rx_bytes;
-	for (i = 0; i < NSS_MAX_NUM_PRI; i++) {
-		gre_mark_stats.stats[NSS_STATS_NODE_RX_QUEUE_0_DROPPED + i] += ngss->node_stats.rx_dropped[i];
-	}
-
-	/*
-	 * Update the GRE redir mark specific stats
-	 */
-	gre_mark_stats.stats[NSS_GRE_REDIR_MARK_STATS_HLOS_MAGIC_FAILED] += ngss->hlos_magic_fail;
-	gre_mark_stats.stats[NSS_GRE_REDIR_MARK_STATS_INV_DST_IF_DROPS] += ngss->invalid_dst_drop;
-	gre_mark_stats.stats[NSS_GRE_REDIR_MARK_STATS_DST_IF_ENQUEUE] += ngss->dst_enqueue_success;
-	gre_mark_stats.stats[NSS_GRE_REDIR_MARK_STATS_DST_IF_ENQUEUE_DROPS] += ngss->dst_enqueue_drop;
-	gre_mark_stats.stats[NSS_GRE_REDIR_MARK_STATS_INV_APPID] += ngss->inv_appid;
-	gre_mark_stats.stats[NSS_GRE_REDIR_MARK_STATS_HEADROOM_UNAVAILABLE] += ngss->headroom_unavail;
-	gre_mark_stats.stats[NSS_GRE_REDIR_MARK_STATS_TX_COMPLETION_SUCCESS] += ngss->tx_completion_success;
-	gre_mark_stats.stats[NSS_GRE_REDIR_MARK_STATS_TX_COMPLETION_DROPS] += ngss->tx_completion_drop;
-
-	spin_unlock_bh(&nss_gre_redir_mark_stats_lock);
-}
-
-/*
- * nss_gre_redir_mark_stats_notify()
- *	Sends notifications to all the registered modules.
- *
- * Leverage NSS-FW statistics timing to update Netlink.
- */
-void nss_gre_redir_mark_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num)
-{
-	struct nss_gre_redir_mark_stats_notification *stats_notify;
-
-	stats_notify = kzalloc(sizeof(struct nss_gre_redir_mark_stats_notification), GFP_ATOMIC);
-	if (!stats_notify) {
-		nss_warning("Unable to allocate memory for stats notification\n");
-		return;
-	}
-
-	if (if_num != NSS_GRE_REDIR_MARK_INTERFACE) {
-		nss_warning("%px: Unknown type for interface %d\n", nss_ctx, if_num);
-		kfree(stats_notify);
-		return;
-	}
-
-	spin_lock_bh(&nss_gre_redir_mark_stats_lock);
-	stats_notify->core_id = nss_ctx->id;
-	stats_notify->if_num = if_num;
-	memcpy(stats_notify->stats_ctx, gre_mark_stats.stats, sizeof(stats_notify->stats_ctx));
-	spin_unlock_bh(&nss_gre_redir_mark_stats_lock);
-
-	atomic_notifier_call_chain(&nss_gre_redir_mark_stats_notifier, NSS_STATS_EVENT_NOTIFY, stats_notify);
-	kfree(stats_notify);
-}
-
-/*
- * nss_gre_redir_mark_stats_unregister_notifier()
- *	Deregisters statistics notifier.
- */
-int nss_gre_redir_mark_stats_unregister_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_unregister(&nss_gre_redir_mark_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_gre_redir_mark_stats_unregister_notifier);
-
-/*
- * nss_gre_redir_mark_stats_register_notifier()
- *	Registers statistics notifier.
- */
-int nss_gre_redir_mark_stats_register_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_register(&nss_gre_redir_mark_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_gre_redir_mark_stats_register_notifier);
--- a/nss_gre_redir_mark_stats.h
+++ b/nss_gre_redir_mark_stats.h
@@ -1,6 +1,6 @@
 /*
  ******************************************************************************
- * Copyright (c) 2019, 2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -18,6 +18,26 @@
 #define __NSS_GRE_REDIR_MARK_STATS_H__
 
 /*
+ * GRE REDIR statistics types
+ */
+enum nss_gre_redir_mark_stats_types {
+	NSS_GRE_REDIR_MARK_STATS_TX_PKTS,
+	NSS_GRE_REDIR_MARK_STATS_TX_BYTES,
+	NSS_GRE_REDIR_MARK_STATS_RX_PKTS,
+	NSS_GRE_REDIR_MARK_STATS_RX_BYTES,
+	NSS_GRE_REDIR_MARK_STATS_RX_DROPS,
+	NSS_GRE_REDIR_MARK_STATS_HLOS_MAGIC_FAILED,
+	NSS_GRE_REDIR_MARK_STATS_INV_DST_IF_DROPS,
+	NSS_GRE_REDIR_MARK_STATS_DST_IF_ENQUEUE,
+	NSS_GRE_REDIR_MARK_STATS_DST_IF_ENQUEUE_DROPS,
+	NSS_GRE_REDIR_MARK_STATS_INV_APPID,
+	NSS_GRE_REDIR_MARK_STATS_HEADROOM_UNAVAILABLE,
+	NSS_GRE_REDIR_MARK_STATS_TX_COMPLETION_SUCCESS,
+	NSS_GRE_REDIR_MARK_STATS_TX_COMPLETION_DROPS,
+	NSS_GRE_REDIR_MARK_STATS_MAX
+};
+
+/*
  * NSS core stats -- for H2N/N2H gre_redir_mark debug stats
  */
 struct nss_gre_redir_mark_stats {
@@ -27,9 +47,6 @@ struct nss_gre_redir_mark_stats {
 /*
  * NSS GRE REDIR Mark statistics APIs
  */
-extern void nss_gre_redir_mark_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num);
-extern void nss_gre_redir_mark_stats_sync(struct nss_ctx_instance *nss_ctx, int if_num,
-					struct nss_gre_redir_mark_stats_sync_msg *ngss);
 extern struct dentry *nss_gre_redir_mark_stats_dentry_create(void);
 
 #endif /* __NSS_GRE_REDIR_MARK_STATS_H__ */
--- a/nss_gre_redir_mark_strings.c
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- ***************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ***************************************************************************
- */
-
-#include "nss_stats.h"
-#include "nss_core.h"
-#include "nss_strings.h"
-#include "nss_gre_redir_mark_strings.h"
-
-/*
- * nss_gre_redir_mark_strings_stats
- *	GRE redir mark statistics string
- */
-struct nss_stats_info nss_gre_redir_mark_strings_stats[NSS_GRE_REDIR_MARK_STATS_MAX] = {
-	{"rx Packets",				NSS_STATS_TYPE_COMMON},
-	{"rx Bytes",				NSS_STATS_TYPE_COMMON},
-	{"tx Packets",				NSS_STATS_TYPE_COMMON},
-	{"tx Bytes",				NSS_STATS_TYPE_COMMON},
-	{"rx_dropped_0",			NSS_STATS_TYPE_DROP},
-	{"rx_dropped_1",			NSS_STATS_TYPE_DROP},
-	{"rx_dropped_2",			NSS_STATS_TYPE_DROP},
-	{"rx_dropped_3",			NSS_STATS_TYPE_DROP},
-	{"HLOS Magic Failed",			NSS_STATS_TYPE_SPECIAL},
-	{"tx Inv_dst_if Drops",			NSS_STATS_TYPE_DROP},
-	{"tx Dst_if Enqueue",			NSS_STATS_TYPE_SPECIAL},
-	{"tx Dst_if Enqueue Drops",		NSS_STATS_TYPE_DROP},
-	{"Invalid Appid",			NSS_STATS_TYPE_SPECIAL},
-	{"Headroom Unavailable",		NSS_STATS_TYPE_EXCEPTION},
-	{"tx Completion Host Enqueue Success",	NSS_STATS_TYPE_SPECIAL},
-	{"tx Completion Host Enqueue Drops",	NSS_STATS_TYPE_DROP}
-};
-
-/*
- * nss_gre_redir_mark_strings_read()
- *	Read gre_redir_mark statistics names
- */
-static ssize_t nss_gre_redir_mark_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_gre_redir_mark_strings_stats, NSS_GRE_REDIR_MARK_STATS_MAX);
-}
-
-/*
- * nss_gre_redir_mark_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(gre_redir_mark);
-
-/*
- * nss_gre_redir_mark_strings_dentry_create()
- *	Create gre_redir_mark statistics strings debug entry.
- */
-void nss_gre_redir_mark_strings_dentry_create(void)
-{
-	nss_strings_create_dentry("gre_redir_mark", &nss_gre_redir_mark_strings_ops);
-}
--- a/nss_gre_redir_mark_strings.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- ****************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ****************************************************************************
- */
-
-#ifndef __NSS_GRE_REDIR_MARK_STRINGS_H
-#define __NSS_GRE_REDIR_MARK_STRINGS_H
-
-#include "nss_gre_redir_mark_stats.h"
-
-extern struct nss_stats_info nss_gre_redir_mark_strings_stats[NSS_GRE_REDIR_MARK_STATS_MAX];
-extern void nss_gre_redir_mark_strings_dentry_create(void);
-
-#endif /* __NSS_GRE_REDIR_MARK_STRINGS_H */
--- a/nss_gre_redir_stats.c
+++ b/nss_gre_redir_stats.c
@@ -1,6 +1,6 @@
 /*
- ****************************************************************************
- * Copyright (c) 2017-2019, 2021, The Linux Foundation. All rights reserved.
+ **************************************************************************
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -11,46 +11,146 @@
  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
  * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ****************************************************************************
+ **************************************************************************
  */
 
 #include "nss_core.h"
 #include "nss_gre_redir.h"
 #include "nss_gre_redir_stats.h"
-#include "nss_gre_redir_strings.h"
 
 /*
- * Declare atomic notifier data structure for statistics.
+ * nss_gre_redir_stats_str
+ *	GRE REDIR statistics string
  */
-ATOMIC_NOTIFIER_HEAD(nss_gre_redir_stats_notifier);
+static int8_t *nss_gre_redir_stats_str[NSS_GRE_REDIR_STATS_MAX] = {
+	"TX Packets",
+	"TX Bytes",
+	"TX Drops",
+	"RX Packets",
+	"RX Bytes",
+	"RX Drops",
+	"TX Sjack Packets",
+	"RX Sjack packets",
+	"TX Offload Packets",
+	"RX Offload Packets",
+	"US exception RX Packets",
+	"US exception TX Packets",
+	"DS exception RX Packets",
+	"DS exception TX Packets",
+	"Encap SG alloc drop",
+	"Decap fail drop",
+	"Decap split drop",
+	"Split SG alloc fail",
+	"Split linear copy fail",
+	"Split not enough tailroom",
+	"Exception ds invalid dst",
+	"Decap eapol frames",
+	"Exception ds invalid appid",
+	"Headroom Unavailable",
+	"Exception ds Tx completion Success",
+	"Exception ds Tx completion drop"
+};
 
 /*
- * Spinlock to protect GRE redirect statistics update/read
+ * nss_gre_redir_stats()
+ *	Make a row for GRE_REDIR stats.
  */
-DEFINE_SPINLOCK(nss_gre_redir_stats_lock);
-
-/*
- * Array to hold tunnel stats along with if_num
- */
-extern struct nss_gre_redir_tunnel_stats tun_stats[NSS_GRE_REDIR_MAX_INTERFACES];
-
-/*
- * nss_gre_redir_stats_get()
- *	Get GRE redirect tunnel stats.
- */
-bool nss_gre_redir_stats_get(int index, struct nss_gre_redir_tunnel_stats *stats)
+static ssize_t nss_gre_redir_stats(char *line, int len, int i, struct nss_gre_redir_tunnel_stats *s)
 {
-	spin_lock_bh(&nss_gre_redir_stats_lock);
-	if (tun_stats[index].ref_count == 0) {
-		spin_unlock_bh(&nss_gre_redir_stats_lock);
-		return false;
+	char name[40];
+	uint64_t tcnt = 0;
+	int j = 0;
+
+	switch (i) {
+	case NSS_GRE_REDIR_STATS_TX_PKTS:
+		tcnt = s->node_stats.tx_packets;
+		return snprintf(line, len, "Common node stats start:\n\n%s = %llu\n", nss_gre_redir_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_STATS_TX_BYTES:
+		tcnt = s->node_stats.tx_bytes;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_STATS_TX_DROPS:
+		tcnt = s->tx_dropped;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_STATS_RX_PKTS:
+		tcnt = s->node_stats.rx_packets;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_STATS_RX_BYTES:
+		tcnt = s->node_stats.rx_bytes;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_STATS_RX_DROPS:
+		tcnt = s->node_stats.rx_dropped[0];
+		return snprintf(line, len, "%s = %llu\nCommon node stats end.\n", nss_gre_redir_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_STATS_SJACK_TX_PKTS:
+		tcnt = s->sjack_tx_packets;
+		return snprintf(line, len, "Offload stats start:\n\n%s = %llu\n", nss_gre_redir_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_STATS_OFFLOAD_TX_PKTS:
+		for (j = 0; j < NSS_GRE_REDIR_MAX_RADIO; j++) {
+			scnprintf(name, sizeof(name), "TX offload pkts for radio %d", j);
+			tcnt += snprintf(line + tcnt, len - tcnt, "%s = %llu\n", name, s->offl_tx_pkts[j]);
+		}
+		return tcnt;
+	case NSS_GRE_REDIR_STATS_SJACK_RX_PKTS:
+		tcnt = s->sjack_rx_packets;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_STATS_OFFLOAD_RX_PKTS:
+		for (j = 0; j < NSS_GRE_REDIR_MAX_RADIO; j++) {
+			scnprintf(name, sizeof(name), "RX offload pkts for radio %d", j);
+			tcnt += snprintf(line + tcnt, len - tcnt, "%s = %llu\n", name, s->offl_rx_pkts[j]);
+		}
+		return tcnt;
+	case NSS_GRE_REDIR_STATS_EXCEPTION_US_RX_PKTS:
+		tcnt = s->exception_us_rx;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_STATS_EXCEPTION_US_TX_PKTS:
+		tcnt = s->exception_us_tx;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_STATS_EXCEPTION_DS_RX_PKTS:
+		tcnt = s->exception_ds_rx;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_STATS_EXCEPTION_DS_TX_PKTS:
+		tcnt = s->exception_ds_tx;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_STATS_ENCAP_SG_ALLOC_DROP:
+		tcnt = s->encap_sg_alloc_drop;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_STATS_DECAP_FAIL_DROP:
+		tcnt = s->decap_fail_drop;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_STATS_DECAP_SPLIT_DROP:
+		tcnt = s->decap_split_drop;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_STATS_SPLIT_SG_ALLOC_FAIL:
+		tcnt = s->split_sg_alloc_fail;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_STATS_SPLIT_LINEAR_COPY_FAIL:
+		tcnt = s->split_linear_copy_fail;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_STATS_SPLIT_NOT_ENOUGH_TAILROOM:
+		tcnt = s->split_not_enough_tailroom;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_STATS_EXCEPTION_DS_INVALID_DST_DROP:
+		tcnt = s->exception_ds_invalid_dst_drop;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_STATS_DECAP_EAPOL_FRAMES:
+		tcnt = s->decap_eapol_frames;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_STATS_EXCEPTION_DS_INV_APPID:
+		tcnt = s->exception_ds_inv_appid;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_STATS_HEADROOM_UNAVAILABLE:
+		tcnt = s->headroom_unavail;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_STATS_TX_COMPLETION_SUCCESS:
+		tcnt = s->tx_completion_success;
+		return snprintf(line, len, "%s = %llu\n", nss_gre_redir_stats_str[i], tcnt);
+	case NSS_GRE_REDIR_STATS_TX_COMPLETION_DROP:
+		tcnt = s->tx_completion_drop;
+		return snprintf(line, len, "%s = %llu\nOffload stats end.\n", nss_gre_redir_stats_str[i], tcnt);
+	default:
+		nss_warning("Unknown stats type %d.\n", i);
+		return 0;
 	}
-
-	memcpy(stats, &tun_stats[index], sizeof(struct nss_gre_redir_tunnel_stats));
-	spin_unlock_bh(&nss_gre_redir_stats_lock);
-	return true;
 }
-EXPORT_SYMBOL(nss_gre_redir_stats_get);
 
 /*
  * nss_gre_redir_stats_read()
@@ -58,25 +158,14 @@ EXPORT_SYMBOL(nss_gre_redir_stats_get);
  */
 static ssize_t nss_gre_redir_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
 {
-	 /*
-	  * Max output lines = #stats +
-	  * few blank lines for banner printing + Number of Extra outputlines
-	  * for future reference to add new stats
-	  */
-	uint32_t max_output_lines = NSS_GRE_REDIR_STATS_MAX + NSS_STATS_EXTRA_OUTPUT_LINES;
-	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines * NSS_GRE_REDIR_MAX_INTERFACES;
 	struct nss_stats_data *data = fp->private_data;
-	struct nss_gre_redir_tunnel_stats stats;
 	ssize_t bytes_read = 0;
-	size_t size_wr = 0;
+	struct nss_gre_redir_tunnel_stats stats;
+	size_t bytes;
+	char line[80 * NSS_GRE_REDIR_MAX_RADIO];
+	int start, end;
 	int index = 0;
 
-	char *lbuf = kzalloc(size_al, GFP_KERNEL);
-	if (unlikely(!lbuf)) {
-		nss_warning("Could not allocate memory for local statistics buffer");
-		return 0;
-	}
-
 	if (data) {
 		index = data->index;
 	}
@@ -85,7 +174,6 @@ static ssize_t nss_gre_redir_stats_read(
 	 * If we are done accomodating all the GRE_REDIR tunnels.
 	 */
 	if (index >= NSS_GRE_REDIR_MAX_INTERFACES) {
-		kfree(lbuf);
 		return 0;
 	}
 
@@ -95,23 +183,48 @@ static ssize_t nss_gre_redir_stats_read(
 		/*
 		 * If gre_redir tunnel does not exists, then isthere will be false.
 		 */
-		isthere = nss_gre_redir_stats_get(index, &stats);
+		isthere = nss_gre_redir_get_stats(index, &stats);
 		if (!isthere) {
 			continue;
 		}
 
-		size_wr += nss_stats_banner(lbuf, size_wr, size_al, "gre_redir stats", NSS_STATS_SINGLE_CORE);
-		size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\nTunnel stats for %s\n", stats.dev->name);
-		size_wr += nss_stats_print("gre_redir", NULL, NSS_STATS_SINGLE_INSTANCE, nss_gre_redir_strings_stats,
-					&stats.tstats.rx_packets, NSS_GRE_REDIR_STATS_MAX, lbuf, size_wr, size_al);
+		bytes = snprintf(line, sizeof(line), "\nTunnel stats for %s\n", stats.dev->name);
+		if ((bytes_read + bytes) > sz) {
+			break;
+		}
+
+		if (copy_to_user(ubuf + bytes_read, line, bytes) != 0) {
+			bytes_read = -EFAULT;
+			goto fail;
+		}
+		bytes_read += bytes;
+		start = NSS_GRE_REDIR_STATS_TX_PKTS;
+		end = NSS_GRE_REDIR_STATS_MAX;
+		while (bytes_read < sz && start < end) {
+			bytes = nss_gre_redir_stats(line, sizeof(line), start, &stats);
+
+			if ((bytes_read + bytes) > sz)
+				break;
+
+			if (copy_to_user(ubuf + bytes_read, line, bytes) != 0) {
+				bytes_read = -EFAULT;
+				goto fail;
+			}
+
+			bytes_read += bytes;
+			start++;
+		}
+	}
+
+	if (bytes_read > 0) {
+		*ppos = bytes_read;
 	}
 
-	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
 	if (data) {
 		data->index = index;
 	}
 
-	kfree(lbuf);
+fail:
 	return bytes_read;
 }
 
@@ -145,168 +258,3 @@ struct dentry *nss_gre_redir_stats_dentr
 
 	return gre_redir;
 }
-
-/*
- * nss_gre_redir_stats_sync()
- *	Update gre_redir tunnel stats.
- */
-void nss_gre_redir_stats_sync(struct nss_ctx_instance *nss_ctx, int if_num, struct nss_gre_redir_stats_sync_msg *ngss)
-{
-	int i, j;
-	uint32_t type;
-	struct net_device *dev;
-	struct nss_gre_redir_tun_stats *node_stats;
-
-	type = nss_dynamic_interface_get_type(nss_ctx, if_num);
-	dev = nss_cmn_get_interface_dev(nss_ctx, if_num);
-	if (!dev) {
-		nss_warning("%px: Unable to find net device for the interface %d\n", nss_ctx, if_num);
-		return;
-	}
-
-	if (!nss_gre_redir_verify_ifnum(if_num)) {
-		nss_warning("%px: Unknown type for interface %d\n", nss_ctx, if_num);
-		return;
-	}
-
-	spin_lock_bh(&nss_gre_redir_stats_lock);
-	for (i = 0; i < NSS_GRE_REDIR_MAX_INTERFACES; i++) {
-		if (tun_stats[i].dev == dev) {
-			break;
-		}
-	}
-
-	if (i == NSS_GRE_REDIR_MAX_INTERFACES) {
-		nss_warning("%px: Unable to find tunnel stats instance for interface %d\n", nss_ctx, if_num);
-		spin_unlock_bh(&nss_gre_redir_stats_lock);
-		return;
-	}
-
-	nss_assert(tun_stats[i].ref_count);
-	node_stats = &tun_stats[i].tstats;
-	switch (type) {
-	case NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_WIFI_HOST_INNER:
-	case NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_WIFI_OFFL_INNER:
-	case NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_SJACK_INNER:
-		node_stats->tx_packets += ngss->node_stats.tx_packets;
-		node_stats->tx_bytes += ngss->node_stats.tx_bytes;
-		node_stats->sjack_tx_packets += ngss->sjack_rx_packets;
-		node_stats->encap_sg_alloc_drop += ngss->encap_sg_alloc_drop;
-		node_stats->tx_dropped += nss_cmn_rx_dropped_sum(&(ngss->node_stats));
-		for (j = 0; j < NSS_GRE_REDIR_MAX_RADIO; j++) {
-			node_stats->offl_tx_pkts[j] += ngss->offl_rx_pkts[j];
-		}
-
-		break;
-
-	case NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_OUTER:
-		node_stats->rx_packets += ngss->node_stats.rx_packets;
-		node_stats->rx_bytes += ngss->node_stats.rx_bytes;
-		node_stats->sjack_rx_packets += ngss->sjack_rx_packets;
-		node_stats->decap_fail_drop += ngss->decap_fail_drop;
-		node_stats->decap_split_drop += ngss->decap_split_drop;
-		node_stats->split_sg_alloc_fail += ngss->split_sg_alloc_fail;
-		node_stats->split_linear_copy_fail += ngss->split_linear_copy_fail;
-		node_stats->split_not_enough_tailroom += ngss->split_not_enough_tailroom;
-		node_stats->decap_eapol_frames += ngss->decap_eapol_frames;
-		for (j = 0; j < NSS_MAX_NUM_PRI; j++) {
-			node_stats->rx_dropped[j] += ngss->node_stats.rx_dropped[j];
-		}
-
-		for (j = 0; j < NSS_GRE_REDIR_MAX_RADIO; j++) {
-			node_stats->offl_rx_pkts[j] += ngss->offl_rx_pkts[j];
-		}
-
-		break;
-
-	case NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_EXCEPTION_US:
-		node_stats->exception_us_rx += ngss->node_stats.rx_packets;
-		node_stats->exception_us_tx += ngss->node_stats.tx_packets;
-		break;
-
-	case NSS_DYNAMIC_INTERFACE_TYPE_GRE_REDIR_EXCEPTION_DS:
-		node_stats->exception_ds_rx += ngss->node_stats.rx_packets;
-		node_stats->exception_ds_tx += ngss->node_stats.tx_packets;
-		node_stats->exception_ds_invalid_dst_drop += ngss->exception_ds_invalid_dst_drop;
-		node_stats->exception_ds_inv_appid += ngss->exception_ds_inv_appid;
-		node_stats->headroom_unavail += ngss->headroom_unavail;
-		node_stats->tx_completion_success += ngss->tx_completion_success;
-		node_stats->tx_completion_drop += ngss->tx_completion_drop;
-		break;
-	}
-
-	spin_unlock_bh(&nss_gre_redir_stats_lock);
-}
-
-/*
- * nss_gre_redir_stats_notify()
- *	Sends notifications to all the registered modules.
- *
- * Leverage NSS-FW statistics timing to update Netlink.
- */
-void nss_gre_redir_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num)
-{
-	struct nss_gre_redir_stats_notification *stats_notify;
-	struct net_device *dev;
-	int i;
-
-	stats_notify = kzalloc(sizeof(struct nss_gre_redir_stats_notification), GFP_ATOMIC);
-	if (!stats_notify) {
-		nss_warning("Unable to allocate memory for stats notification\n");
-		return;
-	}
-
-	dev = nss_cmn_get_interface_dev(nss_ctx, if_num);
-	if (!dev) {
-		nss_warning("%px: Unable to find net device for the interface %d\n", nss_ctx, if_num);
-		kfree(stats_notify);
-		return;
-	}
-
-	if (!nss_gre_redir_verify_ifnum(if_num)) {
-		nss_warning("%px: Unknown type for interface %d\n", nss_ctx, if_num);
-		kfree(stats_notify);
-		return;
-	}
-
-	spin_lock_bh(&nss_gre_redir_stats_lock);
-	for (i = 0; i < NSS_GRE_REDIR_MAX_INTERFACES; i++) {
-		if (tun_stats[i].dev == dev) {
-			break;
-		}
-	}
-
-	if (i == NSS_GRE_REDIR_MAX_INTERFACES) {
-		nss_warning("%px: Unable to find tunnel stats instance for interface %d\n", nss_ctx, if_num);
-		spin_unlock_bh(&nss_gre_redir_stats_lock);
-		kfree(stats_notify);
-		return;
-	}
-
-	stats_notify->core_id = nss_ctx->id;
-	stats_notify->if_num = if_num;
-	memcpy(&(stats_notify->stats_ctx), &(tun_stats[i]), sizeof(stats_notify->stats_ctx));
-	spin_unlock_bh(&nss_gre_redir_stats_lock);
-	atomic_notifier_call_chain(&nss_gre_redir_stats_notifier, NSS_STATS_EVENT_NOTIFY, stats_notify);
-	kfree(stats_notify);
-}
-
-/*
- * nss_gre_redir_stats_unregister_notifier()
- *	Degisters statistics notifier.
- */
-int nss_gre_redir_stats_unregister_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_unregister(&nss_gre_redir_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_gre_redir_stats_unregister_notifier);
-
-/*
- * nss_gre_redir_stats_register_notifier()
- *	Registers statistics notifier.
- */
-int nss_gre_redir_stats_register_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_register(&nss_gre_redir_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_gre_redir_stats_register_notifier);
--- a/nss_gre_redir_stats.h
+++ b/nss_gre_redir_stats.h
@@ -1,6 +1,6 @@
 /*
  ******************************************************************************
- * Copyright (c) 2017-2019, 2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -18,13 +18,41 @@
 #define __NSS_GRE_REDIR_STATS_H__
 
 /*
+ * GRE REDIR statistics
+ */
+enum nss_gre_redir_stats_types {
+	NSS_GRE_REDIR_STATS_TX_PKTS,
+	NSS_GRE_REDIR_STATS_TX_BYTES,
+	NSS_GRE_REDIR_STATS_TX_DROPS,
+	NSS_GRE_REDIR_STATS_RX_PKTS,
+	NSS_GRE_REDIR_STATS_RX_BYTES,
+	NSS_GRE_REDIR_STATS_RX_DROPS,
+	NSS_GRE_REDIR_STATS_SJACK_TX_PKTS,
+	NSS_GRE_REDIR_STATS_SJACK_RX_PKTS,
+	NSS_GRE_REDIR_STATS_OFFLOAD_TX_PKTS,
+	NSS_GRE_REDIR_STATS_OFFLOAD_RX_PKTS,
+	NSS_GRE_REDIR_STATS_EXCEPTION_US_RX_PKTS,
+	NSS_GRE_REDIR_STATS_EXCEPTION_US_TX_PKTS,
+	NSS_GRE_REDIR_STATS_EXCEPTION_DS_RX_PKTS,
+	NSS_GRE_REDIR_STATS_EXCEPTION_DS_TX_PKTS,
+	NSS_GRE_REDIR_STATS_ENCAP_SG_ALLOC_DROP,
+	NSS_GRE_REDIR_STATS_DECAP_FAIL_DROP,
+	NSS_GRE_REDIR_STATS_DECAP_SPLIT_DROP,
+	NSS_GRE_REDIR_STATS_SPLIT_SG_ALLOC_FAIL,
+	NSS_GRE_REDIR_STATS_SPLIT_LINEAR_COPY_FAIL,
+	NSS_GRE_REDIR_STATS_SPLIT_NOT_ENOUGH_TAILROOM,
+	NSS_GRE_REDIR_STATS_EXCEPTION_DS_INVALID_DST_DROP,
+	NSS_GRE_REDIR_STATS_DECAP_EAPOL_FRAMES,
+	NSS_GRE_REDIR_STATS_EXCEPTION_DS_INV_APPID,
+	NSS_GRE_REDIR_STATS_HEADROOM_UNAVAILABLE,
+	NSS_GRE_REDIR_STATS_TX_COMPLETION_SUCCESS,
+	NSS_GRE_REDIR_STATS_TX_COMPLETION_DROP,
+	NSS_GRE_REDIR_STATS_MAX
+};
+
+/*
  * NSS GRE REDIR statistics APIs
  */
-extern spinlock_t nss_gre_redir_stats_lock;
-extern bool nss_gre_redir_verify_ifnum(uint32_t if_num);
-extern void nss_gre_redir_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num);
-extern void nss_gre_redir_stats_sync(struct nss_ctx_instance *nss_ctx, int if_num,
-					struct nss_gre_redir_stats_sync_msg *ngss);
 extern struct dentry *nss_gre_redir_stats_dentry_create(void);
 
 #endif /* __NSS_GRE_REDIR_STATS_H__ */
--- a/nss_gre_redir_strings.c
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- ***************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ***************************************************************************
- */
-
-#include "nss_stats.h"
-#include "nss_core.h"
-#include "nss_strings.h"
-#include "nss_gre_redir_strings.h"
-
-/*
- * nss_gre_redir_strings_stats
- *	GRE redirect statistics string.
- */
-struct nss_stats_info nss_gre_redir_strings_stats[NSS_GRE_REDIR_STATS_MAX] = {
-	{"RX Packets",				NSS_STATS_TYPE_COMMON},
-	{"RX Bytes",				NSS_STATS_TYPE_COMMON},
-	{"TX Packets",				NSS_STATS_TYPE_COMMON},
-	{"TX Bytes",				NSS_STATS_TYPE_COMMON},
-	{"RX Drops_[0]",			NSS_STATS_TYPE_DROP},
-	{"RX Drops_[1]",			NSS_STATS_TYPE_DROP},
-	{"RX Drops_[2]",			NSS_STATS_TYPE_DROP},
-	{"RX Drops_[3]",			NSS_STATS_TYPE_DROP},
-	{"TX Drops",				NSS_STATS_TYPE_DROP},
-	{"RX Sjack Packets",			NSS_STATS_TYPE_SPECIAL},
-	{"TX Sjack packets",			NSS_STATS_TYPE_SPECIAL},
-	{"RX Offload Packets_[0]",		NSS_STATS_TYPE_SPECIAL},
-	{"RX Offload Packets_[1]",		NSS_STATS_TYPE_SPECIAL},
-	{"RX Offload Packets_[2]",		NSS_STATS_TYPE_SPECIAL},
-	{"RX Offload Packets_[3]",		NSS_STATS_TYPE_SPECIAL},
-	{"RX Offload Packets_[4]",		NSS_STATS_TYPE_SPECIAL},
-	{"TX Offload Packets_[0]",		NSS_STATS_TYPE_SPECIAL},
-	{"TX Offload Packets_[1]",		NSS_STATS_TYPE_SPECIAL},
-	{"TX Offload Packets_[2]",		NSS_STATS_TYPE_SPECIAL},
-	{"TX Offload Packets_[3]",		NSS_STATS_TYPE_SPECIAL},
-	{"TX Offload Packets_[4]",		NSS_STATS_TYPE_SPECIAL},
-	{"US exception RX Packets",		NSS_STATS_TYPE_EXCEPTION},
-	{"US exception TX Packets",		NSS_STATS_TYPE_EXCEPTION},
-	{"DS exception RX Packets",		NSS_STATS_TYPE_EXCEPTION},
-	{"DS exception TX Packets",		NSS_STATS_TYPE_EXCEPTION},
-	{"Encap SG alloc drop",			NSS_STATS_TYPE_DROP},
-	{"Decap fail drop",			NSS_STATS_TYPE_DROP},
-	{"Decap split drop",			NSS_STATS_TYPE_SPECIAL},
-	{"Split SG alloc fail",			NSS_STATS_TYPE_SPECIAL},
-	{"Split linear copy fail",		NSS_STATS_TYPE_SPECIAL},
-	{"Split not enough tailroom",		NSS_STATS_TYPE_EXCEPTION},
-	{"Exception ds invalid dst",		NSS_STATS_TYPE_SPECIAL},
-	{"Decap eapol frames",			NSS_STATS_TYPE_SPECIAL},
-	{"Exception ds invalid appid",		NSS_STATS_TYPE_EXCEPTION},
-	{"Headroom Unavailable",		NSS_STATS_TYPE_EXCEPTION},
-	{"Exception ds Tx completion Success",	NSS_STATS_TYPE_SPECIAL},
-	{"Exception ds Tx completion drop",	NSS_STATS_TYPE_DROP}
-};
-
-/*
- * nss_gre_redir_strings_read()
- *	Read GRE redirect statistics names.
- */
-static ssize_t nss_gre_redir_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_gre_redir_strings_stats, NSS_GRE_REDIR_STATS_MAX);
-}
-
-/*
- * nss_gre_redir_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(gre_redir);
-
-/*
- * nss_gre_redir_strings_dentry_create()
- *	Create GRE redirect statistics strings debug entry.
- */
-void nss_gre_redir_strings_dentry_create(void)
-{
-	nss_strings_create_dentry("gre_redir", &nss_gre_redir_strings_ops);
-}
--- a/nss_gre_redir_strings.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- ***************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ***************************************************************************
- */
-
-#ifndef __NSS_GRE_REDIR_STRINGS_H
-#define __NSS_GRE_REDIR_STRINGS_H
-
-#include "nss_gre_redir_stats.h"
-
-extern struct nss_stats_info nss_gre_redir_strings_stats[NSS_GRE_REDIR_STATS_MAX];
-extern void nss_gre_redir_strings_dentry_create(void);
-
-#endif /* __NSS_GRE_REDIR_STRINGS_H */
--- a/nss_gre_stats.c
+++ b/nss_gre_stats.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2019, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -21,38 +21,77 @@
  */
 
 #include "nss_tx_rx_common.h"
-#include "nss_gre.h"
 #include "nss_gre_stats.h"
-#include "nss_gre_strings.h"
 
 /*
- * Declare atomic notifier data structure for statistics.
+ * Data structures to store GRE nss debug stats
  */
-ATOMIC_NOTIFIER_HEAD(nss_gre_stats_notifier);
+static DEFINE_SPINLOCK(nss_gre_stats_lock);
+static struct nss_gre_stats_session_debug session_debug_stats[NSS_GRE_MAX_DEBUG_SESSION_STATS];
+static struct nss_gre_stats_base_debug base_debug_stats;
 
 /*
- * Data structures to store GRE nss debug stats
+ * nss_gre_stats_base_debug_str
+ *	GRE debug statistics strings for base types
  */
-static DEFINE_SPINLOCK(nss_gre_stats_lock);
-static struct nss_gre_stats_session session_stats[NSS_GRE_MAX_DEBUG_SESSION_STATS];
-static struct nss_gre_stats_base base_stats;
+struct nss_stats_info nss_gre_stats_base_debug_str[NSS_GRE_STATS_BASE_DEBUG_MAX] = {
+	{"base_rx_pkts"				,NSS_STATS_TYPE_COMMON},
+	{"base_rx_drops"			,NSS_STATS_TYPE_DROP},
+	{"base_exp_eth_hdr_missing"		,NSS_STATS_TYPE_EXCEPTION},
+	{"base_exp_eth_type_non_ip"		,NSS_STATS_TYPE_EXCEPTION},
+	{"base_exp_ip_unknown_protocol"		,NSS_STATS_TYPE_EXCEPTION},
+	{"base_exp_ip_header_incomplete"	,NSS_STATS_TYPE_EXCEPTION},
+	{"base_exp_ip_bad_total_length"		,NSS_STATS_TYPE_EXCEPTION},
+	{"base_exp_ip_bad_checksum"		,NSS_STATS_TYPE_EXCEPTION},
+	{"base_exp_ip_datagram_incomplete"	,NSS_STATS_TYPE_EXCEPTION},
+	{"base_exp_ip_fragment"			,NSS_STATS_TYPE_EXCEPTION},
+	{"base_exp_ip_options_incomplete"	,NSS_STATS_TYPE_EXCEPTION},
+	{"base_exp_ip_with_options"		,NSS_STATS_TYPE_EXCEPTION},
+	{"base_exp_ipv6_unknown_protocol"	,NSS_STATS_TYPE_EXCEPTION},
+	{"base_exp_ipv6_header_incomplete"	,NSS_STATS_TYPE_EXCEPTION},
+	{"base_exp_unknown_session"		,NSS_STATS_TYPE_EXCEPTION},
+	{"base_exp_node_inactive"		,NSS_STATS_TYPE_EXCEPTION}
+};
+
+/*
+ * nss_gre_stats_session_debug_str
+ *	GRE debug statistics strings for sessions
+ */
+struct nss_stats_info nss_gre_stats_session_debug_str[NSS_GRE_STATS_SESSION_DEBUG_MAX] = {
+	{"session_pbuf_alloc_fail"		, NSS_STATS_TYPE_ERROR},
+	{"session_decap_forward_enqueue_fail"	, NSS_STATS_TYPE_DROP},
+	{"session_encap_forward_enqueue_fail"	, NSS_STATS_TYPE_DROP},
+	{"session_decap_tx_forwarded"		, NSS_STATS_TYPE_SPECIAL},
+	{"session_encap_rx_received"		, NSS_STATS_TYPE_SPECIAL},
+	{"session_encap_rx_drops"		, NSS_STATS_TYPE_DROP},
+	{"session_encap_rx_linear_fail"		, NSS_STATS_TYPE_DROP},
+	{"session_exp_rx_key_error"		, NSS_STATS_TYPE_EXCEPTION},
+	{"session_exp_rx_seq_error"		, NSS_STATS_TYPE_EXCEPTION},
+	{"session_exp_rx_cs_error"		, NSS_STATS_TYPE_EXCEPTION},
+	{"session_exp_rx_flag_mismatch"		, NSS_STATS_TYPE_EXCEPTION},
+	{"session_exp_rx_malformed"		, NSS_STATS_TYPE_EXCEPTION},
+	{"session_exp_rx_invalid_protocol"	, NSS_STATS_TYPE_EXCEPTION},
+	{"session_exp_rx_no_headroom"		, NSS_STATS_TYPE_EXCEPTION}
+};
 
 /*
  * GRE statistics APIs
  */
 
 /*
- * nss_gre_stats_session_unregister()
- *	Unregister debug statistic for GRE session.
+ * nss_gre_stats_session_register()
+ *	Register debug statistic for GRE session.
  */
-void nss_gre_stats_session_unregister(uint32_t if_num)
+void nss_gre_stats_session_register(uint32_t if_num, struct net_device *netdev)
 {
 	int i;
 
 	spin_lock_bh(&nss_gre_stats_lock);
 	for (i = 0; i < NSS_GRE_MAX_DEBUG_SESSION_STATS; i++) {
-		if (session_stats[i].if_num == if_num) {
-			memset(&session_stats[i], 0, sizeof(struct nss_gre_stats_session));
+		if (!session_debug_stats[i].valid) {
+			session_debug_stats[i].valid = true;
+			session_debug_stats[i].if_num = if_num;
+			session_debug_stats[i].if_index = netdev->ifindex;
 			break;
 		}
 	}
@@ -60,19 +99,17 @@ void nss_gre_stats_session_unregister(ui
 }
 
 /*
- * nss_gre_stats_session_register()
- *	Register debug statistic for GRE session.
+ * nss_gre_stats_session_unregister()
+ *	Unregister debug statistic for GRE session.
  */
-void nss_gre_stats_session_register(uint32_t if_num, struct net_device *netdev)
+void nss_gre_stats_session_unregister(uint32_t if_num)
 {
 	int i;
 
 	spin_lock_bh(&nss_gre_stats_lock);
 	for (i = 0; i < NSS_GRE_MAX_DEBUG_SESSION_STATS; i++) {
-		if (!session_stats[i].valid) {
-			session_stats[i].valid = true;
-			session_stats[i].if_num = if_num;
-			session_stats[i].if_index = netdev->ifindex;
+		if (session_debug_stats[i].if_num == if_num) {
+			memset(&session_debug_stats[i], 0, sizeof(struct nss_gre_stats_session_debug));
 			break;
 		}
 	}
@@ -80,25 +117,25 @@ void nss_gre_stats_session_register(uint
 }
 
 /*
- * nss_gre_stats_session_sync()
+ * nss_gre_stats_session_debug_sync()
  *	debug statistics sync for GRE session.
  */
-void nss_gre_stats_session_sync(struct nss_ctx_instance *nss_ctx, struct nss_gre_session_stats_msg *sstats, uint16_t if_num)
+void nss_gre_stats_session_debug_sync(struct nss_ctx_instance *nss_ctx, struct nss_gre_session_stats_msg *sstats, uint16_t if_num)
 {
 	int i, j;
 	enum nss_dynamic_interface_type interface_type = nss_dynamic_interface_get_type(nss_ctx, if_num);
 
 	spin_lock_bh(&nss_gre_stats_lock);
 	for (i = 0; i < NSS_GRE_MAX_DEBUG_SESSION_STATS; i++) {
-		if (session_stats[i].if_num == if_num) {
-			for (j = 0; j < NSS_GRE_SESSION_DEBUG_MAX; j++) {
-				session_stats[i].stats[j] += sstats->stats[j];
+		if (session_debug_stats[i].if_num == if_num) {
+			for (j = 0; j < NSS_GRE_STATS_SESSION_DEBUG_MAX; j++) {
+				session_debug_stats[i].stats[j] += sstats->stats[j];
 			}
 
 			if (interface_type == NSS_DYNAMIC_INTERFACE_TYPE_GRE_INNER) {
-				session_stats[i].stats[NSS_GRE_SESSION_ENCAP_RX_RECEIVED] += sstats->node_stats.rx_packets;
+				session_debug_stats[i].stats[NSS_GRE_STATS_SESSION_ENCAP_RX_RECEIVED] += sstats->node_stats.rx_packets;
 			} else if (interface_type == NSS_DYNAMIC_INTERFACE_TYPE_GRE_OUTER) {
-				session_stats[i].stats[NSS_GRE_SESSION_DECAP_TX_FORWARDED] += sstats->node_stats.tx_packets;
+				session_debug_stats[i].stats[NSS_GRE_STATS_SESSION_DECAP_TX_FORWARDED] += sstats->node_stats.tx_packets;
 			}
 			break;
 		}
@@ -107,38 +144,38 @@ void nss_gre_stats_session_sync(struct n
 }
 
 /*
- * nss_gre_stats_base_sync()
+ * nss_gre_stats_base_debug_sync()
  *	Debug statistics sync for GRE base node.
  */
-void nss_gre_stats_base_sync(struct nss_ctx_instance *nss_ctx, struct nss_gre_base_stats_msg *bstats)
+void nss_gre_stats_base_debug_sync(struct nss_ctx_instance *nss_ctx, struct nss_gre_base_stats_msg *bstats)
 {
 	int i;
 
 	spin_lock_bh(&nss_gre_stats_lock);
-	for (i = 0; i < NSS_GRE_BASE_DEBUG_MAX; i++) {
-		base_stats.stats[i] += bstats->stats[i];
+	for (i = 0; i < NSS_GRE_STATS_BASE_DEBUG_MAX; i++) {
+		base_debug_stats.stats[i] += bstats->stats[i];
 	}
 	spin_unlock_bh(&nss_gre_stats_lock);
 }
 
 /*
- * nss_gre_stats_session_get()
+ * nss_gre_stats_session_debug_get()
  *	Get GRE session debug statistics.
  */
-static void nss_gre_stats_session_get(void *stats_mem, int size)
+static void nss_gre_stats_session_debug_get(void *stats_mem, int size)
 {
-	struct nss_gre_stats_session *stats = (struct nss_gre_stats_session *)stats_mem;
+	struct nss_gre_stats_session_debug *stats = (struct nss_gre_stats_session_debug *)stats_mem;
 	int i;
 
-	if (!stats || (size < (sizeof(struct nss_gre_stats_session) * NSS_GRE_MAX_DEBUG_SESSION_STATS)))  {
+	if (!stats || (size < (sizeof(struct nss_gre_stats_session_debug) * NSS_GRE_MAX_DEBUG_SESSION_STATS)))  {
 		nss_warning("No memory to copy gre stats");
 		return;
 	}
 
 	spin_lock_bh(&nss_gre_stats_lock);
 	for (i = 0; i < NSS_GRE_MAX_DEBUG_SESSION_STATS; i++) {
-		if (session_stats[i].valid) {
-			memcpy(stats, &session_stats[i], sizeof(struct nss_gre_stats_session));
+		if (session_debug_stats[i].valid) {
+			memcpy(stats, &session_debug_stats[i], sizeof(struct nss_gre_stats_session_debug));
 			stats++;
 		}
 	}
@@ -146,25 +183,25 @@ static void nss_gre_stats_session_get(vo
 }
 
 /*
- * nss_gre_stats_base_get()
+ * nss_gre_stats_base_debug_get()
  *	Get GRE debug base statistics.
  */
-static void nss_gre_stats_base_get(void *stats_mem, int size)
+static void nss_gre_stats_base_debug_get(void *stats_mem, int size)
 {
-	struct nss_gre_stats_base *stats = (struct nss_gre_stats_base *)stats_mem;
+	struct nss_gre_stats_base_debug *stats = (struct nss_gre_stats_base_debug *)stats_mem;
 
 	if (!stats) {
 		nss_warning("No memory to copy GRE base stats\n");
 		return;
 	}
 
-	if (size < sizeof(struct nss_gre_stats_base)) {
+	if (size < sizeof(struct nss_gre_stats_base_debug)) {
 		nss_warning("Not enough memory to copy GRE base stats\n");
 		return;
 	}
 
 	spin_lock_bh(&nss_gre_stats_lock);
-	memcpy(stats, &base_stats, sizeof(struct nss_gre_stats_base));
+	memcpy(stats, &base_debug_stats, sizeof(struct nss_gre_stats_base_debug));
 	spin_unlock_bh(&nss_gre_stats_lock);
 }
 
@@ -176,15 +213,15 @@ static ssize_t nss_gre_stats_read(struct
 {
 	uint32_t max_output_lines = 2 /* header & footer for base debug stats */
 		+ 2 /* header & footer for session debug stats */
-		+ NSS_GRE_BASE_DEBUG_MAX  /* Base debug */
-		+ NSS_GRE_MAX_DEBUG_SESSION_STATS * (NSS_GRE_SESSION_DEBUG_MAX + 2) /*session stats */
+		+ NSS_GRE_STATS_BASE_DEBUG_MAX  /* Base debug */
+		+ NSS_GRE_MAX_DEBUG_SESSION_STATS * (NSS_GRE_STATS_SESSION_DEBUG_MAX + 2) /*session stats */
 		+ 2;
 	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
 	size_t size_wr = 0;
 	ssize_t bytes_read = 0;
 	struct net_device *dev;
-	struct nss_gre_stats_session *sstats;
-	struct nss_gre_stats_base *bstats;
+	struct nss_gre_stats_session_debug *sstats;
+	struct nss_gre_stats_base_debug *bstats;
 	int id;
 
 	char *lbuf = kzalloc(size_al, GFP_KERNEL);
@@ -193,14 +230,14 @@ static ssize_t nss_gre_stats_read(struct
 		return 0;
 	}
 
-	bstats = kzalloc(sizeof(struct nss_gre_stats_base), GFP_KERNEL);
+	bstats = kzalloc(sizeof(struct nss_gre_stats_base_debug), GFP_KERNEL);
 	if (unlikely(!bstats)) {
 		nss_warning("Could not allocate memory for base debug statistics buffer");
 		kfree(lbuf);
 		return 0;
 	}
 
-	sstats = kzalloc(sizeof(struct nss_gre_stats_session) * NSS_GRE_MAX_DEBUG_SESSION_STATS, GFP_KERNEL);
+	sstats = kzalloc(sizeof(struct nss_gre_stats_session_debug) * NSS_GRE_MAX_DEBUG_SESSION_STATS, GFP_KERNEL);
 	if (unlikely(!sstats)) {
 		nss_warning("Could not allocate memory for base debug statistics buffer");
 		kfree(lbuf);
@@ -213,18 +250,18 @@ static ssize_t nss_gre_stats_read(struct
 	/*
 	 * Get all base stats
 	 */
-	nss_gre_stats_base_get((void *)bstats, sizeof(struct nss_gre_stats_base));
+	nss_gre_stats_base_debug_get((void *)bstats, sizeof(struct nss_gre_stats_base_debug));
 
 	size_wr += nss_stats_print("gre", NULL, NSS_STATS_SINGLE_INSTANCE
-					, nss_gre_strings_base_stats
+					, nss_gre_stats_base_debug_str
 					, bstats->stats
-					, NSS_GRE_BASE_DEBUG_MAX
+					, NSS_GRE_STATS_BASE_DEBUG_MAX
 					, lbuf, size_wr, size_al);
 
 	/*
 	 * Get all session stats
 	 */
-	nss_gre_stats_session_get(sstats, sizeof(struct nss_gre_stats_session) * NSS_GRE_MAX_DEBUG_SESSION_STATS);
+	nss_gre_stats_session_debug_get(sstats, sizeof(struct nss_gre_stats_session_debug) * NSS_GRE_MAX_DEBUG_SESSION_STATS);
 
 	for (id = 0; id < NSS_GRE_MAX_DEBUG_SESSION_STATS; id++) {
 
@@ -243,9 +280,9 @@ static ssize_t nss_gre_stats_read(struct
 					     (sstats + id)->if_num);
 		}
 		size_wr += nss_stats_print("gre_session", NULL, id
-						, nss_gre_strings_session_stats
+						, nss_gre_stats_session_debug_str
 						, (sstats + id)->stats
-						, NSS_GRE_SESSION_DEBUG_MAX
+						, NSS_GRE_STATS_SESSION_DEBUG_MAX
 						, lbuf, size_wr, size_al);
 		size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\n");
 	}
@@ -272,67 +309,3 @@ void nss_gre_stats_dentry_create(void)
 	nss_stats_create_dentry("gre", &nss_gre_stats_ops);
 }
 
-/*
- * nss_gre_stats_base_notify()
- *	Sends notifications to all the registered modules.
- *
- * Leverage NSS-FW statistics timing to update Netlink.
- */
-void nss_gre_stats_base_notify(struct nss_ctx_instance *nss_ctx)
-{
-	struct nss_gre_base_stats_notification gre_stats;
-
-	spin_lock_bh(&nss_gre_stats_lock);
-	gre_stats.core_id = nss_ctx->id;
-	memcpy(gre_stats.stats_base_ctx, base_stats.stats, sizeof(gre_stats.stats_base_ctx));
-	spin_unlock_bh(&nss_gre_stats_lock);
-
-	atomic_notifier_call_chain(&nss_gre_stats_notifier, NSS_STATS_EVENT_NOTIFY, &gre_stats);
-}
-
-/*
- * nss_gre_stats_session_notify()
- *	Sends notifications to all the registered modules.
- *
- * Leverage NSS-FW statistics timing to update Netlink.
- */
-void nss_gre_stats_session_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num)
-{
-	struct nss_gre_session_stats_notification gre_stats;
-	int i;
-
-	spin_lock_bh(&nss_gre_stats_lock);
-	for (i = 0; i < NSS_GRE_MAX_DEBUG_SESSION_STATS; i++) {
-		if (session_stats[i].if_num != if_num) {
-			continue;
-		}
-
-		memcpy(gre_stats.stats_session_ctx, session_stats[i].stats, sizeof(gre_stats.stats_session_ctx));
-		gre_stats.core_id = nss_ctx->id;
-		gre_stats.if_num = if_num;
-		spin_unlock_bh(&nss_gre_stats_lock);
-		atomic_notifier_call_chain(&nss_gre_stats_notifier, NSS_STATS_EVENT_NOTIFY, &gre_stats);
-		return;
-	}
-	spin_unlock_bh(&nss_gre_stats_lock);
-}
-
-/*
- * nss_gre_stats_unregister_notifier()
- *	Deregisters statistics notifier.
- */
-int nss_gre_stats_unregister_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_unregister(&nss_gre_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_gre_stats_unregister_notifier);
-
-/*
- * nss_gre_stats_register_notifier()
- *	Registers statistics notifier.
- */
-int nss_gre_stats_register_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_register(&nss_gre_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_gre_stats_register_notifier);
--- a/nss_gre_stats.h
+++ b/nss_gre_stats.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017, 2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -22,32 +22,72 @@
 #ifndef __NSS_GRE_STATS_H
 #define __NSS_GRE_STATS_H
 
-#include <nss_cmn.h>
+/*
+ * GRE base debug statistics types
+ */
+enum nss_gre_stats_base_debug_types {
+	NSS_GRE_STATS_BASE_RX_PACKETS,			/**< Rx packet count. */
+	NSS_GRE_STATS_BASE_RX_DROPPED,			/**< Rx dropped count. */
+	NSS_GRE_STATS_BASE_EXP_ETH_HDR_MISSING,		/**< Ethernet header missing. */
+	NSS_GRE_STATS_BASE_EXP_ETH_TYPE_NON_IP,		/**< Not IPV4 or IPV6 packet. */
+	NSS_GRE_STATS_BASE_EXP_IP_UNKNOWN_PROTOCOL,	/**< Unknown protocol. */
+	NSS_GRE_STATS_BASE_EXP_IP_HEADER_INCOMPLETE,	/**< Bad IP header. */
+	NSS_GRE_STATS_BASE_EXP_IP_BAD_TOTAL_LENGTH,	/**< Invalid IP packet length. */
+	NSS_GRE_STATS_BASE_EXP_IP_BAD_CHECKSUM,		/**< Bad packet checksum. */
+	NSS_GRE_STATS_BASE_EXP_IP_DATAGRAM_INCOMPLETE,	/**< Bad packet. */
+	NSS_GRE_STATS_BASE_EXP_IP_FRAGMENT,		/**< IP fragment. */
+	NSS_GRE_STATS_BASE_EXP_IP_OPTIONS_INCOMPLETE,	/**< Invalid IP options. */
+	NSS_GRE_STATS_BASE_EXP_IP_WITH_OPTIONS,		/**< IP packet with options. */
+	NSS_GRE_STATS_BASE_EXP_IPV6_UNKNOWN_PROTOCOL,	/**< Unknown protocol. */
+	NSS_GRE_STATS_BASE_EXP_IPV6_HEADER_INCOMPLETE,	/**< Incomplete IPV6 header. */
+	NSS_GRE_STATS_BASE_EXP_GRE_UNKNOWN_SESSION,	/**< Unknown GRE session. */
+	NSS_GRE_STATS_BASE_EXP_GRE_NODE_INACTIVE,	/**< GRE node inactive. */
+	NSS_GRE_STATS_BASE_DEBUG_MAX,			/**< GRE base error max. */
+};
 
 /*
  *  GRE base debug statistics
  */
-struct nss_gre_stats_base {
-	uint64_t stats[NSS_GRE_BASE_DEBUG_MAX];	/**< GRE debug statistics. */
+struct nss_gre_stats_base_debug	{
+	uint64_t stats[NSS_GRE_STATS_BASE_DEBUG_MAX];	/**< GRE debug statistics. */
+};
+
+/*
+ * GRE session debug statistics types
+ */
+enum nss_gre_stats_session_debug_types {
+	NSS_GRE_STATS_SESSION_PBUF_ALLOC_FAIL,			/**< Pbuf alloc failure. */
+	NSS_GRE_STATS_SESSION_DECAP_FORWARD_ENQUEUE_FAIL,	/**< Rx forward enqueue failure. */
+	NSS_GRE_STATS_SESSION_ENCAP_FORWARD_ENQUEUE_FAIL,	/**< Tx forward enqueue failure. */
+	NSS_GRE_STATS_SESSION_DECAP_TX_FORWARDED,		/**< Packets forwarded after decap. */
+	NSS_GRE_STATS_SESSION_ENCAP_RX_RECEIVED,		/**< Packets received for encap. */
+	NSS_GRE_STATS_SESSION_ENCAP_RX_DROPPED,			/**< Packets dropped while enqueue for encap. */
+	NSS_GRE_STATS_SESSION_ENCAP_RX_LINEAR_FAIL,		/**< Packets dropped during encap linearization. */
+	NSS_GRE_STATS_SESSION_EXP_RX_KEY_ERROR,			/**< Rx KEY error. */
+	NSS_GRE_STATS_SESSION_EXP_RX_SEQ_ERROR,			/**< Rx sequence number error. */
+	NSS_GRE_STATS_SESSION_EXP_RX_CS_ERROR,			/**< Rx checksum error. */
+	NSS_GRE_STATS_SESSION_EXP_RX_FLAG_MISMATCH,		/**< Rx flag mismatch. */
+	NSS_GRE_STATS_SESSION_EXP_RX_MALFORMED,			/**< Rx malformed packet. */
+	NSS_GRE_STATS_SESSION_EXP_RX_INVALID_PROTOCOL,		/**< Rx invalid protocol. */
+	NSS_GRE_STATS_SESSION_EXP_RX_NO_HEADROOM,		/**< Rx no headroom. */
+	NSS_GRE_STATS_SESSION_DEBUG_MAX,			/**< Session debug max. */
 };
 
 /*
  *  GRE session debug statistics
  */
-struct nss_gre_stats_session {
-	uint64_t stats[NSS_GRE_SESSION_DEBUG_MAX];	/**< Session debug statistics. */
-	int32_t if_index;				/**< Netdevice's ifindex. */
-	uint32_t if_num;				/**< NSS interface number. */
-	bool valid;					/**< Is node valid ? */
+struct nss_gre_stats_session_debug {
+	uint64_t stats[NSS_GRE_STATS_SESSION_DEBUG_MAX];	/**< Session debug statistics. */
+	int32_t if_index;					/**< Netdevice's ifindex. */
+	uint32_t if_num;					/**< NSS interface number. */
+	bool valid;						/**< Is node valid ? */
 };
 
 /*
  * GRE statistics APIs
  */
-extern void nss_gre_stats_base_notify(struct nss_ctx_instance *nss_ctx);
-extern void nss_gre_stats_session_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num);
-extern void nss_gre_stats_session_sync(struct nss_ctx_instance *nss_ctx, struct nss_gre_session_stats_msg *sstats, uint16_t if_num);
-extern void nss_gre_stats_base_sync(struct nss_ctx_instance *nss_ctx, struct nss_gre_base_stats_msg *bstats);
+extern void nss_gre_stats_session_debug_sync(struct nss_ctx_instance *nss_ctx, struct nss_gre_session_stats_msg *sstats, uint16_t if_num);
+extern void nss_gre_stats_base_debug_sync(struct nss_ctx_instance *nss_ctx, struct nss_gre_base_stats_msg *bstats);
 extern void nss_gre_stats_session_register(uint32_t if_num, struct net_device *netdev);
 extern void nss_gre_stats_session_unregister(uint32_t if_num);
 extern void nss_gre_stats_dentry_create(void);
--- a/nss_gre_strings.c
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
- ***************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ***************************************************************************
- */
-
-#include "nss_stats.h"
-#include "nss_core.h"
-#include "nss_strings.h"
-#include "nss_gre_strings.h"
-
-/*
- * nss_gre_strings_base_stats
- *	GRE debug statistics strings for base types
- */
-struct nss_stats_info nss_gre_strings_base_stats[NSS_GRE_BASE_DEBUG_MAX] = {
-	{"base_rx_pkts",			NSS_STATS_TYPE_COMMON},
-	{"base_rx_drops",			NSS_STATS_TYPE_DROP},
-	{"base_exp_eth_hdr_missing",		NSS_STATS_TYPE_EXCEPTION},
-	{"base_exp_eth_type_non_ip",		NSS_STATS_TYPE_EXCEPTION},
-	{"base_exp_ip_unknown_protocol",	NSS_STATS_TYPE_EXCEPTION},
-	{"base_exp_ip_header_incomplete",	NSS_STATS_TYPE_EXCEPTION},
-	{"base_exp_ip_bad_total_length",	NSS_STATS_TYPE_EXCEPTION},
-	{"base_exp_ip_bad_checksum",		NSS_STATS_TYPE_EXCEPTION},
-	{"base_exp_ip_datagram_incomplete",	NSS_STATS_TYPE_EXCEPTION},
-	{"base_exp_ip_fragment",		NSS_STATS_TYPE_EXCEPTION},
-	{"base_exp_ip_options_incomplete",	NSS_STATS_TYPE_EXCEPTION},
-	{"base_exp_ip_with_options",		NSS_STATS_TYPE_EXCEPTION},
-	{"base_exp_ipv6_unknown_protocol",	NSS_STATS_TYPE_EXCEPTION},
-	{"base_exp_ipv6_header_incomplete",	NSS_STATS_TYPE_EXCEPTION},
-	{"base_exp_unknown_session",		NSS_STATS_TYPE_EXCEPTION},
-	{"base_exp_node_inactive",		NSS_STATS_TYPE_EXCEPTION}
-};
-
-/*
- * nss_gre_base_strings_read()
- *	 Read GRE base debug statistics names
- */
-static ssize_t nss_gre_base_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_gre_strings_base_stats, NSS_GRE_BASE_DEBUG_MAX);
-}
-
-/*
- * nss_gre_base_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(gre_base);
-
-/*
- * nss_gre_strings_session_stats
- *	GRE debug statistics strings for sessions
- */
-struct nss_stats_info nss_gre_strings_session_stats[NSS_GRE_SESSION_DEBUG_MAX] = {
-	{"session_pbuf_alloc_fail",		NSS_STATS_TYPE_ERROR},
-	{"session_decap_forward_enqueue_fail",	NSS_STATS_TYPE_DROP},
-	{"session_encap_forward_enqueue_fail",	NSS_STATS_TYPE_DROP},
-	{"session_decap_tx_forwarded",		NSS_STATS_TYPE_SPECIAL},
-	{"session_encap_rx_received",		NSS_STATS_TYPE_SPECIAL},
-	{"session_encap_rx_drops",		NSS_STATS_TYPE_DROP},
-	{"session_encap_rx_linear_fail",	NSS_STATS_TYPE_DROP},
-	{"session_exp_rx_key_error",		NSS_STATS_TYPE_EXCEPTION},
-	{"session_exp_rx_seq_error",		NSS_STATS_TYPE_EXCEPTION},
-	{"session_exp_rx_cs_error",		NSS_STATS_TYPE_EXCEPTION},
-	{"session_exp_rx_flag_mismatch",	NSS_STATS_TYPE_EXCEPTION},
-	{"session_exp_rx_malformed",		NSS_STATS_TYPE_EXCEPTION},
-	{"session_exp_rx_invalid_protocol",	NSS_STATS_TYPE_EXCEPTION},
-	{"session_exp_rx_no_headroom",		NSS_STATS_TYPE_EXCEPTION}
-};
-
-/*
- * nss_gre_session_strings_read()
- *	Read GRE session debug statistics names
- */
-static ssize_t nss_gre_session_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_gre_strings_session_stats, NSS_GRE_SESSION_DEBUG_MAX);
-}
-
-/*
- * nss_gre_session_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(gre_session);
-
-/*
- * nss_gre_strings_dentry_create()
- *	Create gre statistics strings debug entry.
- */
-void nss_gre_strings_dentry_create(void)
-{
-	struct dentry *gre_d = NULL;
-
-	if (!nss_top_main.strings_dentry) {
-		nss_warning("qca-nss-drv/strings is not present");
-		return;
-	}
-
-	gre_d = debugfs_create_dir("gre", nss_top_main.strings_dentry);
-	if (!gre_d) {
-		nss_warning("Failed to create qca-nss-drv/strings/gre directory");
-		return;
-	}
-
-	if (!debugfs_create_file("gre_base", 0400, gre_d, &nss_top_main, &nss_gre_base_strings_ops)) {
-		nss_warning("Failed to create qca-nss-drv/strings/gre/gre_base file");
-		debugfs_remove_recursive(gre_d);
-		return;
-	}
-
-	if (!debugfs_create_file("gre_session", 0400, gre_d, &nss_top_main, &nss_gre_session_strings_ops)) {
-		nss_warning("Failed to create qca-nss-drv/strings/gre/gre_session file");
-		debugfs_remove_recursive(gre_d);
-		return;
-	}
-}
--- a/nss_gre_strings.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- ****************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ****************************************************************************
- */
-
-#ifndef __NSS_GRE_STRINGS_H
-#define __NSS_GRE_STRINGS_H
-
-#include "nss_gre_stats.h"
-
-extern struct nss_stats_info nss_gre_strings_base_stats[NSS_GRE_BASE_DEBUG_MAX];
-extern struct nss_stats_info nss_gre_strings_session_stats[NSS_GRE_SESSION_DEBUG_MAX];
-extern void nss_gre_strings_dentry_create(void);
-
-#endif /* __NSS_GRE_STRINGS_H */
--- a/nss_gre_tunnel.c
+++ b/nss_gre_tunnel.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -17,7 +17,6 @@
 #include "nss_tx_rx_common.h"
 #include "nss_gre_tunnel_stats.h"
 #include "nss_gre_tunnel_log.h"
-#include "nss_gre_tunnel_strings.h"
 
 #define NSS_GRE_TUNNEL_TX_TIMEOUT 3000 /* 3 Seconds */
 
@@ -90,7 +89,6 @@ static void nss_gre_tunnel_handler(struc
 	switch (ngtm->cm.type) {
 	case NSS_GRE_TUNNEL_MSG_STATS:
 		nss_gre_tunnel_stats_session_sync(nss_ctx, &ngtm->msg.stats, ncm->interface);
-		nss_gre_tunnel_stats_notify(nss_ctx, ncm->interface);
 		break;
 	}
 
@@ -320,16 +318,16 @@ struct nss_ctx_instance *nss_gre_tunnel_
 
 	BUG_ON(!nss_gre_tunnel_verify_if_num(if_num));
 
-	spin_lock_bh(&nss_gre_tunnel_stats_lock);
+	spin_lock_bh(&nss_gre_tunnel_stats_session_debug_lock);
 	for (i = 0; i < NSS_MAX_GRE_TUNNEL_SESSIONS; i++) {
-		if (!session_stats[i].valid) {
-			session_stats[i].valid = true;
-			session_stats[i].if_num = if_num;
-			session_stats[i].if_index = netdev->ifindex;
+		if (!nss_gre_tunnel_session_debug_stats[i].valid) {
+			nss_gre_tunnel_session_debug_stats[i].valid = true;
+			nss_gre_tunnel_session_debug_stats[i].if_num = if_num;
+			nss_gre_tunnel_session_debug_stats[i].if_index = netdev->ifindex;
 			break;
 		}
 	}
-	spin_unlock_bh(&nss_gre_tunnel_stats_lock);
+	spin_unlock_bh(&nss_gre_tunnel_stats_session_debug_lock);
 
 	if (i == NSS_MAX_GRE_TUNNEL_SESSIONS) {
 		nss_warning("%px: Cannot find free slot for GRE Tunnel session stats, I/F:%u\n", nss_ctx, if_num);
@@ -338,9 +336,9 @@ struct nss_ctx_instance *nss_gre_tunnel_
 
 	if (nss_ctx->subsys_dp_register[if_num].ndev) {
 		nss_warning("%px: Cannot find free slot for GRE Tunnel NSS I/F:%u\n", nss_ctx, if_num);
-		session_stats[i].valid = false;
-		session_stats[i].if_num = 0;
-		session_stats[i].if_index = 0;
+		nss_gre_tunnel_session_debug_stats[i].valid = false;
+		nss_gre_tunnel_session_debug_stats[i].if_num = 0;
+		nss_gre_tunnel_session_debug_stats[i].if_index = 0;
 		return NULL;
 	}
 
@@ -349,7 +347,6 @@ struct nss_ctx_instance *nss_gre_tunnel_
 	nss_top_main.gre_tunnel_msg_callback = ev_cb;
 	nss_core_register_handler(nss_ctx, if_num, nss_gre_tunnel_handler, app_ctx);
 	nss_gre_tunnel_stats_dentry_create();
-	nss_gre_tunnel_strings_dentry_create();
 
 	return nss_ctx;
 }
@@ -366,15 +363,15 @@ void nss_gre_tunnel_unregister_if(uint32
 
 	BUG_ON(!nss_gre_tunnel_verify_if_num(if_num));
 
-	spin_lock_bh(&nss_gre_tunnel_stats_lock);
+	spin_lock_bh(&nss_gre_tunnel_stats_session_debug_lock);
 	for (i = 0; i < NSS_MAX_GRE_TUNNEL_SESSIONS; i++) {
-		if (session_stats[i].if_num == if_num) {
-			memset(&session_stats[i], 0,
-				sizeof(struct nss_gre_tunnel_stats_session));
+		if (nss_gre_tunnel_session_debug_stats[i].if_num == if_num) {
+			memset(&nss_gre_tunnel_session_debug_stats[i], 0,
+			       sizeof(struct nss_gre_tunnel_stats_session_debug));
 			break;
 		}
 	}
-	spin_unlock_bh(&nss_gre_tunnel_stats_lock);
+	spin_unlock_bh(&nss_gre_tunnel_stats_session_debug_lock);
 
 	if (i == NSS_MAX_GRE_TUNNEL_SESSIONS) {
 		nss_warning("%px: Cannot find debug stats for GRE Tunnel session: %d\n", nss_ctx, if_num);
--- a/nss_gre_tunnel_stats.c
+++ b/nss_gre_tunnel_stats.c
@@ -1,6 +1,6 @@
 /*
- ****************************************************************************
- * Copyright (c) 2017, 2020-2021, The Linux Foundation. All rights reserved.
+ **************************************************************************
+ * Copyright (c) 2017, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -11,25 +11,48 @@
  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
  * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ****************************************************************************
+ **************************************************************************
  */
 
 #include "nss_tx_rx_common.h"
-#include "nss_gre_tunnel.h"
 #include "nss_gre_tunnel_stats.h"
-#include "nss_gre_tunnel_strings.h"
 
-/*
- * Declare atomic notifier data structure for statistics.
- */
-ATOMIC_NOTIFIER_HEAD(nss_gre_tunnel_stats_notifier);
+DEFINE_SPINLOCK(nss_gre_tunnel_stats_session_debug_lock);
+struct nss_gre_tunnel_stats_session_debug nss_gre_tunnel_session_debug_stats[NSS_MAX_GRE_TUNNEL_SESSIONS];
 
 /*
- * Spinlock to protect gre tunnel statistics update/read
+ * nss_gre_tunnel_stats_session_debug_str
+ *	GRE Tunnel statistics strings for nss session stats
  */
-DEFINE_SPINLOCK(nss_gre_tunnel_stats_lock);
-
-struct nss_gre_tunnel_stats_session session_stats[NSS_MAX_GRE_TUNNEL_SESSIONS];
+static int8_t *nss_gre_tunnel_stats_session_debug_str[NSS_GRE_TUNNEL_STATS_SESSION_MAX] = {
+	"RX_PKTS",
+	"TX_PKTS",
+	"RX_QUEUE_0_DROPPED",
+	"RX_QUEUE_1_DROPPED",
+	"RX_QUEUE_2_DROPPED",
+	"RX_QUEUE_3_DROPPED",
+	"RX_MALFORMED",
+	"RX_INVALID_PROT",
+	"DECAP_QUEUE_FULL",
+	"RX_SINGLE_REC_DGRAM",
+	"RX_INVALID_REC_DGRAM",
+	"BUFFER_ALLOC_FAIL",
+	"BUFFER_COPY_FAIL",
+	"OUTFLOW_QUEUE_FULL",
+	"TX_DROPPED_HROOM",
+	"RX_CBUFFER_ALLOC_FAIL",
+	"RX_CENQUEUE_FAIL",
+	"RX_DECRYPT_DONE",
+	"RX_FORWARD_ENQUEUE_FAIL",
+	"TX_CBUFFER_ALLOC_FAIL",
+	"TX_CENQUEUE_FAIL",
+	"TX_DROPPED_TROOM",
+	"TX_FORWARD_ENQUEUE_FAIL",
+	"TX_CIPHER_DONE",
+	"CRYPTO_NOSUPP",
+	"RX_DROPPED_MH_VERSION",
+	"RX_UNALIGNED_PKT",
+};
 
 /*
  * nss_gre_tunnel_stats_session_sync()
@@ -39,20 +62,20 @@ void nss_gre_tunnel_stats_session_sync(s
 					uint16_t if_num)
 {
 	int i;
-	struct nss_gre_tunnel_stats_session *s = NULL;
+	struct nss_gre_tunnel_stats_session_debug *s = NULL;
 
 	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 
-	spin_lock_bh(&nss_gre_tunnel_stats_lock);
+	spin_lock_bh(&nss_gre_tunnel_stats_session_debug_lock);
 	for (i = 0; i < NSS_MAX_GRE_TUNNEL_SESSIONS; i++) {
-		if (session_stats[i].if_num == if_num) {
-			s = &session_stats[i];
+		if (nss_gre_tunnel_session_debug_stats[i].if_num == if_num) {
+			s = &nss_gre_tunnel_session_debug_stats[i];
 			break;
 		}
 	}
 
 	if (!s) {
-		spin_unlock_bh(&nss_gre_tunnel_stats_lock);
+		spin_unlock_bh(&nss_gre_tunnel_stats_session_debug_lock);
 		nss_warning("%px: Session not found: %u", nss_ctx, if_num);
 		return;
 	}
@@ -95,14 +118,14 @@ void nss_gre_tunnel_stats_session_sync(s
 #endif
 	}
 
-	spin_unlock_bh(&nss_gre_tunnel_stats_lock);
+	spin_unlock_bh(&nss_gre_tunnel_stats_session_debug_lock);
 }
 
 /*
- * nss_gre_tunnel_stats_session_get()
+ * nss_gre_tunnel_stats_session_debug_get()
  *	Get session GRE Tunnel statitics.
  */
-static void nss_gre_tunnel_stats_session_get(struct nss_gre_tunnel_stats_session *stats)
+static void nss_gre_tunnel_stats_session_debug_get(struct nss_gre_tunnel_stats_session_debug *stats)
 {
 	int i;
 
@@ -111,15 +134,15 @@ static void nss_gre_tunnel_stats_session
 		return;
 	}
 
-	spin_lock_bh(&nss_gre_tunnel_stats_lock);
+	spin_lock_bh(&nss_gre_tunnel_stats_session_debug_lock);
 	for (i = 0; i < NSS_MAX_GRE_TUNNEL_SESSIONS; i++) {
-		if (session_stats[i].valid) {
-			memcpy(stats, &session_stats[i],
-				sizeof(struct nss_gre_tunnel_stats_session));
+		if (nss_gre_tunnel_session_debug_stats[i].valid) {
+			memcpy(stats, &nss_gre_tunnel_session_debug_stats[i],
+				sizeof(struct nss_gre_tunnel_stats_session_debug));
 			stats++;
 		}
 	}
-	spin_unlock_bh(&nss_gre_tunnel_stats_lock);
+	spin_unlock_bh(&nss_gre_tunnel_stats_session_debug_lock);
 }
 
 /*
@@ -134,10 +157,9 @@ static ssize_t nss_gre_tunnel_stats_read
 	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
 	size_t size_wr = 0;
 	ssize_t bytes_read = 0;
-	uint64_t *stats_shadow;
 	struct net_device *dev;
 	int id, i;
-	struct nss_gre_tunnel_stats_session *gre_tunnel_session_stats = NULL;
+	struct nss_gre_tunnel_stats_session_debug *gre_tunnel_session_stats = NULL;
 
 	char *lbuf = kzalloc(size_al, GFP_KERNEL);
 	if (unlikely(lbuf == NULL)) {
@@ -145,31 +167,24 @@ static ssize_t nss_gre_tunnel_stats_read
 		return 0;
 	}
 
-	stats_shadow = kzalloc(NSS_CRYPTO_CMN_RESP_ERROR_MAX * 8, GFP_KERNEL);
-	if (unlikely(!stats_shadow)) {
-		nss_warning("Could not allocate memory for local shadow buffer");
-		kfree(lbuf);
-		return 0;
-	}
-
-	gre_tunnel_session_stats = kzalloc((sizeof(struct nss_gre_tunnel_stats_session)
+	gre_tunnel_session_stats = kzalloc((sizeof(struct nss_gre_tunnel_stats_session_debug)
 						* NSS_MAX_GRE_TUNNEL_SESSIONS), GFP_KERNEL);
 	if (unlikely(gre_tunnel_session_stats == NULL)) {
 		nss_warning("Could not allocate memory for populating GRE Tunnel stats");
 		kfree(lbuf);
-		kfree(stats_shadow);
 		return 0;
 	}
 
 	/*
 	 * Get all stats
 	 */
-	nss_gre_tunnel_stats_session_get(gre_tunnel_session_stats);
+	nss_gre_tunnel_stats_session_debug_get(gre_tunnel_session_stats);
 
 	/*
 	 * Session stats
 	 */
-	size_wr += nss_stats_banner(lbuf, size_wr, size_al, "GRE tunnel stats", NSS_STATS_SINGLE_CORE);
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr,
+				"\nGRE Tunnel session stats start:\n\n");
 
 	for (id = 0; id < NSS_MAX_GRE_TUNNEL_SESSIONS; id++) {
 		if (!gre_tunnel_session_stats[id].valid)
@@ -188,33 +203,34 @@ static ssize_t nss_gre_tunnel_stats_read
 						gre_tunnel_session_stats[id].if_num);
 		}
 
-		size_wr += nss_stats_print("gre_tunnel", NULL, NSS_STATS_SINGLE_INSTANCE,
-					nss_gre_tunnel_strings_stats, gre_tunnel_session_stats[id].stats,
-					NSS_GRE_TUNNEL_STATS_SESSION_MAX, lbuf, size_wr, size_al);
+		for (i = 0; i < NSS_GRE_TUNNEL_STATS_SESSION_MAX; i++) {
+			size_wr += scnprintf(lbuf + size_wr, size_al - size_wr,
+						"\t%s = %llu\n",
+						nss_gre_tunnel_stats_session_debug_str[i],
+						gre_tunnel_session_stats[id].stats[i]);
+		}
 
 		/*
 		 * Print crypto resp err stats.
 		 * TODO: We are not printing with the right enum string for crypto. This
 		 * is intentional since we atleast want to see some stats for now.
 		 */
-		spin_lock_bh(&nss_gre_tunnel_stats_lock);
 		for (i = 0; i < NSS_CRYPTO_CMN_RESP_ERROR_MAX; i++) {
-			stats_shadow[i] = gre_tunnel_session_stats[id].stats[NSS_GRE_TUNNEL_STATS_SESSION_MAX + i];
+			size_wr += scnprintf(lbuf + size_wr, size_al - size_wr,
+						"\t%s = %llu\n",
+						nss_gre_tunnel_stats_session_debug_str[i],
+						gre_tunnel_session_stats[id].stats[NSS_GRE_TUNNEL_STATS_SESSION_MAX + i]);
 		}
 
-		spin_unlock_bh(&nss_gre_tunnel_stats_lock);
-		size_wr += nss_stats_print("gre_tunnel", NULL, NSS_STATS_SINGLE_INSTANCE,
-					nss_gre_tunnel_strings_stats, stats_shadow,
-					NSS_CRYPTO_CMN_RESP_ERROR_MAX, lbuf, size_wr, size_al);
-
 		size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\n");
 	}
 
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr,
+				"\nGRE Tunnel session stats end\n");
 	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, size_wr);
 
 	kfree(gre_tunnel_session_stats);
 	kfree(lbuf);
-	kfree(stats_shadow);
 	return bytes_read;
 }
 
@@ -231,52 +247,3 @@ void nss_gre_tunnel_stats_dentry_create(
 {
 	nss_stats_create_dentry("gre_tunnel", &nss_gre_tunnel_stats_ops);
 }
-
-/*
- * nss_gre_tunnel_stats_notify()
- *	Sends notifications to all the registered modules.
- *
- * Leverage NSS-FW statistics timing to update Netlink.
- */
-void nss_gre_tunnel_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num)
-{
-	struct nss_gre_tunnel_stats_notification gre_tunnel_stats;
-	struct nss_gre_tunnel_stats_session *s = NULL;
-	int i;
-
-	spin_lock_bh(&nss_gre_tunnel_stats_lock);
-	for (i = 0; i < NSS_MAX_GRE_TUNNEL_SESSIONS; i++) {
-		if (session_stats[i].if_num != if_num) {
-			continue;
-		}
-
-		s = &session_stats[i];
-		gre_tunnel_stats.core_id = nss_ctx->id;
-		gre_tunnel_stats.if_num = if_num;
-		memcpy(gre_tunnel_stats.stats_ctx, s->stats, sizeof(gre_tunnel_stats.stats_ctx));
-		spin_unlock_bh(&nss_gre_tunnel_stats_lock);
-		atomic_notifier_call_chain(&nss_gre_tunnel_stats_notifier, NSS_STATS_EVENT_NOTIFY, &gre_tunnel_stats);
-		return;
-	}
-	spin_unlock_bh(&nss_gre_tunnel_stats_lock);
-}
-
-/*
- * nss_gre_tunnel_stats_unregister_notifier()
- *	Deregisters statistics notifier.
- */
-int nss_gre_tunnel_stats_unregister_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_unregister(&nss_gre_tunnel_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_gre_tunnel_stats_unregister_notifier);
-
-/*
- * nss_gre_tunnel_stats_register_notifier()
- *	Registers statistics notifier.
- */
-int nss_gre_tunnel_stats_register_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_register(&nss_gre_tunnel_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_gre_tunnel_stats_register_notifier);
--- a/nss_gre_tunnel_stats.h
+++ b/nss_gre_tunnel_stats.h
@@ -1,6 +1,6 @@
 /*
  ******************************************************************************
- * Copyright (c) 2016-2017, 2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2017, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -18,26 +18,58 @@
 #define __NSS_GRE_TUNNEL_STATS_H
 
 /*
+ * GRE Tunnel session debug statistic counters
+ */
+enum nss_gre_tunnel_stats_session {
+	NSS_GRE_TUNNEL_STATS_SESSION_RX_PKTS,
+	NSS_GRE_TUNNEL_STATS_SESSION_TX_PKTS,
+	NSS_GRE_TUNNEL_STATS_SESSION_RX_QUEUE_0_DROPPED,
+	NSS_GRE_TUNNEL_STATS_SESSION_RX_QUEUE_1_DROPPED,
+	NSS_GRE_TUNNEL_STATS_SESSION_RX_QUEUE_2_DROPPED,
+	NSS_GRE_TUNNEL_STATS_SESSION_RX_QUEUE_3_DROPPED,
+	NSS_GRE_TUNNEL_STATS_SESSION_RX_MALFORMED,
+	NSS_GRE_TUNNEL_STATS_SESSION_RX_INVALID_PROT,
+	NSS_GRE_TUNNEL_STATS_SESSION_DECAP_QUEUE_FULL,
+	NSS_GRE_TUNNEL_STATS_SESSION_RX_SINGLE_REC_DGRAM,
+	NSS_GRE_TUNNEL_STATS_SESSION_RX_INVALID_REC_DGRAM,
+	NSS_GRE_TUNNEL_STATS_SESSION_BUFFER_ALLOC_FAIL,
+	NSS_GRE_TUNNEL_STATS_SESSION_BUFFER_COPY_FAIL,
+	NSS_GRE_TUNNEL_STATS_SESSION_OUTFLOW_QUEUE_FULL,
+	NSS_GRE_TUNNEL_STATS_SESSION_RX_DROPPED_HROOM,
+	NSS_GRE_TUNNEL_STATS_SESSION_RX_CBUFFER_ALLOC_FAIL,
+	NSS_GRE_TUNNEL_STATS_SESSION_RX_CENQUEUE_FAIL,
+	NSS_GRE_TUNNEL_STATS_SESSION_RX_DECRYPT_DONE,
+	NSS_GRE_TUNNEL_STATS_SESSION_RX_FORWARD_ENQUEUE_FAIL,
+	NSS_GRE_TUNNEL_STATS_SESSION_TX_CBUFFER_ALLOC_FAIL,
+	NSS_GRE_TUNNEL_STATS_SESSION_TX_CENQUEUE_FAIL,
+	NSS_GRE_TUNNEL_STATS_SESSION_RX_DROPPED_TROOM,
+	NSS_GRE_TUNNEL_STATS_SESSION_TX_FORWARD_ENQUEUE_FAIL,
+	NSS_GRE_TUNNEL_STATS_SESSION_TX_CIPHER_DONE,
+	NSS_GRE_TUNNEL_STATS_SESSION_CRYPTO_NOSUPP,
+	NSS_GRE_TUNNEL_STATS_SESSION_RX_DROPPED_MH_VERSION,
+	NSS_GRE_TUNNEL_STATS_SESSION_RX_UNALIGNED_PKT,
+	NSS_GRE_TUNNEL_STATS_SESSION_MAX,
+};
+
+/*
  * GRE Tunnel session debug statistics
  */
-struct nss_gre_tunnel_stats_session {
+struct nss_gre_tunnel_stats_session_debug {
 	uint64_t stats[NSS_GRE_TUNNEL_STATS_SESSION_MAX + NSS_CRYPTO_CMN_RESP_ERROR_MAX];
-				/* GRE tunnel statistics */
-	int32_t if_index;	/* Interface index */
-	uint32_t if_num;	/* NSS interface number */
+	int32_t if_index;
+	uint32_t if_num; /* nss interface number */
 	bool valid;
 };
 
 /*
  * Data structures to store GRE Tunnel nss debug stats
  */
-extern spinlock_t nss_gre_tunnel_stats_lock;
-extern struct nss_gre_tunnel_stats_session session_stats[NSS_MAX_GRE_TUNNEL_SESSIONS];
+extern spinlock_t nss_gre_tunnel_stats_session_debug_lock;
+extern struct nss_gre_tunnel_stats_session_debug nss_gre_tunnel_session_debug_stats[NSS_MAX_GRE_TUNNEL_SESSIONS];
 
 /*
  * GRE Tunnel statistics APIs
  */
-extern void nss_gre_tunnel_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num);
 extern void nss_gre_tunnel_stats_session_sync(struct nss_ctx_instance *nss_ctx, struct nss_gre_tunnel_stats *stats_msg, uint16_t if_num);
 extern void nss_gre_tunnel_stats_dentry_create(void);
 
--- a/nss_gre_tunnel_strings.c
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- ****************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ****************************************************************************
- */
-
-#include "nss_stats.h"
-#include "nss_core.h"
-#include "nss_strings.h"
-#include "nss_gre_tunnel_strings.h"
-
-/*
- * nss_gre_tunnel_strings_stats
- *	GRE Tunnel statistics strings for nss session stats
- */
-struct nss_stats_info nss_gre_tunnel_strings_stats[NSS_GRE_TUNNEL_STATS_SESSION_MAX] = {
-	{"rx_pkts",			NSS_STATS_TYPE_COMMON},
-	{"tx_pkts",			NSS_STATS_TYPE_COMMON},
-	{"rx_queue_0_dropped",		NSS_STATS_TYPE_DROP},
-	{"rx_queue_1_dropped",		NSS_STATS_TYPE_DROP},
-	{"rx_queue_2_dropped",		NSS_STATS_TYPE_DROP},
-	{"rx_queue_3_dropped",		NSS_STATS_TYPE_DROP},
-	{"rx_malformed",		NSS_STATS_TYPE_SPECIAL},
-	{"rx_invalid_prot",		NSS_STATS_TYPE_SPECIAL},
-	{"decap_queue_full",		NSS_STATS_TYPE_SPECIAL},
-	{"rx_single_rec_dgram",		NSS_STATS_TYPE_SPECIAL},
-	{"rx_invalid_rec_dgram",	NSS_STATS_TYPE_SPECIAL},
-	{"buffer_alloc_fail",		NSS_STATS_TYPE_SPECIAL},
-	{"buffer_copy_fail",		NSS_STATS_TYPE_SPECIAL},
-	{"outflow_queue_full",		NSS_STATS_TYPE_SPECIAL},
-	{"tx_dropped_hroom",		NSS_STATS_TYPE_DROP},
-	{"rx_cbuffer_alloc_fail",	NSS_STATS_TYPE_SPECIAL},
-	{"rx_cenqueue_fail",		NSS_STATS_TYPE_SPECIAL},
-	{"rx_decrypt_done",		NSS_STATS_TYPE_SPECIAL},
-	{"rx_forward_enqueue_fail",	NSS_STATS_TYPE_SPECIAL},
-	{"tx_cbuffer_alloc_fail",	NSS_STATS_TYPE_SPECIAL},
-	{"tx_cenqueue_fail",		NSS_STATS_TYPE_SPECIAL},
-	{"rx_dropped_troom",		NSS_STATS_TYPE_DROP},
-	{"tx_forward_enqueue_fail",	NSS_STATS_TYPE_SPECIAL},
-	{"tx_cipher_done",		NSS_STATS_TYPE_SPECIAL},
-	{"crypto_nosupp",		NSS_STATS_TYPE_SPECIAL},
-	{"rx_dropped_mh_version",	NSS_STATS_TYPE_SPECIAL},
-	{"rx_unaligned_pkt",		NSS_STATS_TYPE_SPECIAL}
-};
-
-/*
- * nss_gre_tunnel_strings_read()
- *	Read gre_tunnel session debug statistics names
- */
-static ssize_t nss_gre_tunnel_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_gre_tunnel_strings_stats, NSS_GRE_TUNNEL_STATS_SESSION_MAX);
-}
-
-/*
- * nss_gre_tunnel_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(gre_tunnel);
-
-/*
- * nss_gre_tunnel_strings_dentry_create()
- *	Create gre_tunnel statistics strings debug entry.
- */
-void nss_gre_tunnel_strings_dentry_create(void)
-{
-	nss_strings_create_dentry("gre_tunnel", &nss_gre_tunnel_strings_ops);
-}
--- a/nss_gre_tunnel_strings.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- ****************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ****************************************************************************
- */
-
-#ifndef __NSS_GRE_TUNNEL_STRINGS_H
-#define __NSS_GRE_TUNNEL_STRINGS_H
-
-#include "nss_gre_tunnel_stats.h"
-
-extern struct nss_stats_info nss_gre_tunnel_strings_stats[NSS_GRE_TUNNEL_STATS_SESSION_MAX];
-extern void nss_gre_tunnel_strings_dentry_create(void);
-
-#endif /* __NSS_GRE_TUNNEL_STRINGS_H */
--- a/nss_hal/fsm9010/nss_hal_pvt.c
+++ b/nss_hal/fsm9010/nss_hal_pvt.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2015-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2015-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -145,13 +145,12 @@ static struct nss_platform_data *__nss_h
 	npd->nphys = res_nphys.start;
 	npd->vphys = res_vphys.start;
 
-	npd->nmap = ioremap_nocache(npd->nphys, resource_size(&res_nphys));
+	npd->nmap = ioremap(npd->nphys, resource_size(&res_nphys));
 	if (!npd->nmap) {
 		nss_info_always("%px: nss%d: ioremap() fail for nphys\n", nss_ctx, nss_ctx->id);
 		goto out;
 	}
 
-	nss_assert(npd->vphys);
 	npd->vmap = ioremap_cache(npd->vphys, resource_size(&res_vphys));
 	if (!npd->vmap) {
 		nss_info_always("%px: nss%d: ioremap() fail for vphys\n", nss_ctx, nss_ctx->id);
--- a/nss_hal/include/nss_hal.h
+++ b/nss_hal/include/nss_hal.h
@@ -1,12 +1,9 @@
 /*
  **************************************************************************
  * Copyright (c) 2013, 2016-2020 The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
- *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
- *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -52,9 +49,6 @@ extern struct nss_hal_ops nss_hal_ipq50x
 #if defined(NSS_HAL_FSM9010_SUPPORT)
 extern struct nss_hal_ops nss_hal_fsm9010_ops;
 #endif
-#if defined(NSS_HAL_IPQ95XX_SUPPORT)
-extern struct nss_hal_ops nss_hal_ipq95xx_ops;
-#endif
 
 #define NSS_HAL_SUPPORTED_INTERRUPTS (NSS_N2H_INTR_EMPTY_BUFFER_QUEUE | \
 					NSS_N2H_INTR_DATA_QUEUE_0 | \
--- a/nss_hal/include/nss_regs.h
+++ b/nss_hal/include/nss_regs.h
@@ -1,12 +1,9 @@
 /*
  **************************************************************************
  * Copyright (c) 2013, 2015-2017, 2019-2020, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
- *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
- *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -41,26 +38,16 @@
 #define NSS_REGS_C2C_INTR_CLR_OFFSET		0x001c
 #define NSS_REGS_N2H_INTR_STATUS_OFFSET		0x0020
 #define NSS_REGS_N2H_INTR_SET_OFFSET		0x0024
-
-#if defined(NSS_HAL_IPQ95XX_SUPPORT)
-#define NSS_REGS_CORE_INT_STAT0_ENABLE_OFFSET	0x0028
-#define NSS_REGS_CORE_INT_STAT1_ENABLE_OFFSET	0x002c
-#define NSS_REGS_CORE_INT_STAT2_ENABLE_OFFSET	0x0030
-#define NSS_REGS_CORE_INT_STAT3_ENABLE_OFFSET	0x0034
-#elif defined(NSS_HAL_FSM9010_SUPPORT) || defined(NSS_HAL_IPQ806X_SUPPORT)
 #define NSS_REGS_N2H_INTR_CLR_OFFSET		0x0028
 #define NSS_REGS_N2H_INTR_MASK_OFFSET		0x002c
 #define NSS_REGS_N2H_INTR_MASK_SET_OFFSET	0x0030
 #define NSS_REGS_N2H_INTR_MASK_CLR_OFFSET	0x0034
-#endif
-
 #define NSS_REGS_CORE_INT_STAT0_TYPE_OFFSET	0x0038
 #define NSS_REGS_CORE_INT_STAT1_TYPE_OFFSET	0x003c
 #define NSS_REGS_CORE_INT_STAT2_TYPE_OFFSET	0x0040
 #define NSS_REGS_CORE_INT_STAT3_TYPE_OFFSET	0x0044
 #define NSS_REGS_CORE_IFETCH_RANGE_OFFSET	0x0048
 
-
 /*
  * FPB register offsets
  */
--- a/nss_hal/ipq60xx/nss_hal_pvt.c
+++ b/nss_hal/ipq60xx/nss_hal_pvt.c
@@ -207,13 +207,13 @@ static struct nss_platform_data *__nss_h
 	npd->nphys = res_nphys.start;
 	npd->qgic_phys = res_qgic_phys.start;
 
-	npd->nmap = ioremap_nocache(npd->nphys, resource_size(&res_nphys));
+	npd->nmap = ioremap(npd->nphys, resource_size(&res_nphys));
 	if (!npd->nmap) {
 		nss_info_always("%px: nss%d: ioremap() fail for nphys\n", nss_ctx, nss_ctx->id);
 		goto out;
 	}
 
-	npd->qgic_map = ioremap_nocache(npd->qgic_phys, resource_size(&res_qgic_phys));
+	npd->qgic_map = ioremap(npd->qgic_phys, resource_size(&res_qgic_phys));
 	if (!npd->qgic_map) {
 		nss_info_always("%px: nss%d: ioremap() fail for qgic map\n", nss_ctx, nss_ctx->id);
 		goto out;
@@ -433,13 +433,13 @@ static int __nss_hal_common_reset(struct
 
 	of_node_put(cmn);
 
-	nss_misc_reset = ioremap_nocache(res_nss_misc_reset.start, resource_size(&res_nss_misc_reset));
+	nss_misc_reset = ioremap(res_nss_misc_reset.start, resource_size(&res_nss_misc_reset));
 	if (!nss_misc_reset) {
 		pr_err("%px: ioremap fail for nss_misc_reset\n", nss_dev);
 		return -EFAULT;
 	}
 
-	nss_misc_reset_flag = ioremap_nocache(res_nss_misc_reset_flag.start, resource_size(&res_nss_misc_reset_flag));
+	nss_misc_reset_flag = ioremap(res_nss_misc_reset_flag.start, resource_size(&res_nss_misc_reset_flag));
 	if (!nss_misc_reset_flag) {
 		pr_err("%px: ioremap fail for nss_misc_reset_flag\n", nss_dev);
 		return -EFAULT;
--- a/nss_hal/ipq806x/nss_hal_pvt.c
+++ b/nss_hal/ipq806x/nss_hal_pvt.c
@@ -458,7 +458,7 @@ static struct nss_platform_data *__nss_h
 	npd->nphys = res_nphys.start;
 	npd->vphys = res_vphys.start;
 
-	npd->nmap = ioremap_nocache(npd->nphys, resource_size(&res_nphys));
+	npd->nmap = ioremap(npd->nphys, resource_size(&res_nphys));
 	if (!npd->nmap) {
 		nss_info_always("%px: nss%d: ioremap() fail for nphys\n", nss_ctx, nss_ctx->id);
 		goto out;
@@ -711,7 +711,7 @@ static int __nss_hal_common_reset(struct
 	}
 	of_node_put(cmn);
 
-	fpb_base = ioremap_nocache(res_nss_fpb_base.start, resource_size(&res_nss_fpb_base));
+	fpb_base = ioremap(res_nss_fpb_base.start, resource_size(&res_nss_fpb_base));
 	if (!fpb_base) {
 		pr_err("%px: ioremap fail for nss_fpb_base\n", nss_dev);
 		return -EFAULT;
--- a/nss_hal/ipq807x/nss_hal_pvt.c
+++ b/nss_hal/ipq807x/nss_hal_pvt.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -234,20 +234,19 @@ static struct nss_platform_data *__nss_h
 	npd->vphys = res_vphys.start;
 	npd->qgic_phys = res_qgic_phys.start;
 
-	npd->nmap = ioremap_nocache(npd->nphys, resource_size(&res_nphys));
+	npd->nmap = ioremap(npd->nphys, resource_size(&res_nphys));
 	if (!npd->nmap) {
 		nss_info_always("%px: nss%d: ioremap() fail for nphys\n", nss_ctx, nss_ctx->id);
 		goto out;
 	}
 
-	nss_assert(npd->vphys);
 	npd->vmap = ioremap_cache(npd->vphys, resource_size(&res_vphys));
 	if (!npd->vmap) {
 		nss_info_always("%px: nss%d: ioremap() fail for vphys\n", nss_ctx, nss_ctx->id);
 		goto out;
 	}
 
-	npd->qgic_map = ioremap_nocache(npd->qgic_phys, resource_size(&res_qgic_phys));
+	npd->qgic_map = ioremap(npd->qgic_phys, resource_size(&res_qgic_phys));
 	if (!npd->qgic_map) {
 		nss_info_always("%px: nss%d: ioremap() fail for qgic map\n", nss_ctx, nss_ctx->id);
 		goto out;
@@ -467,7 +466,7 @@ static int __nss_hal_common_reset(struct
 	}
 	of_node_put(cmn);
 
-	nss_misc_reset = ioremap_nocache(res_nss_misc_reset.start, resource_size(&res_nss_misc_reset));
+	nss_misc_reset = ioremap(res_nss_misc_reset.start, resource_size(&res_nss_misc_reset));
 	if (!nss_misc_reset) {
 		pr_err("%px: ioremap fail for nss_misc_reset\n", nss_dev);
 		return -EFAULT;
--- a/nss_hal/nss_hal.c
+++ b/nss_hal/nss_hal.c
@@ -1,12 +1,9 @@
 /*
  **************************************************************************
  * Copyright (c) 2016-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
- *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
- *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -27,17 +24,13 @@
 #include <linux/firmware.h>
 #include <linux/of.h>
 #include <linux/irq.h>
+#include <linux/ethtool.h>
 
 #include "nss_hal.h"
 #include "nss_arch.h"
 #include "nss_core.h"
 #include "nss_tx_rx_common.h"
-#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 #include "nss_data_plane.h"
-#endif
-#ifdef NSS_DATA_PLANE_LITE_SUPPORT
-#include "nss_data_plane_lite.h"
-#endif
 #if (NSS_PM_SUPPORT == 1)
 #include "nss_pm.h"
 #endif
@@ -81,9 +74,9 @@ int nss_hal_firmware_load(struct nss_ctx
 	}
 
 
-	load_mem = ioremap_nocache(npd->load_addr, nss_fw->size);
+	load_mem = ioremap(npd->load_addr, nss_fw->size);
 	if (!load_mem) {
-		nss_info_always("%px: ioremap_nocache failed: %x", nss_ctx, npd->load_addr);
+		nss_info_always("%px: ioremap failed: %x", nss_ctx, npd->load_addr);
 		release_firmware(nss_fw);
 		return rc;
 	}
@@ -95,6 +88,7 @@ int nss_hal_firmware_load(struct nss_ctx
 	return 0;
 }
 
+
 /*
  * nss_hal_dt_parse_features()
  */
@@ -105,14 +99,12 @@ void nss_hal_dt_parse_features(struct de
 	 */
 	npd->bridge_enabled = of_property_read_bool(np, "qcom,bridge-enabled");
 	npd->capwap_enabled = of_property_read_bool(np, "qcom,capwap-enabled");
-	npd->clmap_enabled = of_property_read_bool(np, "qcom,clmap-enabled");
 	npd->crypto_enabled = of_property_read_bool(np, "qcom,crypto-enabled");
 	npd->dtls_enabled = of_property_read_bool(np, "qcom,dtls-enabled");
 	npd->gre_enabled = of_property_read_bool(np, "qcom,gre-enabled");
 	npd->gre_redir_enabled = of_property_read_bool(np, "qcom,gre-redir-enabled");
 	npd->gre_tunnel_enabled = of_property_read_bool(np, "qcom,gre_tunnel_enabled");
 	npd->gre_redir_mark_enabled = of_property_read_bool(np, "qcom,gre-redir-mark-enabled");
-	npd->igs_enabled = of_property_read_bool(np, "qcom,igs-enabled");
 	npd->ipsec_enabled = of_property_read_bool(np, "qcom,ipsec-enabled");
 	npd->ipv4_enabled = of_property_read_bool(np, "qcom,ipv4-enabled");
 	npd->ipv4_reasm_enabled = of_property_read_bool(np, "qcom,ipv4-reasm-enabled");
@@ -126,25 +118,19 @@ void nss_hal_dt_parse_features(struct de
 	npd->pptp_enabled = of_property_read_bool(np, "qcom,pptp-enabled");
 	npd->portid_enabled = of_property_read_bool(np, "qcom,portid-enabled");
 	npd->pvxlan_enabled = of_property_read_bool(np, "qcom,pvxlan-enabled");
+	npd->clmap_enabled = of_property_read_bool(np, "qcom,clmap-enabled");
 	npd->qvpn_enabled = of_property_read_bool(np, "qcom,qvpn-enabled");
 	npd->rmnet_rx_enabled = of_property_read_bool(np, "qcom,rmnet_rx-enabled");
 	npd->shaping_enabled = of_property_read_bool(np, "qcom,shaping-enabled");
-	npd->tls_enabled = of_property_read_bool(np, "qcom,tls-enabled");
 	npd->tstamp_enabled = of_property_read_bool(np, "qcom,tstamp-enabled");
 	npd->turbo_frequency = of_property_read_bool(np, "qcom,turbo-frequency");
 	npd->tun6rd_enabled = of_property_read_bool(np, "qcom,tun6rd-enabled");
 	npd->tunipip6_enabled = of_property_read_bool(np, "qcom,tunipip6-enabled");
 	npd->vlan_enabled = of_property_read_bool(np, "qcom,vlan-enabled");
-	npd->vxlan_enabled = of_property_read_bool(np, "qcom,vxlan-enabled");
 	npd->wlanredirect_enabled = of_property_read_bool(np, "qcom,wlanredirect-enabled");
 	npd->wifioffload_enabled = of_property_read_bool(np, "qcom,wlan-dataplane-offload-enabled");
-	npd->match_enabled = of_property_read_bool(np, "qcom,match-enabled");
-	npd->mirror_enabled = of_property_read_bool(np, "qcom,mirror-enabled");
-	npd->udp_st_enabled = of_property_read_bool(np, "qcom,udp-st-enabled");
-	npd->edma_lite_enabled = of_property_read_bool(np, "qcom,edma-lite-enabled");
-	npd->trustsec_enabled = of_property_read_bool(np, "qcom,trustsec-enabled");
+	npd->igs_enabled = of_property_read_bool(np, "qcom,igs-enabled");
 }
-
 /*
  * nss_hal_clean_up_irq()
  */
@@ -365,7 +351,6 @@ int nss_hal_probe(struct platform_device
 	}
 #endif
 
-#ifdef NSS_DRV_IPV4_ENABLE
 	if (npd->ipv4_enabled == NSS_FEATURE_ENABLED) {
 		nss_top->ipv4_handler_id = nss_dev->id;
 		nss_ipv4_register_handler();
@@ -374,15 +359,10 @@ int nss_hal_probe(struct platform_device
 		nss_top->edma_handler_id = nss_dev->id;
 		nss_edma_register_handler();
 #endif
-
-#ifdef NSS_DRV_ETH_RX_ENABLE
 		nss_eth_rx_register_handler(nss_ctx);
-#endif
-
 #ifdef NSS_DRV_LAG_ENABLE
 		nss_lag_register_handler();
 #endif
-
 #ifdef NSS_DRV_TRUSTSEC_ENABLE
 		nss_top->trustsec_tx_handler_id = nss_dev->id;
 		nss_trustsec_tx_register_handler();
@@ -393,25 +373,15 @@ int nss_hal_probe(struct platform_device
 		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_GENERIC_REDIR_N2H] = nss_dev->id;
 		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_GENERIC_REDIR_H2N] = nss_dev->id;
 	}
-#endif
-
-#ifdef NSS_DRV_TRUSTSEC_RX_ENABLE
-	if (npd->trustsec_enabled == NSS_FEATURE_ENABLED) {
-		nss_top->trustsec_rx_handler_id = nss_dev->id;
-		nss_trustsec_rx_register_handler();
-
-		nss_top->trustsec_tx_handler_id = nss_dev->id;
-		nss_trustsec_tx_register_handler();
-	}
-#endif
 
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,3))
 #ifdef NSS_DRV_CAPWAP_ENABLE
 	if (npd->capwap_enabled == NSS_FEATURE_ENABLED) {
 		nss_top->capwap_handler_id = nss_dev->id;
-		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_CAPWAP_OUTER] = nss_dev->id;
-		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_CAPWAP_HOST_INNER] = nss_dev->id;
+		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_CAPWAP] = nss_dev->id;
 	}
 #endif
+#endif
 
 #ifdef NSS_DRV_IPV4_REASM_ENABLE
 	if (npd->ipv4_reasm_enabled == NSS_FEATURE_ENABLED) {
@@ -441,7 +411,7 @@ int nss_hal_probe(struct platform_device
 	 */
 	if (npd->crypto_enabled == NSS_FEATURE_ENABLED) {
 		nss_top->crypto_handler_id = nss_dev->id;
-#if defined(NSS_HAL_IPQ807x_SUPPORT) || defined(NSS_HAL_IPQ60XX_SUPPORT) || defined(NSS_HAL_IPQ50XX_SUPPORT) || defined(NSS_HAL_IPQ95XX_SUPPORT)
+#if defined(NSS_HAL_IPQ807x_SUPPORT) || defined(NSS_HAL_IPQ60XX_SUPPORT) || defined(NSS_HAL_IPQ50XX_SUPPORT)
 		nss_crypto_cmn_register_handler();
 #else
 		nss_top->crypto_enabled = 1;
@@ -513,7 +483,7 @@ int nss_hal_probe(struct platform_device
 #ifdef NSS_DRV_DTLS_ENABLE
 	if (npd->dtls_enabled == NSS_FEATURE_ENABLED) {
 		nss_top->dtls_handler_id = nss_dev->id;
-#if defined(NSS_HAL_IPQ807x_SUPPORT) || defined(NSS_HAL_IPQ60XX_SUPPORT) || defined(NSS_HAL_IPQ50XX_SUPPORT) || defined(NSS_HAL_IPQ95XX_SUPPORT)
+#if defined(NSS_HAL_IPQ807x_SUPPORT) || defined(NSS_HAL_IPQ60XX_SUPPORT) || defined(NSS_HAL_IPQ50XX_SUPPORT)
 		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_DTLS_CMN_INNER] = nss_dev->id;
 		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_DTLS_CMN_OUTER] = nss_dev->id;
 		nss_dtls_cmn_register_handler();
@@ -588,33 +558,24 @@ int nss_hal_probe(struct platform_device
 	}
 #endif
 
-#ifdef NSS_DRV_WIFIOFFLOAD_ENABLE
+#ifdef NSS_DRV_WIFI_ENABLE
 	if (npd->wifioffload_enabled == NSS_FEATURE_ENABLED) {
 		nss_top->wifi_handler_id = nss_dev->id;
 		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_VAP] = nss_dev->id;
 		nss_wifi_register_handler();
 		nss_wifili_register_handler();
-#ifdef NSS_DRV_WIFI_EXT_VDEV_ENABLE
-		nss_wifi_ext_vdev_register_handler();
-#endif
+#if (NSS_FW_VERSION_CODE <= NSS_FW_VERSION(11,0))
+		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_WIFILI] = nss_dev->id;
+#else
 		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_WIFILI_INTERNAL] = nss_dev->id;
 		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_WIFILI_EXTERNAL0] = nss_dev->id;
 		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_WIFILI_EXTERNAL1] = nss_dev->id;
-		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_WIFI_EXT_VDEV_WDS] = nss_dev->id;
-		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_WIFI_EXT_VDEV_VLAN] = nss_dev->id;
-		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_WIFI_MESH_INNER] = nss_dev->id;
-		nss_top->dynamic_interface_table[NSS_DYNAMIC_INTERFACE_TYPE_WIFI_MESH_OUTER] = nss_dev->id;
-
 		/*
 		 * Register wifi mac database when offload enabled
 		 */
 		nss_top->wmdb_handler_id = nss_dev->id;
 		nss_wifi_mac_db_register_handler();
-
-		/*
-		 * Initialize wifili thread scheme database
-		 */
-		nss_wifili_thread_scheme_db_init(nss_dev->id);
+#endif
 	}
 #endif
 
@@ -701,6 +662,7 @@ int nss_hal_probe(struct platform_device
 	}
 #endif
 
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,1))
 #ifdef NSS_DRV_TLS_ENABLE
 #if defined(NSS_HAL_IPQ807x_SUPPORT) || defined(NSS_HAL_IPQ60XX_SUPPORT)
 	if (npd->tls_enabled == NSS_FEATURE_ENABLED) {
@@ -711,7 +673,6 @@ int nss_hal_probe(struct platform_device
 	}
 #endif
 #endif
-
 #ifdef NSS_DRV_MIRROR_ENABLE
 	if (npd->mirror_enabled == NSS_FEATURE_ENABLED) {
 		nss_top->mirror_handler_id = nss_dev->id;
@@ -719,14 +680,7 @@ int nss_hal_probe(struct platform_device
 		nss_mirror_register_handler();
 		nss_info("%d: NSS mirror is enabled", nss_dev->id);
 	}
-
 #endif
-
-#ifdef NSS_DRV_UDP_ST_ENABLE
-	if (npd->udp_st_enabled == NSS_FEATURE_ENABLED) {
-		nss_top->udp_st_handler_id = nss_dev->id;
-		nss_udp_st_register_handler(nss_ctx);
-	}
 #endif
 
 	if (nss_ctx->id == 0) {
@@ -740,19 +694,8 @@ int nss_hal_probe(struct platform_device
 		nss_freq_init_cpu_usage();
 #endif
 
-#ifdef NSS_DRV_LSO_RX_ENABLE
 		nss_lso_rx_register_handler(nss_ctx);
-#endif
-	}
-
-#ifdef NSS_DRV_EDMA_LITE_ENABLE
-	if (npd->edma_lite_enabled == NSS_FEATURE_ENABLED) {
-		nss_top->edma_lite_handler_id[nss_ctx->id] = nss_ctx->id;
-		nss_edma_lite_register_handler(nss_ctx);
-	} else {
-		nss_top->edma_lite_handler_id[nss_ctx->id] = -1;
 	}
-#endif
 
 	nss_top->frequency_handler_id = nss_dev->id;
 
@@ -798,7 +741,7 @@ int nss_hal_probe(struct platform_device
 		nss_hal_enable_interrupt(nss_ctx, nss_ctx->int_ctx[i].shift_factor, NSS_HAL_SUPPORTED_INTERRUPTS);
 	}
 
-	nss_info_always("%px: All resources initialized and nss core%d has been brought out of reset", nss_ctx, nss_dev->id);
+	nss_info("%px: All resources initialized and nss core%d has been brought out of reset", nss_ctx, nss_dev->id);
 	goto out;
 
 err_register_irq:
@@ -851,13 +794,7 @@ int nss_hal_remove(struct platform_devic
 	/*
 	 * nss-drv is exiting, unregister and restore host data plane
 	 */
-#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 	nss_top->data_plane_ops->data_plane_unregister();
-#endif
-
-#ifdef NSS_DATA_PLANE_LITE_SUPPORT
-	nss_data_plane_lite_unregister();
-#endif
 
 #if (NSS_FABRIC_SCALING_SUPPORT == 1)
 	fab_scaling_unregister(nss_core0_clk);
--- a/nss_if.c
+++ b/nss_if.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2016, 2018-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2016, 2018-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -160,10 +160,10 @@ nss_tx_status_t nss_if_tx_buf(struct nss
 }
 
 /*
- * nss_if_tx_msg_with_size()
- *	Transmit a message to the specific interface on this core with a specified size.
+ * nss_if_tx_msg()
+ *	Transmit a message to the specific interface on this core.
  */
-nss_tx_status_t nss_if_tx_msg_with_size(struct nss_ctx_instance *nss_ctx, struct nss_if_msg *nim, uint32_t size)
+nss_tx_status_t nss_if_tx_msg(struct nss_ctx_instance *nss_ctx, struct nss_if_msg *nim)
 {
 	struct nss_cmn_msg *ncm = &nim->cm;
 	struct net_device *dev;
@@ -198,19 +198,7 @@ nss_tx_status_t nss_if_tx_msg_with_size(
 		return NSS_TX_FAILURE_BAD_PARAM;
 	}
 
-	return nss_core_send_cmd(nss_ctx, nim, sizeof(*nim), size);
-}
-EXPORT_SYMBOL(nss_if_tx_msg_with_size);
-
-/*
- * nss_if_tx_msg()
- *	Transmit a message to the specific interface on this core.
- */
-nss_tx_status_t nss_if_tx_msg(struct nss_ctx_instance *nss_ctx, struct nss_if_msg *nim)
-{
-	NSS_VERIFY_CTX_MAGIC(nss_ctx);
-
-	return nss_if_tx_msg_with_size(nss_ctx, nim, NSS_NBUF_PAYLOAD_SIZE);
+	return nss_core_send_cmd(nss_ctx, nim, sizeof(*nim), NSS_NBUF_PAYLOAD_SIZE);
 }
 
 /*
@@ -277,90 +265,6 @@ nss_tx_status_t nss_if_set_nexthop(struc
 }
 EXPORT_SYMBOL(nss_if_set_nexthop);
 
-/*
- * nss_if_change_mtu()
- *	Change the MTU of the interface.
- */
-nss_tx_status_t nss_if_change_mtu(struct nss_ctx_instance *nss_ctx, nss_if_num_t if_num, uint16_t mtu)
-{
-	struct nss_if_msg nim;
-
-	NSS_VERIFY_CTX_MAGIC(nss_ctx);
-
-	nss_trace("%px: NSS If MTU will be changed to %u, of NSS if num: %u\n", nss_ctx, mtu, if_num);
-
-	nss_cmn_msg_init(&nim.cm, if_num, NSS_IF_MTU_CHANGE,
-				sizeof(struct nss_if_mtu_change), nss_if_callback, NULL);
-
-	nim.msg.mtu_change.min_buf_size = mtu;
-
-	return nss_if_msg_sync(nss_ctx, &nim);
-}
-EXPORT_SYMBOL(nss_if_change_mtu);
-
-/*
- * nss_if_change_mac_addr()
- *	Change the MAC address of the interface.
- */
-nss_tx_status_t nss_if_change_mac_addr(struct nss_ctx_instance *nss_ctx, nss_if_num_t if_num, uint8_t *mac_addr)
-{
-	struct nss_if_msg nim;
-
-	NSS_VERIFY_CTX_MAGIC(nss_ctx);
-
-	nss_trace("%px: NSS If MAC address will be changed to %s, of NSS if num: %u\n", nss_ctx, mac_addr, if_num);
-
-	nss_cmn_msg_init(&nim.cm, if_num, NSS_IF_MAC_ADDR_SET,
-				sizeof(struct nss_if_mac_address_set), nss_if_callback, NULL);
-
-	memcpy(nim.msg.mac_address_set.mac_addr, mac_addr, ETH_ALEN);
-
-	return nss_if_msg_sync(nss_ctx, &nim);
-}
-EXPORT_SYMBOL(nss_if_change_mac_addr);
-
-/*
- * nss_if_vsi_unassign()
- *	API to send VSI detach message to NSS FW.
- */
-nss_tx_status_t nss_if_vsi_unassign(struct nss_ctx_instance *nss_ctx, nss_if_num_t if_num, uint32_t vsi)
-{
-	struct nss_if_msg nim;
-
-	NSS_VERIFY_CTX_MAGIC(nss_ctx);
-
-	nss_trace("%px: VSI to be unassigned is %u\n", nss_ctx, vsi);
-
-	nss_cmn_msg_init(&nim.cm, if_num, NSS_IF_VSI_UNASSIGN,
-				sizeof(struct nss_if_vsi_unassign), nss_if_callback, NULL);
-
-	nim.msg.vsi_unassign.vsi = vsi;
-
-	return nss_if_msg_sync(nss_ctx, &nim);
-}
-EXPORT_SYMBOL(nss_if_vsi_unassign);
-
-/*
- * nss_if_vsi_assign()
- *	API to send VSI attach message to NSS FW.
- */
-nss_tx_status_t nss_if_vsi_assign(struct nss_ctx_instance *nss_ctx, nss_if_num_t if_num, uint32_t vsi)
-{
-	struct nss_if_msg nim;
-
-	NSS_VERIFY_CTX_MAGIC(nss_ctx);
-
-	nss_trace("%px: VSI to be assigned is %u\n", nss_ctx, vsi);
-
-	nss_cmn_msg_init(&nim.cm, if_num, NSS_IF_VSI_ASSIGN,
-				sizeof(struct nss_if_vsi_assign), nss_if_callback, NULL);
-
-	nim.msg.vsi_assign.vsi = vsi;
-
-	return nss_if_msg_sync(nss_ctx, &nim);
-}
-EXPORT_SYMBOL(nss_if_vsi_assign);
-
 EXPORT_SYMBOL(nss_if_tx_msg);
 EXPORT_SYMBOL(nss_if_register);
 EXPORT_SYMBOL(nss_if_unregister);
--- a/nss_igs.c
+++ b/nss_igs.c
@@ -14,14 +14,12 @@
  **************************************************************************
  */
 
-#include "nss_tx_rx_common.h"
-#include "nss_igs_stats.h"
-
-#if (LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 0))
 #ifdef CONFIG_NET_CLS_ACT
 #include <linux/tc_act/tc_nss_mirred.h>
 #endif
-#endif
+
+#include "nss_tx_rx_common.h"
+#include "nss_igs_stats.h"
 
 static struct module *nss_igs_module;
 
--- a/nss_init.c
+++ b/nss_init.c
@@ -1,12 +1,9 @@
 /*
  **************************************************************************
  * Copyright (c) 2013-2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
- *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
- *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -27,12 +24,7 @@
 #include "nss_pm.h"
 #endif
 #include "nss_tx_rx_common.h"
-#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 #include "nss_data_plane.h"
-#endif
-#ifdef NSS_DATA_PLANE_LITE_SUPPORT
-#include "nss_data_plane_lite.h"
-#endif
 #include "nss_capwap.h"
 #include "nss_strings.h"
 
@@ -641,24 +633,10 @@ static struct ctl_table_header *nss_dev_
  */
 static int __init nss_init(void)
 {
-#if defined(NSS_DRV_POINT_OFFLOAD)
-	struct device_node *pof = NULL;
-#endif
-
-
 #if (NSS_DT_SUPPORT == 1)
 	struct device_node *cmn = NULL;
 #endif
-
-#if defined(NSS_DRV_POINT_OFFLOAD)
-	pof = of_find_node_by_name(NULL, "reg_update");
-	if ((!pof) || (!of_property_read_bool(pof, "ubi_core_enable"))) {
-		nss_info_always("UBI is not enabled. Disable qca-nss-drv\n");
-		return 0;
-	}
-#endif
-
-nss_info("Init NSS driver");
+	nss_info("Init NSS driver");
 
 #if (NSS_DT_SUPPORT == 1)
 	/*
@@ -677,18 +655,14 @@ nss_info("Init NSS driver");
 #if defined(NSS_HAL_IPQ806X_SUPPORT)
 	if (of_machine_is_compatible("qcom,ipq8064") || of_machine_is_compatible("qcom,ipq8062")) {
 		nss_top_main.hal_ops = &nss_hal_ipq806x_ops;
-#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 		nss_top_main.data_plane_ops = &nss_data_plane_gmac_ops;
-#endif
 		nss_top_main.num_nss = 2;
 	}
 #endif
 #if defined(NSS_HAL_IPQ807x_SUPPORT)
 	if (of_machine_is_compatible("qcom,ipq807x") || of_machine_is_compatible("qcom,ipq8074")) {
 		nss_top_main.hal_ops = &nss_hal_ipq807x_ops;
-#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 		nss_top_main.data_plane_ops = &nss_data_plane_ops;
-#endif
 #if defined(NSS_MEM_PROFILE_LOW)
 		nss_top_main.num_nss = 1;
 #else
@@ -699,35 +673,21 @@ nss_info("Init NSS driver");
 #if defined(NSS_HAL_IPQ60XX_SUPPORT)
 	if (of_machine_is_compatible("qcom,ipq6018")) {
 		nss_top_main.hal_ops = &nss_hal_ipq60xx_ops;
-#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 		nss_top_main.data_plane_ops = &nss_data_plane_ops;
-#endif
 		nss_top_main.num_nss = 1;
 	}
 #endif
 #if defined(NSS_HAL_IPQ50XX_SUPPORT)
 	if (of_machine_is_compatible("qcom,ipq5018")) {
 		nss_top_main.hal_ops = &nss_hal_ipq50xx_ops;
-#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 		nss_top_main.data_plane_ops = &nss_data_plane_ops;
-#endif
 		nss_top_main.num_nss = 1;
 	}
 #endif
-
-#if defined(NSS_HAL_IPQ95XX_SUPPORT)
-	if (of_machine_is_compatible("qcom,ipq9574-emulation") || of_machine_is_compatible("qcom,ipq9574")) {
-		nss_top_main.hal_ops = &nss_hal_ipq95xx_ops;
-		nss_top_main.num_nss = 1;
-	}
-#endif
-
 #if defined(NSS_HAL_FSM9010_SUPPORT)
 	if (of_machine_is_compatible("qcom,fsm9010")) {
 		nss_top_main.hal_ops = &nss_hal_fsm9010_ops;
-#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 		nss_top_main.data_plane_ops = &nss_data_plane_gmac_ops;
-#endif
 		nss_top_main.num_nss = 1;
 	}
 #endif
@@ -740,9 +700,7 @@ nss_info("Init NSS driver");
 	 * For banana, only ipq806x is supported
 	 */
 	nss_top_main.hal_ops = &nss_hal_ipq806x_ops;
-#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 	nss_top_main.data_plane_ops = &nss_data_plane_gmac_ops;
-#endif
 	nss_top_main.num_nss = 2;
 
 #endif /* NSS_DT_SUPPORT */
@@ -751,20 +709,11 @@ nss_info("Init NSS driver");
 	/*
 	 * Initialize data_plane workqueue
 	 */
-
-#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 	if (nss_data_plane_init_delay_work()) {
 		nss_warning("Error initializing nss_data_plane_workqueue\n");
 		return -EFAULT;
 	}
-#endif
 
-#ifdef NSS_DATA_PLANE_LITE_SUPPORT
-	if (nss_data_plane_lite_init_delay_work()){
-		nss_warning("Error initializing nss_data_plane_lite_workqueue\n");
-		return -EFAULT;
-	}
-#endif
 	/*
 	 * Enable spin locks
 	 */
@@ -790,9 +739,7 @@ nss_info("Init NSS driver");
 	/*
 	 * Registering sysctl for ipv4/6 specific config.
 	 */
-#ifdef NSS_DRV_IPV4_ENABLE
 	nss_ipv4_register_sysctl();
-#endif
 #ifdef NSS_DRV_IPV6_ENABLE
 	nss_ipv6_register_sysctl();
 #endif
@@ -828,13 +775,12 @@ nss_info("Init NSS driver");
 	 */
 	nss_project_register_sysctl();
 
+#ifdef NSS_DRV_PPPOE_ENABLE
 	/*
 	 * Registering sysctl for pppoe specific config.
 	 */
-#ifdef NSS_DRV_PPPOE_ENABLE
 	nss_pppoe_register_sysctl();
 #endif
-
 	/*
 	 * Setup Runtime Sample values
 	 */
@@ -928,13 +874,6 @@ nss_info("Init NSS driver");
 #endif
 
 	/*
-	 * Init Wi-Fi mesh
-	 */
-#ifdef NSS_DRV_WIFI_MESH_ENABLE
-	nss_wifi_mesh_init();
-#endif
-
-	/*
 	 * Register platform_driver
 	 */
 	return platform_driver_register(&nss_driver);
@@ -968,20 +907,18 @@ static void __exit nss_cleanup(void)
 	nss_c2c_tx_unregister_sysctl();
 #endif
 
+#ifdef NSS_DRV_PPPOE_ENABLE
 	/*
 	 * Unregister pppoe specific sysctl
 	 */
-#ifdef NSS_DRV_PPPOE_ENABLE
 	nss_pppoe_unregister_sysctl();
 #endif
 
 	/*
 	 * Unregister ipv4/6 specific sysctl and free allocated to connection tables
 	 */
-#ifdef NSS_DRV_IPV4_ENABLE
 	nss_ipv4_unregister_sysctl();
 	nss_ipv4_free_conn_tables();
-#endif
 
 #ifdef NSS_DRV_IPV6_ENABLE
 	nss_ipv6_unregister_sysctl();
@@ -989,14 +926,7 @@ static void __exit nss_cleanup(void)
 #endif
 
 	nss_project_unregister_sysctl();
-
-#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 	nss_data_plane_destroy_delay_work();
-#endif
-
-#ifdef NSS_DATA_PLANE_LITE_SUPPORT
-	nss_data_plane_lite_destroy_delay_work();
-#endif
 
 	/*
 	 * cleanup ppe on supported platform
--- a/nss_ipsec_cmn.c
+++ b/nss_ipsec_cmn.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -19,11 +19,11 @@
 #include "nss_ipsec_cmn.h"
 #include "nss_ppe.h"
 #include "nss_ipsec_cmn_log.h"
-#include "nss_ipsec_cmn_stats.h"
-#include "nss_ipsec_cmn_strings.h"
 
 #define NSS_IPSEC_CMN_TX_TIMEOUT 3000 /* 3 Seconds */
 #define NSS_IPSEC_CMN_INTERFACE_MAX_LONG BITS_TO_LONGS(NSS_MAX_NET_INTERFACES)
+#define NSS_IPSEC_CMN_STATS_MAX_LINES (NSS_STATS_NODE_MAX + 32)
+#define NSS_IPSEC_CMN_STATS_SIZE_PER_IF (NSS_STATS_MAX_STR_LENGTH * NSS_IPSEC_CMN_STATS_MAX_LINES)
 
 /*
  * Private data structure for handling synchronous messaging.
@@ -36,6 +36,104 @@ static struct nss_ipsec_cmn_pvt {
 } ipsec_cmn_pvt;
 
 /*
+ * nss_ipsec_cmn_stats_sync()
+ *	Update ipsec_cmn node statistics.
+ */
+static void nss_ipsec_cmn_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_cmn_msg *ncm)
+{
+	struct nss_ipsec_cmn_msg *nicm = (struct nss_ipsec_cmn_msg *)ncm;
+	struct nss_top_instance *nss_top = nss_ctx->nss_top;
+	struct nss_cmn_node_stats *msg_stats = &nicm->msg.ctx_sync.stats.cmn_stats;
+	uint64_t *if_stats;
+	int8_t i;
+
+	spin_lock_bh(&nss_top->stats_lock);
+
+	/*
+	 * Update common node stats,
+	 * Note: DTLS only supports a single queue for RX
+	 */
+	if_stats = nss_top->stats_node[ncm->interface];
+	if_stats[NSS_STATS_NODE_RX_PKTS] += msg_stats->rx_packets;
+	if_stats[NSS_STATS_NODE_RX_BYTES] += msg_stats->rx_bytes;
+
+	for (i = 0; i < NSS_MAX_NUM_PRI; i++) {
+		if_stats[NSS_STATS_NODE_RX_QUEUE_0_DROPPED + i] += msg_stats->rx_dropped[i];
+	}
+
+	if_stats[NSS_STATS_NODE_TX_PKTS] += msg_stats->tx_packets;
+	if_stats[NSS_STATS_NODE_TX_BYTES] += msg_stats->tx_bytes;
+
+	spin_unlock_bh(&nss_top->stats_lock);
+}
+
+/*
+ * nss_ipsec_cmn_stats_read()
+ *	Read ipsec_cmn node statistics.
+ */
+static ssize_t nss_ipsec_cmn_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
+{
+	struct nss_ctx_instance *nss_ctx = nss_ipsec_cmn_get_context();
+	enum nss_dynamic_interface_type type;
+	ssize_t bytes_read = 0;
+	size_t len = 0, size;
+	uint32_t if_num;
+	char *buf;
+
+	size = NSS_IPSEC_CMN_STATS_SIZE_PER_IF * bitmap_weight(ipsec_cmn_pvt.if_map, NSS_MAX_NET_INTERFACES);
+
+	buf = kzalloc(size, GFP_KERNEL);
+	if (!buf) {
+		nss_warning("Could not allocate memory for local statistics buffer\n");
+		return 0;
+	}
+
+	len += nss_stats_banner(buf, len, size, "ipsec_cmn", NSS_STATS_SINGLE_CORE);
+
+	/*
+	 * Common node stats for each IPSEC dynamic interface.
+	 */
+	for_each_set_bit(if_num, ipsec_cmn_pvt.if_map, NSS_MAX_NET_INTERFACES) {
+
+		type = nss_dynamic_interface_get_type(nss_ctx, if_num);
+		switch (type) {
+		case NSS_DYNAMIC_INTERFACE_TYPE_IPSEC_CMN_INNER:
+			len += scnprintf(buf + len, size - len, "\nInner if_num:%03u", if_num);
+			break;
+
+		case NSS_DYNAMIC_INTERFACE_TYPE_IPSEC_CMN_MDATA_INNER:
+			len += scnprintf(buf + len, size - len, "\nMetadata inner if_num:%03u", if_num);
+			break;
+
+		case NSS_DYNAMIC_INTERFACE_TYPE_IPSEC_CMN_OUTER:
+			len += scnprintf(buf + len, size - len, "\nOuter if_num:%03u", if_num);
+			break;
+
+		case NSS_DYNAMIC_INTERFACE_TYPE_IPSEC_CMN_MDATA_OUTER:
+			len += scnprintf(buf + len, size - len, "\nMetadata outer if_num:%03u", if_num);
+			break;
+
+		default:
+			len += scnprintf(buf + len, size - len, "\nUnknown(%d) if_num:%03u", type, if_num);
+			break;
+		}
+
+		len += scnprintf(buf + len, size - len, "\n-------------------\n");
+		len += nss_stats_fill_common_stats(if_num, NSS_STATS_SINGLE_INSTANCE, buf, len, size - len, "ipsec_cmn");
+	}
+
+	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, buf, len);
+	kfree(buf);
+
+	return bytes_read;
+}
+
+/*
+ * nss_ipsec_cmn_stats_ops
+ */
+NSS_STATS_DECLARE_FILE_OPERATIONS(ipsec_cmn)
+
+/*
  * nss_ipsec_cmn_verify_ifnum()
  *	Verify if the interface number is a IPsec interface.
  */
@@ -91,10 +189,8 @@ static void nss_ipsec_cmn_msg_handler(st
 		return;
 	}
 
-	if (ncm->type == NSS_IPSEC_CMN_MSG_TYPE_CTX_SYNC) {
+	if (ncm->type == NSS_IPSEC_CMN_MSG_TYPE_CTX_SYNC)
 		nss_ipsec_cmn_stats_sync(nss_ctx, ncm);
-		nss_ipsec_cmn_stats_notify(nss_ctx, ncm->interface);
-	}
 
 	/*
 	 * Update the callback and app_data for NOTIFY messages, ipsec_cmn sends all notify messages
@@ -102,7 +198,7 @@ static void nss_ipsec_cmn_msg_handler(st
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
 		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
-		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[ncm->interface].app_data;
+		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[nss_ctx->id][ncm->interface].app_data;
 	}
 
 	/*
@@ -151,15 +247,6 @@ static void nss_ipsec_cmn_sync_resp(void
 }
 
 /*
- * nss_ipsec_cmn_ifmap_get()
- *	Return IPsec common active interfaces map.
- */
-unsigned long *nss_ipsec_cmn_ifmap_get(void)
-{
-	return ipsec_cmn_pvt.if_map;
-}
-
-/*
  * nss_ipsec_cmn_get_context()
  *	Retrieve context for IPSEC redir.
  */
@@ -335,10 +422,8 @@ struct nss_ctx_instance *nss_ipsec_cmn_r
 		return NULL;
 	}
 
-#ifdef NSS_DRV_PPE_ENABLE
 	if (features & NSS_IPSEC_CMN_FEATURE_INLINE_ACCEL)
 		nss_ppe_tx_ipsec_add_intf_msg(nss_ipsec_cmn_get_ifnum_with_coreid(if_num));
-#endif
 
 	/*
 	 * Registering handler for sending tunnel interface msgs to NSS.
@@ -520,6 +605,5 @@ void nss_ipsec_cmn_register_handler(void
 {
 	sema_init(&ipsec_cmn_pvt.sem, 1);
 	init_completion(&ipsec_cmn_pvt.complete);
-	nss_ipsec_cmn_stats_dentry_create();
-	nss_ipsec_cmn_strings_dentry_create();
+	nss_stats_create_dentry("ipsec_cmn", &nss_ipsec_cmn_stats_ops);
 }
--- a/nss_ipsec_cmn_stats.c
+++ /dev/null
@@ -1,219 +0,0 @@
-/*
- ***************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ***************************************************************************
- */
-
-#include "nss_core.h"
-#include "nss_ipsec_cmn.h"
-#include "nss_ipsec_cmn_stats.h"
-#include "nss_ipsec_cmn_strings.h"
-
-/*
- * Declare atomic notifier data structure for statistics.
- */
-ATOMIC_NOTIFIER_HEAD(nss_ipsec_cmn_stats_notifier);
-
-/*
- * Spinlock to protect IPsec common statistics update/read
- */
-DEFINE_SPINLOCK(nss_ipsec_cmn_stats_lock);
-
-unsigned long *nss_ipsec_cmn_ifmap_get(void);
-const char *nss_ipsec_cmn_stats_iface_type(enum nss_dynamic_interface_type type);
-
-/*
- * nss_ipsec_cmn_stats
- *	ipsec common statistics
- */
-uint64_t nss_ipsec_cmn_stats[NSS_MAX_NET_INTERFACES][NSS_IPSEC_CMN_STATS_MAX];
-
-/*
- * nss_ipsec_cmn_stats_read()
- *	Read ipsec_cmn node statistics.
- */
-static ssize_t nss_ipsec_cmn_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	/*
-	 * Max output lines = #stats +
-	 * few blank lines for banner printing + Number of Extra outputlines
-	 * for future reference to add new stats
-	 */
-	uint32_t max_output_lines = NSS_IPSEC_CMN_STATS_MAX + NSS_STATS_EXTRA_OUTPUT_LINES;
-	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
-	struct nss_ctx_instance *nss_ctx = nss_ipsec_cmn_get_context();
-	enum nss_dynamic_interface_type type;
-	unsigned long *ifmap;
-	uint64_t *stats_shadow;
-	ssize_t bytes_read = 0;
-	size_t size_wr = 0;
-	uint32_t if_num;
-	int32_t i;
-	int count;
-	char *lbuf;
-
-	ifmap = nss_ipsec_cmn_ifmap_get();
-	count = bitmap_weight(ifmap, NSS_MAX_NET_INTERFACES);
-	if (count) {
-		size_al = size_al * count;
-	}
-
-	lbuf = vzalloc(size_al);
-	if (unlikely(!lbuf)) {
-		nss_warning("Could not allocate memory for local statistics buffer");
-		return -ENOMEM;
-	}
-
-	stats_shadow = vzalloc(NSS_IPSEC_CMN_STATS_MAX * 8);
-	if (unlikely(!stats_shadow)) {
-		nss_warning("Could not allocate memory for local shadow buffer");
-		vfree(lbuf);
-		return -ENOMEM;
-	}
-
-	/*
-	 * Common node stats for each IPSEC dynamic interface.
-	 */
-	size_wr += nss_stats_banner(lbuf, size_wr, size_al, "ipsec_cmn stats", NSS_STATS_SINGLE_CORE);
-	for_each_set_bit(if_num, ifmap, NSS_MAX_NET_INTERFACES) {
-
-		type = nss_dynamic_interface_get_type(nss_ctx, if_num);
-		if ((type < NSS_DYNAMIC_INTERFACE_TYPE_IPSEC_CMN_INNER) ||
-			(type > NSS_DYNAMIC_INTERFACE_TYPE_IPSEC_CMN_REDIRECT)) {
-			continue;
-		}
-
-		spin_lock_bh(&nss_ipsec_cmn_stats_lock);
-		for (i = 0; i < NSS_IPSEC_CMN_STATS_MAX; i++) {
-			stats_shadow[i] = nss_ipsec_cmn_stats[if_num][i];
-		}
-		spin_unlock_bh(&nss_ipsec_cmn_stats_lock);
-
-		size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\n%s if_num:%03u\n",
-					nss_ipsec_cmn_stats_iface_type(type), if_num);
-		size_wr += nss_stats_print("ipsec_cmn", NULL, NSS_STATS_SINGLE_INSTANCE, nss_ipsec_cmn_strings_stats,
-							stats_shadow, NSS_IPSEC_CMN_STATS_MAX, lbuf, size_wr, size_al);
-	}
-
-	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
-	vfree(lbuf);
-	vfree(stats_shadow);
-
-	return bytes_read;
-}
-
-/*
- * nss_ipsec_cmn_stats_ops.
- */
-NSS_STATS_DECLARE_FILE_OPERATIONS(ipsec_cmn);
-
-/*
- * nss_ipsec_cmn_stats_sync()
- *	Update ipsec_cmn node statistics.
- */
-void nss_ipsec_cmn_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_cmn_msg *ncm)
-{
-	struct nss_ipsec_cmn_msg *nicm = (struct nss_ipsec_cmn_msg *)ncm;
-	struct nss_ipsec_cmn_ctx_stats *ndccs = &nicm->msg.ctx_sync.stats;
-	uint64_t *ctx_stats;
-	uint32_t *msg_stats;
-	uint16_t i = 0;
-
-	spin_lock_bh(&nss_ipsec_cmn_stats_lock);
-
-	msg_stats = (uint32_t *)ndccs;
-	ctx_stats = nss_ipsec_cmn_stats[ncm->interface];
-
-	for (i = 0; i < NSS_IPSEC_CMN_STATS_MAX; i++, ctx_stats++, msg_stats++) {
-		*ctx_stats += *msg_stats;
-	}
-
-	spin_unlock_bh(&nss_ipsec_cmn_stats_lock);
-}
-
-/*
- * nss_ipsec_cmn_stats_iface_type()
- *	Return a string for each interface type.
- */
-const char *nss_ipsec_cmn_stats_iface_type(enum nss_dynamic_interface_type type)
-{
-	switch (type) {
-	case NSS_DYNAMIC_INTERFACE_TYPE_IPSEC_CMN_INNER:
-		return "ipsec_cmn_inner";
-
-	case NSS_DYNAMIC_INTERFACE_TYPE_IPSEC_CMN_MDATA_INNER:
-		return "ipsec_cmn_mdata_inner";
-
-	case NSS_DYNAMIC_INTERFACE_TYPE_IPSEC_CMN_OUTER:
-		return "ipsec_cmn_outer";
-
-	case NSS_DYNAMIC_INTERFACE_TYPE_IPSEC_CMN_MDATA_OUTER:
-		return "ipsec_cmn_mdata_outer";
-
-	case NSS_DYNAMIC_INTERFACE_TYPE_IPSEC_CMN_REDIRECT:
-		return "ipsec_cmn_redirect";
-
-	default:
-		return "invalid_interface";
-	}
-}
-
-/*
- * nss_ipsec_cmn_stats_notify()
- *	Sends notifications to all the registered modules.
- *
- * Leverage NSS-FW statistics timing to update Netlink.
- */
-void nss_ipsec_cmn_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num)
-{
-	struct nss_ipsec_cmn_stats_notification ipsec_cmn_stats;
-
-	spin_lock_bh(&nss_ipsec_cmn_stats_lock);
-	ipsec_cmn_stats.core_id = nss_ctx->id;
-	ipsec_cmn_stats.if_num = if_num;
-	memcpy(ipsec_cmn_stats.stats_ctx, nss_ipsec_cmn_stats[if_num], sizeof(ipsec_cmn_stats.stats_ctx));
-	spin_unlock_bh(&nss_ipsec_cmn_stats_lock);
-
-	atomic_notifier_call_chain(&nss_ipsec_cmn_stats_notifier, NSS_STATS_EVENT_NOTIFY, &ipsec_cmn_stats);
-}
-
-/*
- * nss_ipsec_cmn_stats_unregister_notifier()
- *	Deregisters statistics notifier.
- */
-int nss_ipsec_cmn_stats_unregister_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_unregister(&nss_ipsec_cmn_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_ipsec_cmn_stats_unregister_notifier);
-
-/*
- * nss_ipsec_cmn_stats_register_notifier()
- *	Registers statistics notifier.
- */
-int nss_ipsec_cmn_stats_register_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_register(&nss_ipsec_cmn_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_ipsec_cmn_stats_register_notifier);
-
-/*
- * nss_ipsec_cmn_stats_dentry_create()
- *	Create ipsec common statistics debug entry.
- */
-void nss_ipsec_cmn_stats_dentry_create(void)
-{
-	nss_stats_create_dentry("ipsec_cmn", &nss_ipsec_cmn_stats_ops);
-}
--- a/nss_ipsec_cmn_stats.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- ***************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ***************************************************************************
- */
-
-#ifndef __NSS_IPSEC_CMN_STATS_H
-#define __NSS_IPSEC_CMN_STATS_H
-
-#include <nss_cmn.h>
-
-extern void nss_ipsec_cmn_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num);
-extern void nss_ipsec_cmn_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_cmn_msg *ncm);
-extern void nss_ipsec_cmn_stats_dentry_create(void);
-
-#endif /* __NSS_IPSEC_CMN_STATS_H */
--- a/nss_ipsec_cmn_strings.c
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- ***************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ***************************************************************************
- */
-
-#include "nss_stats.h"
-#include "nss_core.h"
-#include "nss_strings.h"
-#include "nss_ipsec_cmn_strings.h"
-
-/*
- * nss_ipsec_cmn_strings_stats
- *	ipsec common statistics strings.
- */
-struct nss_stats_info nss_ipsec_cmn_strings_stats[NSS_IPSEC_CMN_STATS_MAX] = {
-	{"rx_pkts",			NSS_STATS_TYPE_COMMON},
-	{"rx_byts",			NSS_STATS_TYPE_COMMON},
-	{"tx_pkts",			NSS_STATS_TYPE_COMMON},
-	{"tx_byts",			NSS_STATS_TYPE_COMMON},
-	{"rx_queue[0]_drops",		NSS_STATS_TYPE_DROP},
-	{"rx_queue[1]_drops",		NSS_STATS_TYPE_DROP},
-	{"rx_queue[2]_drops",		NSS_STATS_TYPE_DROP},
-	{"rx_queue[3]_drops",		NSS_STATS_TYPE_DROP},
-	{"fail_headroom",		NSS_STATS_TYPE_DROP},
-	{"fail_tailroom",		NSS_STATS_TYPE_DROP},
-	{"fail_replay",			NSS_STATS_TYPE_DROP},
-	{"fail_replay_dup",		NSS_STATS_TYPE_DROP},
-	{"fail_replay_win",		NSS_STATS_TYPE_DROP},
-	{"fail_pbuf_crypto",		NSS_STATS_TYPE_DROP},
-	{"fail_queue",			NSS_STATS_TYPE_DROP},
-	{"fail_queue_crypto",		NSS_STATS_TYPE_DROP},
-	{"fail_queue_nexthop",		NSS_STATS_TYPE_DROP},
-	{"fail_pbuf_alloc",		NSS_STATS_TYPE_DROP},
-	{"fail_pbuf_linear",		NSS_STATS_TYPE_DROP},
-	{"fail_pbuf_stats",		NSS_STATS_TYPE_DROP},
-	{"fail_pbuf_align",		NSS_STATS_TYPE_DROP},
-	{"fail_cipher",			NSS_STATS_TYPE_EXCEPTION},
-	{"fail_auth",			NSS_STATS_TYPE_EXCEPTION},
-	{"fail_seq_ovf",		NSS_STATS_TYPE_DROP},
-	{"fail_blk_len",		NSS_STATS_TYPE_DROP},
-	{"fail_hash_len",		NSS_STATS_TYPE_DROP},
-	{"fail_transform",		NSS_STATS_TYPE_DROP},
-	{"fail_crypto",			NSS_STATS_TYPE_DROP},
-	{"fail_cle",			NSS_STATS_TYPE_DROP},
-	{"is_stopped",			NSS_STATS_TYPE_SPECIAL}
-};
-
-/*
- * nss_ipsec_cmn_strings_read()
- *	Read ipsec common statistics names
- */
-static ssize_t nss_ipsec_cmn_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_ipsec_cmn_strings_stats, NSS_IPSEC_CMN_STATS_MAX);
-}
-
-/*
- * nss_ipsec_cmn_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(ipsec_cmn);
-
-/*
- * nss_ipsec_cmn_strings_dentry_create()
- *	Create ipsec common statistics strings debug entry.
- */
-void nss_ipsec_cmn_strings_dentry_create(void)
-{
-	nss_strings_create_dentry("ipsec_cmn", &nss_ipsec_cmn_strings_ops);
-}
--- a/nss_ipsec_cmn_strings.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- ***************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ***************************************************************************
- */
-
-#ifndef __NSS_IPSEC_CMN_STRINGS_H
-#define __NSS_IPSEC_CMN_STRINGS_H
-
-#include "nss_ipsec_cmn_stats.h"
-
-extern struct nss_stats_info nss_ipsec_cmn_strings_stats[NSS_IPSEC_CMN_STATS_MAX];
-extern void nss_ipsec_cmn_strings_dentry_create(void);
-
-#endif /* __NSS_IPSEC_CMN_STRINGS_H */
--- a/nss_ipv4.c
+++ b/nss_ipv4.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2013-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2013-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -70,20 +70,6 @@ static inline void nss_ipv4_dscp_map_usa
 }
 
 /*
- * nss_ipv4_get_total_conn_count()
- *	 Returns the sum of IPv4 and IPv6 connections.
- */
-static uint32_t nss_ipv4_get_total_conn_count(int ipv4_num_conn)
-{
-
-#ifdef NSS_DRV_IPV6_ENABLE
-	return ipv4_num_conn + nss_ipv6_conn_cfg;
-#else
-	return ipv4_num_conn;
-#endif
-}
-
-/*
  * nss_ipv4_rx_msg_handler()
  *	Handle NSS -> HLOS messages for IPv4 bridge/route
  */
@@ -438,7 +424,7 @@ static int nss_ipv4_conn_cfg_process(str
 
 	nss_info("%px: IPv4 supported connections: %d\n", nss_ctx, conn);
 
-	nss_ipv4_ct_info.ce_mem = __get_free_pages(GFP_ATOMIC | __GFP_NOWARN | __GFP_ZERO,
+	nss_ipv4_ct_info.ce_mem = __get_free_pages(GFP_KERNEL | __GFP_NOWARN | __GFP_ZERO,
 					get_order(nss_ipv4_ct_info.ce_table_size));
 	if (!nss_ipv4_ct_info.ce_mem) {
 		nss_warning("%px: Memory allocation failed for IPv4 Connections: %d\n",
@@ -447,7 +433,7 @@ static int nss_ipv4_conn_cfg_process(str
 		goto fail;
 	}
 
-	nss_ipv4_ct_info.cme_mem = __get_free_pages(GFP_ATOMIC | __GFP_NOWARN | __GFP_ZERO,
+	nss_ipv4_ct_info.cme_mem = __get_free_pages(GFP_KERNEL | __GFP_NOWARN | __GFP_ZERO,
 					get_order(nss_ipv4_ct_info.cme_table_size));
 	if (!nss_ipv4_ct_info.ce_mem) {
 		nss_warning("%px: Memory allocation failed for IPv4 Connections: %d\n",
@@ -546,8 +532,7 @@ int nss_ipv4_update_conn_count(int ipv4_
 	 * Min. value should be at least 256 connections. This is the
 	 * minimum connections we will support for each of them.
 	 */
-	sum_of_conn = nss_ipv4_get_total_conn_count(ipv4_num_conn);
-
+	sum_of_conn = ipv4_num_conn + nss_ipv6_conn_cfg;
 	if ((ipv4_num_conn & NSS_NUM_CONN_QUANTA_MASK) ||
 		(sum_of_conn > NSS_MAX_TOTAL_NUM_CONN_IPV4_IPV6) ||
 		(ipv4_num_conn < NSS_MIN_NUM_CONN)) {
--- a/nss_ipv4_log.c
+++ b/nss_ipv4_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016, 2018, 2020-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016, 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -88,9 +88,7 @@ static void nss_ipv4_log_rule_create_msg
 		"flow_qos_tag: %x (%u)\n"
 		"return_qos_tag: %x (%u)\n"
 		"flow_dscp: %x\n"
-		"return_dscp: %x\n"
-		"flow_mirror_ifnum: %u\n"
-		"return_mirror_ifnum: %u\n",
+		"return_dscp: %x\n",
 		nim,
 		nircm->tuple.protocol,
 		nircm->conn_rule.flow_mtu,
@@ -116,9 +114,7 @@ static void nss_ipv4_log_rule_create_msg
 		nircm->qos_rule.flow_qos_tag, nircm->qos_rule.flow_qos_tag,
 		nircm->qos_rule.return_qos_tag, nircm->qos_rule.return_qos_tag,
 		nircm->dscp_rule.flow_dscp,
-		nircm->dscp_rule.return_dscp,
-		nircm->mirror_rule.flow_ifnum,
-		nircm->mirror_rule.return_ifnum);
+		nircm->dscp_rule.return_dscp);
 }
 
 /*
--- a/nss_ipv4_stats.c
+++ b/nss_ipv4_stats.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016-2017, 2019-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2017, 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -177,9 +177,6 @@ void nss_ipv4_stats_node_sync(struct nss
 	nss_ipv4_stats[NSS_IPV4_STATS_MC_CONNECTION_DESTROY_REQUESTS] += nins->ipv4_mc_connection_destroy_requests;
 	nss_ipv4_stats[NSS_IPV4_STATS_MC_CONNECTION_DESTROY_MISSES] += nins->ipv4_mc_connection_destroy_misses;
 	nss_ipv4_stats[NSS_IPV4_STATS_MC_CONNECTION_FLUSHES] += nins->ipv4_mc_connection_flushes;
-	nss_ipv4_stats[NSS_IPV4_STATS_CONNECTION_CREATE_INVALID_MIRROR_IFNUM] += nins->ipv4_connection_create_invalid_mirror_ifnum;
-	nss_ipv4_stats[NSS_IPV4_STATS_CONNECTION_CREATE_INVALID_MIRROR_IFTYPE] += nins->ipv4_connection_create_invalid_mirror_iftype;
-	nss_ipv4_stats[NSS_IPV4_STATS_MIRROR_FAILURES] += nins->ipv4_mirror_failures;
 
 	for (i = 0; i < NSS_IPV4_EXCEPTION_EVENT_MAX; i++) {
 		nss_ipv4_exception_stats[i] += nins->exception_events[i];
--- a/nss_ipv4_strings.c
+++ b/nss_ipv4_strings.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
@@ -106,10 +106,10 @@ struct nss_stats_info nss_ipv4_strings_e
 	{"mc_pbuf_alloc_failure"		, NSS_STATS_TYPE_EXCEPTION},
 	{"pppoe_bridge_no_icme"			, NSS_STATS_TYPE_EXCEPTION},
 	{"pppoe_no_session"			, NSS_STATS_TYPE_DROP},
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,0))
 	{"icmp_ipv4_gre_hdr_incomplete"		, NSS_STATS_TYPE_EXCEPTION},
 	{"icmp_ipv4_esp_hdr_incomplete"		, NSS_STATS_TYPE_EXCEPTION},
-	{"emesh_prio_mismatch"			, NSS_STATS_TYPE_EXCEPTION},
-	{"mc_ucast_dmac_failure"		, NSS_STATS_TYPE_EXCEPTION},
+#endif
 };
 
 /*
@@ -137,10 +137,7 @@ struct nss_stats_info nss_ipv4_strings_s
 	{"mc_create_invalid_interface"	, NSS_STATS_TYPE_SPECIAL},
 	{"mc_destroy_requests"		, NSS_STATS_TYPE_SPECIAL},
 	{"mc_destroy_misses"		, NSS_STATS_TYPE_SPECIAL},
-	{"mc_flushes"			, NSS_STATS_TYPE_SPECIAL},
-	{"mirror_invalid_ifnum_conn_create_req"		, NSS_STATS_TYPE_SPECIAL},
-	{"mirror_invalid_iftype_conn_create_req"	, NSS_STATS_TYPE_SPECIAL},
-	{"mirror_failures"		, NSS_STATS_TYPE_SPECIAL},
+	{"mc_flushes"			, NSS_STATS_TYPE_SPECIAL}
 };
 
 /*
--- a/nss_ipv6.c
+++ b/nss_ipv6.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -428,7 +428,7 @@ static int nss_ipv6_conn_cfg_process(str
 
 	nss_info("%px: IPv6 supported connections: %d\n", nss_ctx, conn);
 
-	nss_ipv6_ct_info.ce_mem = __get_free_pages(GFP_ATOMIC | __GFP_NOWARN | __GFP_ZERO,
+	nss_ipv6_ct_info.ce_mem = __get_free_pages(GFP_KERNEL | __GFP_NOWARN | __GFP_ZERO,
 					get_order(nss_ipv6_ct_info.ce_table_size));
 	if (!nss_ipv6_ct_info.ce_mem) {
 		nss_warning("%px: Memory allocation failed for IPv6 Connections: %d\n",
@@ -440,7 +440,7 @@ static int nss_ipv6_conn_cfg_process(str
 							nss_ctx,
 							conn);
 
-	nss_ipv6_ct_info.cme_mem = __get_free_pages(GFP_ATOMIC | __GFP_NOWARN | __GFP_ZERO,
+	nss_ipv6_ct_info.cme_mem = __get_free_pages(GFP_KERNEL | __GFP_NOWARN | __GFP_ZERO,
 					get_order(nss_ipv6_ct_info.cme_table_size));
 	if (!nss_ipv6_ct_info.cme_mem) {
 		nss_warning("%px: Memory allocation failed for IPv6 Connections: %d\n",
--- a/nss_ipv6_log.c
+++ b/nss_ipv6_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016, 2018, 2020-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016, 2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -103,9 +103,7 @@ static void nss_ipv6_log_rule_create_msg
 		"flow_qos_tag: %x (%u)\n"
 		"return_qos_tag: %x (%u)\n"
 		"flow_dscp: %x\n"
-		"return_dscp: %x\n"
-		"flow_mirror_ifnum: %u\n"
-		"return_mirror_ifnum: %u\n",
+		"return_dscp: %x\n",
 		nim,
 		nircm->tuple.protocol,
 		nircm->conn_rule.flow_mtu,
@@ -129,9 +127,7 @@ static void nss_ipv6_log_rule_create_msg
 		nircm->qos_rule.flow_qos_tag, nircm->qos_rule.flow_qos_tag,
 		nircm->qos_rule.return_qos_tag, nircm->qos_rule.return_qos_tag,
 		nircm->dscp_rule.flow_dscp,
-		nircm->dscp_rule.return_dscp,
-		nircm->mirror_rule.flow_ifnum,
-		nircm->mirror_rule.return_ifnum);
+		nircm->dscp_rule.return_dscp);
 }
 
 /*
--- a/nss_ipv6_stats.c
+++ b/nss_ipv6_stats.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016-2017, 2019-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2017, 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -180,9 +180,6 @@ void nss_ipv6_stats_node_sync(struct nss
 	nss_ipv6_stats[NSS_IPV6_STATS_MC_CONNECTION_DESTROY_REQUESTS] += nins->ipv6_mc_connection_destroy_requests;
 	nss_ipv6_stats[NSS_IPV6_STATS_MC_CONNECTION_DESTROY_MISSES] += nins->ipv6_mc_connection_destroy_misses;
 	nss_ipv6_stats[NSS_IPV6_STATS_MC_CONNECTION_FLUSHES] += nins->ipv6_mc_connection_flushes;
-	nss_ipv6_stats[NSS_IPV6_STATS_CONNECTION_CREATE_INVALID_MIRROR_IFNUM] += nins->ipv6_connection_create_invalid_mirror_ifnum;
-	nss_ipv6_stats[NSS_IPV6_STATS_CONNECTION_CREATE_INVALID_MIRROR_IFTYPE] += nins->ipv6_connection_create_invalid_mirror_iftype;
-	nss_ipv6_stats[NSS_IPV6_STATS_MIRROR_FAILURES] += nins->ipv6_mirror_failures;
 
 	for (i = 0; i < NSS_IPV6_EXCEPTION_EVENT_MAX; i++) {
 		nss_ipv6_exception_stats[i] += nins->exception_events[i];
--- a/nss_ipv6_strings.c
+++ b/nss_ipv6_strings.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
@@ -81,12 +81,14 @@ struct nss_stats_info nss_ipv6_strings_e
 	{"tunipip6_needs_fragmentation"			, NSS_STATS_TYPE_EXCEPTION},
 	{"pppoe_bridge_no_icme"				, NSS_STATS_TYPE_EXCEPTION},
 	{"dont_frag_set"				, NSS_STATS_TYPE_EXCEPTION},
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,0))
 	{"reassembly_not_supported"			, NSS_STATS_TYPE_EXCEPTION},
 	{"pppoe_no_session"				, NSS_STATS_TYPE_DROP},
 	{"icmp_gre_header_incomplete"			, NSS_STATS_TYPE_EXCEPTION},
 	{"icmp_esp_header_incomplete"			, NSS_STATS_TYPE_EXCEPTION},
-	{"emesh_prio_mismatch"				, NSS_STATS_TYPE_EXCEPTION},
-	{"mc_ucast_dmac_failure"			, NSS_STATS_TYPE_EXCEPTION},
+#else
+	{"pppoe_no_session"				, NSS_STATS_TYPE_DROP},
+#endif
 };
 
 /*
@@ -115,10 +117,7 @@ struct nss_stats_info nss_ipv6_strings_s
 	{"mc_create_invalid_interface"	,NSS_STATS_TYPE_SPECIAL},
 	{"mc_destroy_requests"		,NSS_STATS_TYPE_SPECIAL},
 	{"mc_destroy_misses"		,NSS_STATS_TYPE_SPECIAL},
-	{"mc_flushes"			,NSS_STATS_TYPE_SPECIAL},
-	{"mirror_invalid_ifnum_conn_create_req"		,NSS_STATS_TYPE_SPECIAL},
-	{"mirror_invalid_iftype_conn_create_req"	,NSS_STATS_TYPE_SPECIAL},
-	{"mirror_failures"		,NSS_STATS_TYPE_SPECIAL},
+	{"mc_flushes"			,NSS_STATS_TYPE_SPECIAL}
 };
 
 /*
--- a/nss_map_t_stats.c
+++ b/nss_map_t_stats.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017,2019-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017,2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -60,7 +60,7 @@ static ssize_t nss_map_t_stats_read(stru
 	for (id = 0; id < NSS_MAX_MAP_T_DYNAMIC_INTERFACES; id++) {
 
 			if (!map_t_instance_stats[id].valid) {
-				continue;
+				break;
 			}
 
 			dev = dev_get_by_index(&init_net, map_t_instance_stats[id].if_index);
--- a/nss_match.c
+++ b/nss_match.c
@@ -1,6 +1,6 @@
 /*
  ***************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -23,7 +23,6 @@
 #include "nss_tx_rx_common.h"
 #include "nss_match_log.h"
 #include "nss_match_stats.h"
-#include "nss_match_strings.h"
 
 #define NSS_MATCH_TX_TIMEOUT 1000	/* 1 Seconds */
 
@@ -149,7 +148,6 @@ static void nss_match_handler(struct nss
 		 * Update common node statistics
 		 */
 		nss_match_stats_sync(nss_ctx, nem);
-		nss_match_stats_notify(nss_ctx, nem->cm.interface);
 	}
 
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
@@ -211,10 +209,10 @@ nss_tx_status_t nss_match_msg_tx_sync(st
 EXPORT_SYMBOL(nss_match_msg_tx_sync);
 
 /*
- * nss_match_unregister_instance()
- *	Unregisters match instance.
+ * nss_match_register_instance()
+ *	Registers match instance.
  */
-bool nss_match_unregister_instance(int if_num)
+struct nss_ctx_instance *nss_match_register_instance(int if_num, nss_match_msg_sync_callback_t notify_cb)
 {
 	struct nss_ctx_instance *nss_ctx;
 	uint32_t status;
@@ -224,27 +222,32 @@ bool nss_match_unregister_instance(int i
 
 	if (!nss_match_verify_if_num(if_num)) {
 		nss_warning("%px: Incorrect interface number: %d", nss_ctx, if_num);
-		return false;
+		return NULL;
 	}
 
-	nss_core_unregister_handler(nss_ctx, if_num);
-	status = nss_core_unregister_msg_handler(nss_ctx, if_num);
+	nss_core_register_handler(nss_ctx, if_num, nss_match_handler, NULL);
+	status = nss_core_register_msg_handler(nss_ctx, if_num, (nss_if_rx_msg_callback_t)notify_cb);
 	if (status != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%px: Not able to unregister handler for interface %d with NSS core\n", nss_ctx, if_num);
-		return false;
+		nss_warning("%px: Not able to register handler for interface %d with NSS core\n", nss_ctx, if_num);
+		return NULL;
 	}
 
-	nss_match_ifnum_delete(if_num);
+	if (!nss_match_ifnum_add(if_num)) {
+		nss_warning("%px: Unable to add match inteface : %u\n", nss_ctx, if_num);
+		nss_core_unregister_handler(nss_ctx, if_num);
+		nss_core_unregister_msg_handler(nss_ctx, if_num);
+		return NULL;
+	}
 
-	return true;
+	return nss_ctx;
 }
-EXPORT_SYMBOL(nss_match_unregister_instance);
+EXPORT_SYMBOL(nss_match_register_instance);
 
 /*
- * nss_match_register_instance()
- *	Registers match instance.
+ * nss_match_unregister_instance()
+ *	Unregisters match instance.
  */
-struct nss_ctx_instance *nss_match_register_instance(int if_num, nss_match_msg_sync_callback_t notify_cb)
+bool nss_match_unregister_instance(int if_num)
 {
 	struct nss_ctx_instance *nss_ctx;
 	uint32_t status;
@@ -254,26 +257,21 @@ struct nss_ctx_instance *nss_match_regis
 
 	if (!nss_match_verify_if_num(if_num)) {
 		nss_warning("%px: Incorrect interface number: %d", nss_ctx, if_num);
-		return NULL;
+		return false;
 	}
 
-	nss_core_register_handler(nss_ctx, if_num, nss_match_handler, NULL);
-	status = nss_core_register_msg_handler(nss_ctx, if_num, (nss_if_rx_msg_callback_t)notify_cb);
+	nss_core_unregister_handler(nss_ctx, if_num);
+	status = nss_core_unregister_msg_handler(nss_ctx, if_num);
 	if (status != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%px: Not able to register handler for interface %d with NSS core\n", nss_ctx, if_num);
-		return NULL;
+		nss_warning("%px: Not able to unregister handler for interface %d with NSS core\n", nss_ctx, if_num);
+		return false;
 	}
 
-	if (!nss_match_ifnum_add(if_num)) {
-		nss_warning("%px: Unable to add match inteface : %u\n", nss_ctx, if_num);
-		nss_core_unregister_handler(nss_ctx, if_num);
-		nss_core_unregister_msg_handler(nss_ctx, if_num);
-		return NULL;
-	}
+	nss_match_ifnum_delete(if_num);
 
-	return nss_ctx;
+	return true;
 }
-EXPORT_SYMBOL(nss_match_register_instance);
+EXPORT_SYMBOL(nss_match_unregister_instance);
 
 /*
  * nss_match_msg_init()
@@ -293,7 +291,6 @@ EXPORT_SYMBOL(nss_match_msg_init);
 void nss_match_init()
 {
 	nss_match_stats_dentry_create();
-	nss_match_strings_dentry_create();
 	sema_init(&match_pvt.sem, 1);
 	init_completion(&match_pvt.complete);
 }
--- a/nss_match_stats.c
+++ b/nss_match_stats.c
@@ -1,6 +1,6 @@
 /*
  ***************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -23,123 +23,21 @@
 #include "nss_stats.h"
 #include <nss_match.h>
 #include "nss_match_stats.h"
-#include "nss_match_strings.h"
 
 #define NSS_MATCH_STATS_SIZE_PER_IF (NSS_STATS_MAX_STR_LENGTH * NSS_STATS_NODE_MAX)
                                         /* Total number of statistics per match interface. */
 
 int match_ifnum[NSS_MATCH_INSTANCE_MAX] = {0};
-uint64_t nss_match_stats[NSS_MATCH_INSTANCE_MAX][NSS_MATCH_STATS_MAX];
 static DEFINE_SPINLOCK(nss_match_stats_lock);
 
 /*
- * Declare atomic notifier data structure for statistics.
- */
-ATOMIC_NOTIFIER_HEAD(nss_match_stats_notifier);
-
-/*
- * nss_match_stats_read()
- *	Read match node statiistics.
- */
-static ssize_t nss_match_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	/*
-	 * Max output lines = #stats +
-	 * few blank lines for banner printing + Number of Extra outputlines
-	 * for future reference to add new stats
-	 */
-	uint32_t max_output_lines = NSS_MATCH_STATS_MAX + NSS_STATS_EXTRA_OUTPUT_LINES;
-	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines * NSS_MATCH_INSTANCE_MAX;
-	ssize_t bytes_read = 0;
-	size_t size_wr = 0;
-	uint32_t if_num;
-	int index;
-
-	char *lbuf = kzalloc(size_al, GFP_KERNEL);
-	if (unlikely(!lbuf)) {
-		nss_warning("Could not allocate memory for local statistics buffer");
-		return 0;
-	}
-
-	size_wr += nss_stats_banner(lbuf, size_wr, size_al, "match stats", NSS_STATS_SINGLE_CORE);
-
-	/*
-	 * Common node stats for each match dynamic interface.
-	 */
-	for (index = 0; index < NSS_MATCH_INSTANCE_MAX; index++) {
-
-		spin_lock_bh(&nss_match_stats_lock);
-		if_num = match_ifnum[index];
-		spin_unlock_bh(&nss_match_stats_lock);
-
-		if (if_num) {
-			size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\nMatch node if_num:%03u", if_num);
-			size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\n ---------------------- \n");
-			size_wr += nss_stats_print("match", NULL, NSS_STATS_SINGLE_INSTANCE, nss_match_strings_stats,
-						nss_match_stats[index], NSS_MATCH_STATS_MAX, lbuf, size_wr, size_al);
-			continue;
-		}
-	}
-
-	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
-	kfree(lbuf);
-	return bytes_read;
-}
-
-
-/*
- * nss_match_stats_sync()
- *	Update match common node statistics.
- */
-void nss_match_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_match_msg *nmm)
-{
-	struct nss_match_stats_sync *ndccs = &nmm->msg.stats;
-	uint64_t *ctx_stats;
-	uint32_t *msg_stats;
-	uint32_t if_num;
-	uint16_t i = 0;
-	int index;
-
-	for (index = 0; index < NSS_MATCH_INSTANCE_MAX; index++) {
-		spin_lock_bh(&nss_match_stats_lock);
-		if_num = match_ifnum[index];
-		spin_unlock_bh(&nss_match_stats_lock);
-
-		if (if_num == nmm->cm.interface) {
-			break;
-		}
-	}
-
-	if (index == NSS_MATCH_INSTANCE_MAX) {
-		nss_warning("Invalid Match index\n");
-		return;
-	}
-
-	spin_lock_bh(&nss_match_stats_lock);
-	msg_stats = (uint32_t *)ndccs;
-	ctx_stats = nss_match_stats[index];
-
-	for (i = 0; i < NSS_MATCH_STATS_MAX; i++, ctx_stats++, msg_stats++) {
-		*ctx_stats += *msg_stats;
-	}
-
-	spin_unlock_bh(&nss_match_stats_lock);
-}
-
-/*
- * nss_match_stats_ops
- */
-NSS_STATS_DECLARE_FILE_OPERATIONS(match)
-
-/*
  * nss_match_ifnum_add()
- *	Add match node interface ID.
  */
 bool nss_match_ifnum_add(int if_num)
 {
 	int index = 0;
 
-	spin_lock_bh(&nss_match_stats_lock);
+	spin_lock(&nss_match_stats_lock);
 
 	for (index = 0; index < NSS_MATCH_INSTANCE_MAX; index++) {
 		if (match_ifnum[index]) {
@@ -148,23 +46,22 @@ bool nss_match_ifnum_add(int if_num)
 
 		match_ifnum[index] = if_num;
 
-		spin_unlock_bh(&nss_match_stats_lock);
+		spin_unlock(&nss_match_stats_lock);
 		return true;
 	}
 
-	spin_unlock_bh(&nss_match_stats_lock);
+	spin_unlock(&nss_match_stats_lock);
 	return false;
 }
 
 /*
  * nss_match_ifnum_delete()
- *	Delete match node interface ID.
  */
 bool nss_match_ifnum_delete(int if_num)
 {
 	int index = 0;
 
-	spin_lock_bh(&nss_match_stats_lock);
+	spin_lock(&nss_match_stats_lock);
 
 	for (index = 0; index < NSS_MATCH_INSTANCE_MAX; index++) {
 		if (match_ifnum[index] != if_num) {
@@ -173,67 +70,91 @@ bool nss_match_ifnum_delete(int if_num)
 
 		match_ifnum[index] = 0;
 
-		spin_unlock_bh(&nss_match_stats_lock);
+		spin_unlock(&nss_match_stats_lock);
 		return true;
 	}
 
-	spin_unlock_bh(&nss_match_stats_lock);
+	spin_unlock(&nss_match_stats_lock);
 	return false;
 }
 
+
 /*
- * nss_match_stats_notify()
- *	Sends notifications to all the registered modules.
- *
- * Leverage NSS-FW statistics timing to update Netlink.
+ * nss_match_stats_read()
+ *	Read match node statiistics.
  */
-void nss_match_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num)
+static ssize_t nss_match_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
 {
-	struct nss_match_stats_notification match_stats;
-	uint32_t interface;
-	int index;
+	ssize_t bytes_read = 0;
+	uint32_t index, if_num;
+	char *lbuf;
+        size_t size_al = NSS_MATCH_STATS_SIZE_PER_IF * NSS_MATCH_INSTANCE_MAX;
+	size_t size_wr = 0;
 
-	match_stats.core_id = nss_ctx->id;
-	match_stats.if_num = if_num;
+	lbuf = kzalloc(size_al, GFP_KERNEL);
+	if (!lbuf) {
+		nss_warning("Could not allocate memory for local statistics buffer\n");
+		return 0;
+	}
 
+	size_wr += nss_stats_banner(lbuf, size_wr, size_al, "match", NSS_STATS_SINGLE_CORE);
+
+	/*
+	 * Common node stats for each match dynamic interface.
+	 */
 	for (index = 0; index < NSS_MATCH_INSTANCE_MAX; index++) {
+
 		spin_lock_bh(&nss_match_stats_lock);
-		interface = match_ifnum[index];
+		if_num = match_ifnum[index];
 		spin_unlock_bh(&nss_match_stats_lock);
 
-		if (interface == if_num) {
-			break;
+		if (if_num) {
+			size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\nMatch node if_num:%03u", if_num);
+			size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\n ---------------------- \n");
+			size_wr += nss_stats_fill_common_stats(if_num, NSS_STATS_SINGLE_INSTANCE, lbuf, size_wr, size_al, "match");
+			continue;
 		}
 	}
 
-	if (index == NSS_MATCH_INSTANCE_MAX) {
-		nss_warning("Invalid Match index\n");
-		return;
-	}
-
-	spin_lock_bh(&nss_match_stats_lock);
-	memcpy(match_stats.stats_ctx, nss_match_stats[index], sizeof(match_stats.stats_ctx));
-	spin_unlock_bh(&nss_match_stats_lock);
-	atomic_notifier_call_chain(&nss_match_stats_notifier, NSS_STATS_EVENT_NOTIFY, &match_stats);
+	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
+	kfree(lbuf);
+	return bytes_read;
 }
 
+
 /*
- * nss_match_stats_unregister_notifier()
- *	Deregisters statistics notifier.
+ * nss_match_stats_sync()
+ *	Update match common node statistics.
  */
-int nss_match_stats_unregister_notifier(struct notifier_block *nb)
+void nss_match_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_match_msg *nmm)
 {
-	return atomic_notifier_chain_unregister(&nss_match_stats_notifier, nb);
+	struct nss_top_instance *nss_top = nss_ctx->nss_top;
+	struct nss_match_stats_sync *msg_stats = &nmm->msg.stats;
+	uint64_t *if_stats;
+	int index;
+
+	spin_lock_bh(&nss_top->stats_lock);
+
+	/*
+	 * Update common node stats
+	 */
+	if_stats = nss_top->stats_node[nmm->cm.interface];
+	if_stats[NSS_STATS_NODE_RX_PKTS] += msg_stats->p_stats.rx_packets;
+	if_stats[NSS_STATS_NODE_RX_BYTES] += msg_stats->p_stats.rx_bytes;
+	if_stats[NSS_STATS_NODE_TX_PKTS] += msg_stats->p_stats.tx_packets;
+	if_stats[NSS_STATS_NODE_TX_BYTES] += msg_stats->p_stats.tx_bytes;
+
+	for (index = 0; index < NSS_MAX_NUM_PRI; index++) {
+		if_stats[NSS_STATS_NODE_RX_QUEUE_0_DROPPED + index] += msg_stats->p_stats.rx_dropped[index];
+	}
+
+	spin_unlock_bh(&nss_top->stats_lock);
 }
 
 /*
- * nss_match_stats_register_notifier()
- *	Registers statistics notifier.
+ * nss_match_stats_ops
  */
-int nss_match_stats_register_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_register(&nss_match_stats_notifier, nb);
-}
+NSS_STATS_DECLARE_FILE_OPERATIONS(match)
 
 /*
  * nss_match_stats_dentry_create()
--- a/nss_match_stats.h
+++ b/nss_match_stats.h
@@ -1,6 +1,6 @@
 /*
  ***************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -19,63 +19,9 @@
 #ifndef __NSS_MATCH_STATS_H__
 #define __NSS_MATCH_STATS_H__
 
-/**
- * nss_match_stats_types
- *	Match statistics types.
- */
-enum nss_match_stats_types {
-	NSS_MATCH_STATS_HIT_COUNT_0 = NSS_STATS_NODE_MAX,
-					/**< Hit count of rule ID 1. */
-	NSS_MATCH_STATS_HIT_COUNT_1,	/**< Hit count of rule ID 2. */
-	NSS_MATCH_STATS_HIT_COUNT_2,	/**< Hit count of rule ID 3. */
-	NSS_MATCH_STATS_HIT_COUNT_3,	/**< Hit count of rule ID 4. */
-	NSS_MATCH_STATS_HIT_COUNT_4,	/**< Hit count of rule ID 5. */
-	NSS_MATCH_STATS_HIT_COUNT_5,	/**< Hit count of rule ID 6. */
-	NSS_MATCH_STATS_HIT_COUNT_6,	/**< Hit count of rule ID 7. */
-	NSS_MATCH_STATS_HIT_COUNT_7,	/**< Hit count of rule ID 8. */
-	NSS_MATCH_STATS_HIT_COUNT_8,	/**< Hit count of rule ID 9. */
-	NSS_MATCH_STATS_HIT_COUNT_9,	/**< Hit count of rule ID 10. */
-	NSS_MATCH_STATS_HIT_COUNT_10,	/**< Hit count of rule ID 11. */
-	NSS_MATCH_STATS_HIT_COUNT_11,	/**< Hit count of rule ID 12. */
-	NSS_MATCH_STATS_HIT_COUNT_12,	/**< Hit count of rule ID 13. */
-	NSS_MATCH_STATS_HIT_COUNT_13,	/**< Hit count of rule ID 14. */
-	NSS_MATCH_STATS_HIT_COUNT_14,	/**< Hit count of rule ID 15. */
-	NSS_MATCH_STATS_HIT_COUNT_15,	/**< Hit count of rule ID 16. */
-	NSS_MATCH_STATS_HIT_COUNT_16,	/**< Hit count of rule ID 17. */
-	NSS_MATCH_STATS_HIT_COUNT_17,	/**< Hit count of rule ID 18. */
-	NSS_MATCH_STATS_HIT_COUNT_18,	/**< Hit count of rule ID 19. */
-	NSS_MATCH_STATS_HIT_COUNT_19,	/**< Hit count of rule ID 20. */
-	NSS_MATCH_STATS_HIT_COUNT_20,	/**< Hit count of rule ID 21. */
-	NSS_MATCH_STATS_HIT_COUNT_21,	/**< Hit count of rule ID 22. */
-	NSS_MATCH_STATS_HIT_COUNT_22,	/**< Hit count of rule ID 23. */
-	NSS_MATCH_STATS_HIT_COUNT_23,	/**< Hit count of rule ID 24. */
-	NSS_MATCH_STATS_HIT_COUNT_24,	/**< Hit count of rule ID 25. */
-	NSS_MATCH_STATS_HIT_COUNT_25,	/**< Hit count of rule ID 26. */
-	NSS_MATCH_STATS_HIT_COUNT_26,	/**< Hit count of rule ID 27. */
-	NSS_MATCH_STATS_HIT_COUNT_27,	/**< Hit count of rule ID 28. */
-	NSS_MATCH_STATS_HIT_COUNT_28,	/**< Hit count of rule ID 29. */
-	NSS_MATCH_STATS_HIT_COUNT_29,	/**< Hit count of rule ID 30. */
-	NSS_MATCH_STATS_HIT_COUNT_30,	/**< Hit count of rule ID 31. */
-	NSS_MATCH_STATS_HIT_COUNT_31,	/**< Hit count of rule ID 32. */
-	NSS_MATCH_STATS_MAX,		/**< Maximum statistics type. */
-};
-
-/**
- * nss_match_stats_notification
- *	Match transmission statistics structure.
- */
-struct nss_match_stats_notification {
-	uint64_t stats_ctx[NSS_MATCH_STATS_MAX];	/**< Context transmission statistics. */
-	uint32_t core_id;				/**< Core ID. */
-	uint32_t if_num;				/**< Interface number. */
-};
-
 extern bool nss_match_ifnum_add(int if_num);
 extern bool nss_match_ifnum_delete(int if_num);
-extern void nss_match_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num);
 extern void nss_match_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_match_msg *nmm);
 extern void nss_match_stats_dentry_create(void);
-extern int nss_match_stats_unregister_notifier(struct notifier_block *nb);
-extern int nss_match_stats_register_notifier(struct notifier_block *nb);
 
 #endif /* __NSS_MATCH_STATS_H__ */
--- a/nss_match_strings.c
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- ***************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ***************************************************************************
- */
-
-#include "nss_stats.h"
-#include "nss_core.h"
-#include "nss_strings.h"
-#include "nss_match_strings.h"
-
-/*
- * nss_match_strings_stats
- *	match statistics strings.
- */
-struct nss_stats_info nss_match_strings_stats[NSS_MATCH_STATS_MAX] = {
-	{"rx_pkts",		NSS_STATS_TYPE_COMMON},
-	{"rx_byts",		NSS_STATS_TYPE_COMMON},
-	{"tx_pkts",		NSS_STATS_TYPE_COMMON},
-	{"tx_byts",		NSS_STATS_TYPE_COMMON},
-	{"rx_queue[0]_drops",	NSS_STATS_TYPE_DROP},
-	{"rx_queue[1]_drops",	NSS_STATS_TYPE_DROP},
-	{"rx_queue[2]_drops",	NSS_STATS_TYPE_DROP},
-	{"rx_queue[3]_drops",	NSS_STATS_TYPE_DROP},
-	{"hit_count[0]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[1]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[2]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[3]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[4]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[5]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[6]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[7]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[8]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[9]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[10]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[11]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[12]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[13]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[14]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[15]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[16]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[17]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[18]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[19]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[20]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[21]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[22]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[23]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[24]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[25]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[26]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[27]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[28]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[29]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[30]",	NSS_STATS_TYPE_SPECIAL},
-	{"hit_count[31]",	NSS_STATS_TYPE_SPECIAL}
-};
-
-/*
- * nss_match_stats_strings_read()
- *	Read match statistics names
- */
-static ssize_t nss_match_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_match_strings_stats, NSS_MATCH_STATS_MAX);
-}
-
-/*
- * nss_match_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(match);
-
-/*
- * nss_match_strings_dentry_create()
- *	Create match statistics strings debug entry.
- */
-void nss_match_strings_dentry_create(void)
-{
-	nss_strings_create_dentry("match", &nss_match_strings_ops);
-}
--- a/nss_match_strings.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- ***************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ***************************************************************************
- */
-
-#ifndef __NSS_MATCH_STRINGS_H
-#define __NSS_MATCH_STRINGS_H
-
-#include "nss_match_stats.h"
-
-extern struct nss_stats_info nss_match_strings_stats[NSS_MATCH_STATS_MAX];
-extern void nss_match_strings_dentry_create(void);
-
-#endif /* __NSS_MATCH_STRINGS_H */
--- a/nss_meminfo.c
+++ b/nss_meminfo.c
@@ -735,7 +735,7 @@ bool nss_meminfo_init(struct nss_ctx_ins
 	/*
 	 * meminfo_start is the label where the start address of meminfo map is stored.
 	 */
-	meminfo_start = (uint32_t *)ioremap_nocache(nss_ctx->load + NSS_MEMINFO_MAP_START_OFFSET,
+	meminfo_start = (uint32_t *)ioremap(nss_ctx->load + NSS_MEMINFO_MAP_START_OFFSET,
 							NSS_MEMINFO_RESERVE_AREA_SIZE);
 	if (!meminfo_start) {
 		nss_info_always("%px: cannot remap meminfo start\n", nss_ctx);
--- a/nss_mirror.c
+++ b/nss_mirror.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
@@ -18,7 +18,6 @@
 
 #include "nss_tx_rx_common.h"
 #include "nss_mirror_stats.h"
-#include "nss_mirror_strings.h"
 #include "nss_mirror_log.h"
 
 #define NSS_MIRROR_TX_TIMEOUT 3000 /* 3 Seconds */
@@ -90,7 +89,6 @@ static void nss_mirror_handler(struct ns
 		 * Debug stats embedded in stats msg.
 		 */
 		nss_mirror_stats_sync(nss_ctx, nmm, ncm->interface);
-		nss_mirror_stats_notify(nss_ctx, ncm->interface);
 		break;
 	}
 
@@ -292,5 +290,4 @@ void nss_mirror_register_handler(void)
 	init_completion(&nss_mirror_pvt.complete);
 
 	nss_mirror_stats_dentry_create();
-	nss_mirror_strings_dentry_create();
 }
--- a/nss_mirror_stats.c
+++ b/nss_mirror_stats.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
@@ -18,19 +18,28 @@
 
 #include "nss_stats.h"
 #include "nss_core.h"
-#include "nss_mirror.h"
 #include "nss_mirror_stats.h"
-#include "nss_mirror_strings.h"
 
 static struct nss_mirror_stats_debug_instance *stats_db[NSS_MAX_MIRROR_DYNAMIC_INTERFACES];
 					/* Mirror stats data structure. */
 
 /*
- * Atomic notifier data structure for statistics
+ * Data structures to store mirror interface stats.
  */
-ATOMIC_NOTIFIER_HEAD(nss_mirror_stats_notifier);
+static DEFINE_SPINLOCK(nss_mirror_stats_debug_lock);
 
-static DEFINE_SPINLOCK(nss_mirror_stats_lock);
+/*
+ * nss_mirror_stats_str
+ *	Mirror statistics strings for nss session stats.
+ */
+struct nss_stats_info nss_mirror_stats_str[NSS_MIRROR_STATS_MAX] = {
+	{"MIRROR_STATS_PKTS"			, NSS_STATS_TYPE_SPECIAL},
+	{"MIRROR_STATS_BYTES"			, NSS_STATS_TYPE_SPECIAL},
+	{"MIRROR_STATS_TX_FAIL"			, NSS_STATS_TYPE_DROP},
+	{"MIRROR_STATS_DEST_LOOKUP_FAIL"	, NSS_STATS_TYPE_DROP},
+	{"MIRROR_STATS_MEM_ALLOC_FAIL"		, NSS_STATS_TYPE_ERROR},
+	{"MIRROR_STATS_COPY_FAIL"		, NSS_STATS_TYPE_ERROR},
+};
 
 /*
  * nss_mirror_stats_get()
@@ -46,7 +55,7 @@ static void nss_mirror_stats_get(void *s
 		return;
 	}
 
-	spin_lock_bh(&nss_mirror_stats_lock);
+	spin_lock_bh(&nss_mirror_stats_debug_lock);
 	for (i = 0; i < NSS_MAX_MIRROR_DYNAMIC_INTERFACES; i++) {
 
 		/*
@@ -62,7 +71,7 @@ static void nss_mirror_stats_get(void *s
 			}
 		}
 	}
-	spin_unlock_bh(&nss_mirror_stats_lock);
+	spin_unlock_bh(&nss_mirror_stats_debug_lock);
 }
 
 /*
@@ -106,7 +115,7 @@ static ssize_t nss_mirror_stats_read(str
 	 * Get all stats
 	 */
 	nss_mirror_stats_get((void *)mirror_shadow_stats, mirror_active_instances);
-	size_wr += nss_stats_banner(lbuf, size_wr, size_al, "mirror stats", NSS_STATS_SINGLE_CORE);
+	size_wr += nss_stats_banner(lbuf, size_wr, size_al, "mirror", NSS_STATS_SINGLE_CORE);
 
 	/*
 	 * Session stats
@@ -128,12 +137,13 @@ static ssize_t nss_mirror_stats_read(str
 			/*
 			 * Mirror interface exception stats.
 			 */
-			size_wr += nss_stats_print("mirror", "mirror exception stats",
+			size_wr += nss_stats_print("mirror", "mirror exception stats start",
 							 id,
-							 nss_mirror_strings_stats,
+							 nss_mirror_stats_str,
 							 mirror_shadow_stats[id].stats,
 							 NSS_MIRROR_STATS_MAX,
 							 lbuf, size_wr, size_al);
+			size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\n");
 	}
 
 	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, size_wr);
@@ -156,7 +166,7 @@ void nss_mirror_stats_sync(struct nss_ct
 	struct nss_cmn_node_stats *node_stats_ptr = &stats_msg->node_stats;
 	uint32_t *mirror_stats_ptr = (uint32_t *)&stats_msg->mirror_stats;
 
-	spin_lock_bh(&nss_mirror_stats_lock);
+	spin_lock_bh(&nss_mirror_stats_debug_lock);
 	for (i = 0; i < NSS_MAX_MIRROR_DYNAMIC_INTERFACES; i++) {
 		if (!stats_db[i] || (stats_db[i]->if_num != if_num)) {
 			continue;
@@ -168,16 +178,16 @@ void nss_mirror_stats_sync(struct nss_ct
 			 */
 			stats_db[i]->stats[j] += mirror_stats_ptr[j];
 		}
-		spin_unlock_bh(&nss_mirror_stats_lock);
+		spin_unlock_bh(&nss_mirror_stats_debug_lock);
 		goto sync_cmn_stats;
 	}
 
-	spin_unlock_bh(&nss_mirror_stats_lock);
 	nss_warning("Invalid mirror stats sync message received for %d interface\n", if_num);
+	spin_unlock_bh(&nss_mirror_stats_debug_lock);
 	return;
 
 sync_cmn_stats:
-	spin_lock_bh(&nss_mirror_stats_lock);
+	spin_lock_bh(&nss_top->stats_lock);
 
 	/*
 	 * Sync common stats.
@@ -192,7 +202,7 @@ sync_cmn_stats:
 			node_stats_ptr->rx_dropped[i];
 	}
 
-	spin_unlock_bh(&nss_mirror_stats_lock);
+	spin_unlock_bh(&nss_top->stats_lock);
 }
 
 /*
@@ -212,7 +222,7 @@ void nss_mirror_stats_reset(uint32_t if_
 	/*
 	 * Reset mirror stats.
 	 */
-	spin_lock_bh(&nss_mirror_stats_lock);
+	spin_lock_bh(&nss_mirror_stats_debug_lock);
 	for (i = 0; i < NSS_MAX_MIRROR_DYNAMIC_INTERFACES; i++) {
 		if (!stats_db[i] || (stats_db[i]->if_num != if_num)) {
 			continue;
@@ -222,7 +232,7 @@ void nss_mirror_stats_reset(uint32_t if_
 		stats_db[i] = NULL;
 		break;
 	}
-	spin_unlock_bh(&nss_mirror_stats_lock);
+	spin_unlock_bh(&nss_mirror_stats_debug_lock);
 
 	if (mirror_debug_instance) {
 		vfree(mirror_debug_instance);
@@ -245,7 +255,7 @@ int nss_mirror_stats_init(uint32_t if_nu
 		return -1;
 	}
 
-	spin_lock_bh(&nss_mirror_stats_lock);
+	spin_lock_bh(&nss_mirror_stats_debug_lock);
 	for (i = 0; i < NSS_MAX_MIRROR_DYNAMIC_INTERFACES; i++) {
 		if (stats_db[i] != NULL) {
 			continue;
@@ -254,10 +264,10 @@ int nss_mirror_stats_init(uint32_t if_nu
 		stats_db[i] = mirror_debug_instance;
 		stats_db[i]->if_num = if_num;
 		stats_db[i]->if_index = netdev->ifindex;
-		spin_unlock_bh(&nss_mirror_stats_lock);
+		spin_unlock_bh(&nss_mirror_stats_debug_lock);
 		return 0;
 	}
-	spin_unlock_bh(&nss_mirror_stats_lock);
+	spin_unlock_bh(&nss_mirror_stats_debug_lock);
 	vfree(mirror_debug_instance);
 	return -1;
 }
@@ -275,50 +285,3 @@ void nss_mirror_stats_dentry_create(void
 {
 	nss_stats_create_dentry("mirror", &nss_mirror_stats_ops);
 }
-
-/*
- * nss_mirror_stats_notify()
- *	Sends notifications to all the registered modules.
- *
- * Leverage NSS-FW statistics timing to update Netlink.
- */
-void nss_mirror_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num)
-{
-	struct nss_mirror_stats_notification mirror_stats;
-	int i;
-
-	spin_lock_bh(&nss_mirror_stats_lock);
-	for (i = 0; i < NSS_MAX_MIRROR_DYNAMIC_INTERFACES; i++) {
-		if (!stats_db[i] || (stats_db[i]->if_num != if_num)) {
-			continue;
-		}
-
-		memcpy(mirror_stats.stats_ctx, stats_db[i]->stats, sizeof(mirror_stats.stats_ctx));
-		mirror_stats.core_id = nss_ctx->id;
-		mirror_stats.if_num = if_num;
-		spin_unlock_bh(&nss_mirror_stats_lock);
-		atomic_notifier_call_chain(&nss_mirror_stats_notifier, NSS_STATS_EVENT_NOTIFY, &mirror_stats);
-		return;
-	}
-	spin_unlock_bh(&nss_mirror_stats_lock);
-}
-
-/*
- * nss_mirror_stats_unregister_notifier()
- *	Deregisters statistics notifier.
- */
-int nss_mirror_stats_unregister_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_unregister(&nss_mirror_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_mirror_stats_unregister_notifier);
-
-/*
- * nss_mirror_stats_register_notifier()
- *	Registers statistics notifier.
- */
-int nss_mirror_stats_register_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_register(&nss_mirror_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_mirror_stats_register_notifier);
--- a/nss_mirror_stats.h
+++ b/nss_mirror_stats.h
@@ -1,6 +1,6 @@
 /*
  ******************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
@@ -25,6 +25,20 @@
 extern atomic_t nss_mirror_num_instances;
 
 /*
+ * nss_mirror_stats
+ *	Mirror interface debug statistics.
+ */
+enum nss_mirror_stats {
+	NSS_MIRROR_STATS_PKTS,			/* Number of packets exceptioned to host. */
+	NSS_MIRROR_STATS_BYTES,			/* Number of bytes exceptioned to host. */
+	NSS_MIRROR_STATS_TX_SEND_FAIL,		/* Transmit send failures. */
+	NSS_MIRROR_STATS_DEST_LOOKUP_FAIL,	/* Destination lookup failures. */
+	NSS_MIRROR_STATS_MEM_ALLOC_FAIL,	/* Memory allocation failures. */
+	NSS_MIRROR_STATS_COPY_FAIL,		/* Copy failures. */
+	NSS_MIRROR_STATS_MAX			/* Maximum statistics count. */
+};
+
+/*
  * nss_mirror_stats_debug_instance
  *	Stucture for H2N/N2H mirror interface debug stats.
  */
@@ -34,11 +48,29 @@ struct nss_mirror_stats_debug_instance {
 	uint32_t if_num;			/* Mirror instance NSS interface number */
 };
 
+/*
+ * nss_mirror_stats_sync()
+ *	API to sync statistics for mirror interface.
+ */
 extern void nss_mirror_stats_sync(struct nss_ctx_instance *nss_ctx,
 		 struct nss_mirror_msg *nmm, uint16_t if_num);
+
+/*
+ * nss_mirror_stats_reset()
+ *	API to reset the mirror interface stats.
+ */
 extern void nss_mirror_stats_reset(uint32_t if_num);
+
+/*
+ * nss_mirror_stats_init()
+ *	API to initialize mirror debug instance statistics.
+ */
 extern int nss_mirror_stats_init(uint32_t if_num, struct net_device *netdev);
+
+/*
+ * nss_mirror_stats_dentry_create()
+ *	Create mirror interface statistics debug entry.
+ */
 extern void nss_mirror_stats_dentry_create(void);
-extern void nss_mirror_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num);
 
 #endif /* __NSS_MIRROR_STATS_H */
--- a/nss_mirror_strings.c
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- ***************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ***************************************************************************
- */
-
-#include "nss_stats.h"
-#include "nss_core.h"
-#include "nss_strings.h"
-#include "nss_mirror_strings.h"
-
-/*
- * nss_mirror_strings_stats
- *	Mirror statistics strings for nss session stats.
- */
-struct nss_stats_info nss_mirror_strings_stats[NSS_MIRROR_STATS_MAX] = {
-	{"pkts",		NSS_STATS_TYPE_SPECIAL},
-	{"bytes",		NSS_STATS_TYPE_SPECIAL},
-	{"tx_fail",		NSS_STATS_TYPE_DROP},
-	{"dest_lookup_fail",	NSS_STATS_TYPE_DROP},
-	{"mem_alloc_fail",	NSS_STATS_TYPE_ERROR},
-	{"copy_fail",		NSS_STATS_TYPE_ERROR},
-};
-
-/*
- * nss_mirror_strings_read()
- *	Read mirror statistics names
- */
-static ssize_t nss_mirror_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_mirror_strings_stats, NSS_MIRROR_STATS_MAX);
-}
-
-/*
- * nss_mirror_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(mirror);
-
-/*
- * nss_mirror_strings_dentry_create()
- *	Create mirror statistics strings debug entry.
- */
-void nss_mirror_strings_dentry_create(void)
-{
-	nss_strings_create_dentry("mirror", &nss_mirror_strings_ops);
-}
--- a/nss_mirror_strings.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- ***************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ***************************************************************************
- */
-
-#ifndef __NSS_MIRROR_STRINGS_H
-#define __NSS_MIRROR_STRINGS_H
-
-#include "nss_mirror_stats.h"
-
-extern struct nss_stats_info nss_mirror_strings_stats[NSS_MIRROR_STATS_MAX];
-extern void nss_mirror_strings_dentry_create(void);
-
-#endif /* __NSS_MIRROR_STRINGS_H */
--- a/nss_n2h.c
+++ b/nss_n2h.c
@@ -33,12 +33,6 @@
 #define NSS_N2H_DEFAULT_EMPTY_POOL_BUF_SZ	8192
 #define NSS_N2H_TX_TIMEOUT 3000 /* 3 Seconds */
 
-/*
- * Allocate shaper pool memory in multiple chunk of PAGE_SIZE
- */
-#define NSS_N2H_MIN_QOS_MEM_POOL_SZ		1
-#define NSS_N2H_QOS_MEM_POOL_SZ_MB(size)		(size * 1024 * 1024)
-
 int nss_n2h_empty_pool_buf_cfg[NSS_MAX_CORES] __read_mostly = {-1, -1};
 int nss_n2h_empty_paged_pool_buf_cfg[NSS_MAX_CORES] __read_mostly = {-1, -1};
 int nss_n2h_water_mark[NSS_MAX_CORES][2] __read_mostly = {{-1, -1}, {-1, -1} };
@@ -50,7 +44,6 @@ int nss_n2h_core0_add_buf_pool_size __re
 int nss_n2h_core1_add_buf_pool_size __read_mostly;
 int nss_n2h_queue_limit[NSS_MAX_CORES] __read_mostly = {NSS_DEFAULT_QUEUE_LIMIT, NSS_DEFAULT_QUEUE_LIMIT};
 int nss_n2h_host_bp_config[NSS_MAX_CORES] __read_mostly;
-int nss_n2h_shaper_pool_size_cfg __read_mostly;
 
 struct nss_n2h_registered_data {
 	nss_n2h_msg_callback_t n2h_callback;
@@ -67,9 +60,6 @@ static struct nss_n2h_cfg_pvt nss_n2h_q_
 static struct nss_n2h_cfg_pvt nss_n2h_q_lim_pvt;
 static struct nss_n2h_cfg_pvt nss_n2h_host_bp_cfg_pvt;
 
-static uint32_t nss_n2h_shaper_pool_cfg_num_pages;
-static nss_tx_status_t nss_n2h_cfg_shaper_pool(struct nss_ctx_instance *nss_ctx)
-;
 /*
  * nss_n2h_interface_handler()
  *	Handle NSS -> HLOS messages for N2H node
@@ -995,24 +985,6 @@ static int nss_n2h_wifi_payloads_handler
 }
 
 /*
- * nss_n2h_get_qos_mem_size_cfg_handler()
- *	Gets the QoS memory pool size
- */
-static int nss_n2h_get_qos_mem_size_cfg_handler(struct ctl_table *ctl,
-			int write, void __user *buffer,
-			size_t *lenp, loff_t *ppos)
-{
-	int ret = NSS_FAILURE;
-
-	if (!write) {
-		nss_n2h_shaper_pool_size_cfg = NSS_N2H_QOS_MEM_POOL_SZ_MB(nss_core_get_qos_mem_size());
-	}
-
-	ret = proc_dointvec(ctl, write, buffer, lenp, ppos);
-	return ret;
-}
-
-/*
  * nss_n2h_update_queue_config_callback()
  *	Callback to handle the completion of queue config command
  */
@@ -1734,13 +1706,6 @@ static struct ctl_table nss_n2h_table_si
 		.mode		= 0644,
 		.proc_handler	= &nss_n2h_host_bp_cfg_core0_handler,
 	},
-	{
-		.procname		= "qos_mem_size",
-		.data			= &nss_n2h_shaper_pool_size_cfg,
-		.maxlen			= sizeof(int),
-		.mode			= 0644,
-		.proc_handler	= &nss_n2h_get_qos_mem_size_cfg_handler,
-	},
 
 	{ }
 };
@@ -1894,13 +1859,6 @@ static struct ctl_table nss_n2h_table_mu
 		.mode		= 0644,
 		.proc_handler	= &nss_n2h_host_bp_cfg_core1_handler,
 	},
-	{
-		.procname		= "qos_mem_size",
-		.data			= &nss_n2h_shaper_pool_size_cfg,
-		.maxlen			= sizeof(int),
-		.mode			= 0644,
-		.proc_handler	= &nss_n2h_get_qos_mem_size_cfg_handler,
-	},
 	{ }
 };
 
@@ -1977,113 +1935,6 @@ nss_tx_status_t nss_n2h_cfg_empty_pool_s
 	return nss_tx_status;
 }
 
-static inline void nss_n2h_shaper_pool_free(struct nss_n2h_shaper_mem_cfg_msg *nnsmcm, int num_blks)
-{
-	int blk_count;
-	for (blk_count = 0; blk_count < num_blks; blk_count++) {
-		kfree((void *)nnsmcm->pool_vaddr[blk_count]);
-	}
-}
-
-/*
- * nss_n2h_cfg_qos_mem_size_callback()
- *	Call back function for QoS memory pool size configuration
- */
-static void nss_n2h_cfg_qos_mem_size_callback(void *app_data, struct nss_n2h_msg *nnm)
-{
-	struct nss_ctx_instance *nss_ctx __maybe_unused = (struct nss_ctx_instance *)app_data;
-	struct nss_n2h_shaper_mem_cfg_msg *nnsmcm = &nnm->msg.shaper_mem_cfg;
-	nnsmcm->num_blks = ntohl(nnsmcm->num_blks);
-
-	if (nnm->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_warning("%px: Shaper pool configuration failed with error: %d\n", nss_ctx, nnm->cm.error);
-		nss_n2h_shaper_pool_free(nnsmcm, nnsmcm->num_blks);
-		return;
-	}
-
-	nss_core_update_qos_mem_size(nss_core_get_qos_mem_size() + (PAGE_SIZE * nnsmcm->num_blks));
-	nss_n2h_cfg_shaper_pool(nss_ctx);
-	nss_info("%px: shaper pool configuration success\n", nss_ctx);
-}
-
-/*
- * nss_n2h_cfg_shaper_pool()
- *	Config QoS memory pool in NSS FW
- */
-static nss_tx_status_t nss_n2h_cfg_shaper_pool(struct nss_ctx_instance *nss_ctx)
-{
-	struct nss_n2h_msg nnm;
-	struct nss_n2h_shaper_mem_cfg_msg *nnsmcm;
-	nss_tx_status_t nss_tx_status;
-	int blk_count;
-
-	if (!nss_n2h_shaper_pool_cfg_num_pages) {
-		return NSS_TX_SUCCESS;
-	}
-
-	memset(&nnm, 0, sizeof(struct nss_n2h_msg));
-	nss_n2h_msg_init(&nnm, NSS_N2H_INTERFACE,
-			NSS_TX_METADATA_TYPE_N2H_SHAPER_POOL_CFG,
-			sizeof(struct nss_n2h_shaper_mem_cfg_msg),
-			nss_n2h_cfg_qos_mem_size_callback,
-			(void *)nss_ctx);
-
-	nnsmcm = &nnm.msg.shaper_mem_cfg;
-
-	for (blk_count = 0; blk_count < MAX_PAGES_PER_MSG; blk_count++) {
-		void *kern_addr = kzalloc(PAGE_SIZE, GFP_ATOMIC);
-		if (!kern_addr) {
-			nss_warning("%px: memory allocation failed for shaper pool", nss_ctx);
-			return NSS_TX_FAILURE;
-		}
-
-		kmemleak_not_leak(kern_addr);
-		nnsmcm->pool_vaddr[blk_count] = (nss_ptr_t)kern_addr;
-		nnsmcm->pool_addr[blk_count] = dma_map_single(nss_ctx->dev, kern_addr, PAGE_SIZE, DMA_TO_DEVICE);
-	}
-
-	nnsmcm->mem_blk_size = htonl(PAGE_SIZE);
-	nnsmcm->num_blks = htonl(blk_count);
-	nss_tx_status = nss_n2h_tx_msg(nss_ctx, &nnm);
-
-	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_n2h_shaper_pool_free(nnsmcm, blk_count);
-		nss_warning("%px: nss_tx error setting shaper pool\n", nss_ctx);
-		return NSS_TX_FAILURE;
-	}
-
-	nss_n2h_shaper_pool_cfg_num_pages--;
-	return NSS_TX_SUCCESS;
-}
-
-/*
- * nss_n2h_cfg_qos_mem_size()
- *	Config QoS memory pool size
- */
-nss_tx_status_t nss_n2h_cfg_qos_mem_size(struct nss_ctx_instance *nss_ctx, uint32_t pool_sz)
-{
-	nss_info("%px: update QoS memory pool size: %dMB\n",
-		nss_ctx, pool_sz);
-
-	if (!pool_sz) {
-		nss_info("%px: No extra memory allocated for QoS memory pool",
-				nss_ctx);
-		return NSS_TX_SUCCESS;
-	}
-
-	if (pool_sz < NSS_N2H_MIN_QOS_MEM_POOL_SZ) {
-		nss_warning("%px: pool size: %d is less than minimum value allowed: %d",
-				nss_ctx, pool_sz, NSS_N2H_MIN_QOS_MEM_POOL_SZ);
-		return NSS_TX_FAILURE;
-	}
-
-	nss_n2h_shaper_pool_cfg_num_pages = ALIGN(NSS_N2H_QOS_MEM_POOL_SZ_MB(pool_sz), PAGE_SIZE)/(PAGE_SIZE * MAX_PAGES_PER_MSG);
-
-	nss_info("%px: shaper pool size:%d bytes\n", nss_ctx, NSS_N2H_QOS_MEM_POOL_SZ_MB(pool_sz));
-
-	return nss_n2h_cfg_shaper_pool(nss_ctx);
-}
-
 /*
  * nss_n2h_paged_buf_pool_init()
  *	Sends a command down to NSS to initialize paged buffer pool
--- a/nss_n2h_stats.c
+++ b/nss_n2h_stats.c
@@ -38,7 +38,7 @@ static ssize_t nss_n2h_stats_read(struct
 	 * Max output lines = #stats + few blank lines for banner printing +
 	 * Number of Extra outputlines for future reference to add new stats
 	 */
-	uint32_t max_output_lines = (NSS_N2H_STATS_MAX + 3) * NSS_MAX_CORES + NSS_STATS_EXTRA_OUTPUT_LINES;
+	uint32_t max_output_lines = (NSS_N2H_STATS_MAX + 3) * 2 + 5;
 	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
 	size_t size_wr = 0;
 	ssize_t bytes_read = 0;
--- a/nss_n2h_strings.c
+++ b/nss_n2h_strings.c
@@ -38,14 +38,14 @@ struct nss_stats_info nss_n2h_strings_st
 	{"ticks"			, NSS_STATS_TYPE_SPECIAL},
 	{"worst_ticks"			, NSS_STATS_TYPE_SPECIAL},
 	{"iterations"			, NSS_STATS_TYPE_SPECIAL},
-	{"pbuf_ocm_total_count"		, NSS_STATS_TYPE_SPECIAL},
-	{"pbuf_ocm_free_count"		, NSS_STATS_TYPE_SPECIAL},
 	{"pbuf_ocm_alloc_fail_payload"	, NSS_STATS_TYPE_SPECIAL},
+	{"pbuf_ocm_free_count"		, NSS_STATS_TYPE_SPECIAL},
+	{"pbuf_ocm_total_count"		, NSS_STATS_TYPE_SPECIAL},
 	{"pbuf_ocm_alloc_fail_nopayload", NSS_STATS_TYPE_SPECIAL},
-	{"pbuf_def_total_count"		, NSS_STATS_TYPE_SPECIAL},
-	{"pbuf_def_free_count"		, NSS_STATS_TYPE_SPECIAL},
 	{"pbuf_def_alloc_fail_payload"	, NSS_STATS_TYPE_SPECIAL},
+	{"pbuf_def_free_count"		, NSS_STATS_TYPE_SPECIAL},
 	{"pbuf_def_alloc_fail_nopayload", NSS_STATS_TYPE_SPECIAL},
+	{"pbuf_def_total_count"		, NSS_STATS_TYPE_SPECIAL},
 	{"payload_alloc_fails"		, NSS_STATS_TYPE_SPECIAL},
 	{"payload_free_count"		, NSS_STATS_TYPE_SPECIAL},
 	{"h2n_control_pkts"		, NSS_STATS_TYPE_SPECIAL},
--- a/nss_phys_if.h
+++ b/nss_phys_if.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -70,12 +70,6 @@ struct nss_phys_if_estats {
 	uint32_t gmac_worst_case_ticks;	/**< Worst case iteration of the GMAC in ticks */
 	uint32_t gmac_iterations;	/**< Number of iterations around the GMAC */
 	uint32_t tx_pause_frames;	/**< Number of pause frames sent by the GMAC */
-
-	/*
-	 * On IPQ50xx, we rely on the SSDK to pull the mmc stats.
-	 * The FAL layer does not do this on IPQ806x.
-	 */
-#if defined(NSS_HAL_IPQ806X_SUPPORT)
 	uint32_t mmc_rx_overflow_errors;
 					/**< Number of RX overflow errors */
 	uint32_t mmc_rx_watchdog_timeout_errors;
@@ -100,7 +94,6 @@ struct nss_phys_if_estats {
 	uint32_t mmc_tx_single_col;	/* Number of single collisions */
 	uint32_t mmc_tx_multiple_col;	/* Number of multiple collisions */
 	uint32_t mmc_tx_octets_gb;	/* Number of good/bad octets sent*/
-#endif
 };
 
 /**
--- a/nss_ppe.c
+++ b/nss_ppe.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016-2018, 2020-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -16,7 +16,6 @@
 
 #include "nss_ppe.h"
 #include "nss_ppe_stats.h"
-#include "nss_ppe_strings.h"
 
 DEFINE_SPINLOCK(nss_ppe_stats_lock);
 
@@ -272,7 +271,6 @@ static void nss_ppe_handler(struct nss_c
 		 * session debug stats embeded in session stats msg
 		 */
 		nss_ppe_stats_sync(nss_ctx, &msg->msg.stats, ncm->interface);
-		nss_ppe_stats_notify(nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -311,7 +309,6 @@ void nss_ppe_register_handler(void)
 
 	if (nss_ppe_debug_stats.valid) {
 		nss_ppe_stats_dentry_create();
-		nss_ppe_strings_dentry_create();
 	}
 }
 
@@ -357,7 +354,7 @@ void nss_ppe_init(void)
 	/*
 	 * Get the PPE base address
 	 */
-	ppe_pvt.ppe_base = ioremap_nocache(PPE_BASE_ADDR, PPE_REG_SIZE);
+	ppe_pvt.ppe_base = ioremap(PPE_BASE_ADDR, PPE_REG_SIZE);
 	if (!ppe_pvt.ppe_base) {
 		nss_warning("DRV can't get PPE base address\n");
 		return;
--- a/nss_ppe_stats.c
+++ b/nss_ppe_stats.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -17,12 +17,6 @@
 #include "nss_core.h"
 #include "nss_ppe.h"
 #include "nss_ppe_stats.h"
-#include "nss_ppe_strings.h"
-
-/*
- * Declare atomic notifier data structure for statistics.
- */
-ATOMIC_NOTIFIER_HEAD(nss_ppe_stats_notifier);
 
 static uint8_t ppe_cc_nonexception[NSS_PPE_STATS_CPU_CODE_NONEXCEPTION_MAX] = {
 	NSS_PPE_STATS_CPU_CODE_EXP_FAKE_L2_PROT_ERR,
@@ -109,10 +103,371 @@ static uint8_t ppe_cc_nonexception[NSS_P
 };
 
 /*
- * nss_ppe_stats_str_sc_type
- *      PPE service-code stats type
+ * nss_ppe_stats_str_conn
+ *	PPE statistics strings for nss flow stats
+ */
+static int8_t *nss_ppe_stats_str_conn[NSS_PPE_STATS_CONN_MAX] = {
+	"v4 routed flows",
+	"v4 bridge flows",
+	"v4 conn create req",
+	"v4 conn create fail",
+	"v4 conn destroy req",
+	"v4 conn destroy fail",
+	"v4 conn MC create req",
+	"v4 conn MC create fail",
+	"v4 conn MC update req",
+	"v4 conn MC update fail",
+	"v4 conn MC delete req",
+	"v4 conn MC delete fail",
+	"v4 conn unknown if",
+
+	"v6 routed flows",
+	"v6 bridge flows",
+	"v6 conn create req",
+	"v6 conn create fail",
+	"v6 conn destroy req",
+	"v6 conn destroy fail",
+	"v6 conn MC create req",
+	"v6 conn MC create fail",
+	"v6 conn MC update req",
+	"v6 conn MC update fail",
+	"v6 conn MC delete req",
+	"v6 conn MC delete fail",
+	"v6 conn unknown if",
+
+	"conn fail - vp full",
+	"conn fail - nexthop full",
+	"conn fail - flow full",
+	"conn fail - host full",
+	"conn fail - pub-ip full",
+	"conn fail - port not setup",
+	"conn fail - rw fifo full",
+	"conn fail - flow cmd failure",
+	"conn fail - unknown proto",
+	"conn fail - ppe not responding",
+	"conn fail - CE opaque invalid",
+	"conn fail - fqg full"
+};
+
+/*
+ * nss_ppe_stats_str_l3
+ *	PPE statistics strings for nss debug stats
+ */
+static int8_t *nss_ppe_stats_str_l3[NSS_PPE_STATS_L3_MAX] = {
+	"PPE L3 dbg reg 0",
+	"PPE L3 dbg reg 1",
+	"PPE L3 dbg reg 2",
+	"PPE L3 dbg reg 3",
+	"PPE L3 dbg reg 4",
+	"PPE L3 dbg reg port",
+};
+
+/*
+ * nss_ppe_stats_str_code
+ *	PPE statistics strings for nss debug stats
+ */
+static int8_t *nss_ppe_stats_str_code[NSS_PPE_STATS_CODE_MAX] = {
+	"PPE CPU_CODE",
+	"PPE DROP_CODE",
+};
+
+/*
+ * nss_ppe_stats_str_dc
+ *	PPE statistics strings for drop code
  */
-static int8_t *nss_ppe_stats_str_sc_type[NSS_PPE_SC_MAX] = {
+static int8_t *nss_ppe_stats_str_dc[NSS_PPE_STATS_DROP_CODE_MAX] = {
+	"PPE_DROP_CODE_NONE",
+	"PPE_DROP_CODE_EXP_UNKNOWN_L2_PORT",
+	"PPE_DROP_CODE_EXP_PPPOE_WRONG_VER_TYPE",
+	"PPE_DROP_CODE_EXP_PPPOE_WRONG_CODE",
+	"PPE_DROP_CODE_EXP_PPPOE_UNSUPPORTED_PPP_PROT",
+	"PPE_DROP_CODE_EXP_IPV4_WRONG_VER",
+	"PPE_DROP_CODE_EXP_IPV4_SMALL_IHL",
+	"PPE_DROP_CODE_EXP_IPV4_WITH_OPTION",
+	"PPE_DROP_CODE_EXP_IPV4_HDR_INCOMPLETE",
+	"PPE_DROP_CODE_EXP_IPV4_BAD_TOTAL_LEN",
+	"PPE_DROP_CODE_EXP_IPV4_DATA_INCOMPLETE",
+	"PPE_DROP_CODE_EXP_IPV4_FRAG",
+	"PPE_DROP_CODE_EXP_IPV4_PING_OF_DEATH",
+	"PPE_DROP_CODE_EXP_IPV4_SNALL_TTL",
+	"PPE_DROP_CODE_EXP_IPV4_UNK_IP_PROT",
+	"PPE_DROP_CODE_EXP_IPV4_CHECKSUM_ERR",
+	"PPE_DROP_CODE_EXP_IPV4_INV_SIP",
+	"PPE_DROP_CODE_EXP_IPV4_INV_DIP",
+	"PPE_DROP_CODE_EXP_IPV4_LAND_ATTACK",
+	"PPE_DROP_CODE_EXP_IPV4_AH_HDR_INCOMPLETE",
+	"PPE_DROP_CODE_EXP_IPV4_AH_HDR_CROSS_BORDER",
+	"PPE_DROP_CODE_EXP_IPV4_ESP_HDR_INCOMPLETE",
+	"PPE_DROP_CODE_EXP_IPV6_WRONG_VER",
+	"PPE_DROP_CODE_EXP_IPV6_HDR_INCOMPLETE",
+	"PPE_DROP_CODE_EXP_IPV6_BAD_PAYLOAD_LEN",
+	"PPE_DROP_CODE_EXP_IPV6_DATA_INCOMPLETE",
+	"PPE_DROP_CODE_EXP_IPV6_WITH_EXT_HDR",
+	"PPE_DROP_CODE_EXP_IPV6_SMALL_HOP_LIMIT",
+	"PPE_DROP_CODE_EXP_IPV6_INV_SIP",
+	"PPE_DROP_CODE_EXP_IPV6_INV_DIP",
+	"PPE_DROP_CODE_EXP_IPV6_LAND_ATTACK",
+	"PPE_DROP_CODE_EXP_IPV6_FRAG",
+	"PPE_DROP_CODE_EXP_IPV6_PING_OF_DEATH",
+	"PPE_DROP_CODE_EXP_IPV6_WITH_MORE_EXT_HDR",
+	"PPE_DROP_CODE_EXP_IPV6_UNK_LAST_NEXT_HDR",
+	"PPE_DROP_CODE_EXP_IPV6_MOBILITY_HDR_INCOMPLETE",
+	"PPE_DROP_CODE_EXP_IPV6_MOBILITY_HDR_CROSS_BORDER",
+	"PPE_DROP_CODE_EXP_IPV6_AH_HDR_INCOMPLETE",
+	"PPE_DROP_CODE_EXP_IPV6_AH_HDR_CROSS_BORDER",
+	"PPE_DROP_CODE_EXP_IPV6_ESP_HDR_INCOMPLETE",
+	"PPE_DROP_CODE_EXP_IPV6_ESP_HDR_CROSS_BORDER",
+	"PPE_DROP_CODE_EXP_IPV6_OTHER_EXT_HDR_INCOMPLETE",
+	"PPE_DROP_CODE_EXP_IPV6_OTHER_EXT_HDR_CROSS_BORDER",
+	"PPE_DROP_CODE_EXP_TCP_HDR_INCOMPLETE",
+	"PPE_DROP_CODE_EXP_TCP_HDR_CROSS_BORDER",
+	"PPE_DROP_CODE_EXP_TCP_SMAE_SP_DP",
+	"PPE_DROP_CODE_EXP_TCP_SMALL_DATA_OFFSET",
+	"PPE_DROP_CODE_EXP_TCP_FLAGS_0",
+	"PPE_DROP_CODE_EXP_TCP_FLAGS_1",
+	"PPE_DROP_CODE_EXP_TCP_FLAGS_2",
+	"PPE_DROP_CODE_EXP_TCP_FLAGS_3",
+	"PPE_DROP_CODE_EXP_TCP_FLAGS_4",
+	"PPE_DROP_CODE_EXP_TCP_FLAGS_5",
+	"PPE_DROP_CODE_EXP_TCP_FLAGS_6",
+	"PPE_DROP_CODE_EXP_TCP_FLAGS_7",
+	"PPE_DROP_CODE_EXP_TCP_CHECKSUM_ERR",
+	"PPE_DROP_CODE_EXP_UDP_HDR_INCOMPLETE",
+	"PPE_DROP_CODE_EXP_UDP_HDR_CROSS_BORDER",
+	"PPE_DROP_CODE_EXP_UDP_SMAE_SP_DP",
+	"PPE_DROP_CODE_EXP_UDP_BAD_LEN",
+	"PPE_DROP_CODE_EXP_UDP_DATA_INCOMPLETE",
+	"PPE_DROP_CODE_EXP_UDP_CHECKSUM_ERR",
+	"PPE_DROP_CODE_EXP_UDP_LITE_HDR_INCOMPLETE",
+	"PPE_DROP_CODE_EXP_UDP_LITE_HDR_CROSS_BORDER",
+	"PPE_DROP_CODE_EXP_UDP_LITE_SMAE_SP_DP",
+	"PPE_DROP_CODE_EXP_UDP_LITE_CSM_COV_1_TO_7",
+	"PPE_DROP_CODE_EXP_UDP_LITE_CSM_COV_TOO_LONG",
+	"PPE_DROP_CODE_EXP_UDP_LITE_CSM_COV_CROSS_BORDER",
+	"PPE_DROP_CODE_EXP_UDP_LITE_CHECKSUM_ERR",
+	"PPE_DROP_CODE_L3_MC_BRIDGE_ACTION",
+	"PPE_DROP_CODE_L3_NO_ROUTE_PREHEAD_NAT_ACTION",
+	"PPE_DROP_CODE_L3_NO_ROUTE_PREHEAD_NAT_ERROR",
+	"PPE_DROP_CODE_L3_ROUTE_ACTION",
+	"PPE_DROP_CODE_L3_NO_ROUTE_ACTION",
+	"PPE_DROP_CODE_L3_NO_ROUTE_NH_INVALID_ACTION",
+	"PPE_DROP_CODE_L3_NO_ROUTE_PREHEAD_ACTION",
+	"PPE_DROP_CODE_L3_BRIDGE_ACTION",
+	"PPE_DROP_CODE_L3_FLOW_ACTION",
+	"PPE_DROP_CODE_L3_FLOW_MISS_ACTION",
+	"PPE_DROP_CODE_L2_EXP_MRU_FAIL",
+	"PPE_DROP_CODE_L2_EXP_MTU_FAIL",
+	"PPE_DROP_CODE_L3_EXP_IP_PREFIX_BC",
+	"PPE_DROP_CODE_L3_EXP_MTU_FAIL",
+	"PPE_DROP_CODE_L3_EXP_MRU_FAIL",
+	"PPE_DROP_CODE_L3_EXP_ICMP_RDT",
+	"PPE_DROP_CODE_FAKE_MAC_HEADER_ERR",
+	"PPE_DROP_CODE_L3_EXP_IP_RT_TTL_ZERO",
+	"PPE_DROP_CODE_L3_FLOW_SERVICE_CODE_LOOP",
+	"PPE_DROP_CODE_L3_FLOW_DE_ACCELEARTE",
+	"PPE_DROP_CODE_L3_EXP_FLOW_SRC_IF_CHK_FAIL",
+	"PPE_DROP_CODE_L3_FLOW_SYNC_TOGGLE_MISMATCH",
+	"PPE_DROP_CODE_L3_EXP_MTU_DF_FAIL",
+	"PPE_DROP_CODE_L3_EXP_PPPOE_MULTICAST",
+	"PPE_DROP_CODE_IPV4_SG_UNKNOWN",
+	"PPE_DROP_CODE_IPV6_SG_UNKNOWN",
+	"PPE_DROP_CODE_ARP_SG_UNKNOWN",
+	"PPE_DROP_CODE_ND_SG_UNKNOWN",
+	"PPE_DROP_CODE_IPV4_SG_VIO",
+	"PPE_DROP_CODE_IPV6_SG_VIO",
+	"PPE_DROP_CODE_ARP_SG_VIO",
+	"PPE_DROP_CODE_ND_SG_VIO",
+	"PPE_DROP_CODE_L2_NEW_MAC_ADDRESS",
+	"PPE_DROP_CODE_L2_HASH_COLLISION",
+	"PPE_DROP_CODE_L2_STATION_MOVE",
+	"PPE_DROP_CODE_L2_LEARN_LIMIT",
+	"PPE_DROP_CODE_L2_SA_LOOKUP_ACTION",
+	"PPE_DROP_CODE_L2_DA_LOOKUP_ACTION",
+	"PPE_DROP_CODE_APP_CTRL_ACTION",
+	"PPE_DROP_CODE_IN_VLAN_FILTER_ACTION",
+	"PPE_DROP_CODE_IN_VLAN_XLT_MISS",
+	"PPE_DROP_CODE_EG_VLAN_FILTER_DROP",
+	"PPE_DROP_CODE_ACL_PRE_ACTION",
+	"PPE_DROP_CODE_ACL_POST_ACTION",
+	"PPE_DROP_CODE_MC_BC_SA",
+	"PPE_DROP_CODE_NO_DESTINATION",
+	"PPE_DROP_CODE_STG_IN_FILTER",
+	"PPE_DROP_CODE_STG_EG_FILTER",
+	"PPE_DROP_CODE_SOURCE_FILTER_FAIL",
+	"PPE_DROP_CODE_TRUNK_SEL_FAIL",
+	"PPE_DROP_CODE_TX_EN_FAIL",
+	"PPE_DROP_CODE_VLAN_TAG_FMT",
+	"PPE_DROP_CODE_CRC_ERR",
+	"PPE_DROP_CODE_PAUSE_FRAME",
+	"PPE_DROP_CODE_PROMISC",
+	"PPE_DROP_CODE_ISOLATION",
+	"PPE_DROP_CODE_MGMT_APP",
+	"PPE_DROP_CODE_FAKE_L2_PROT_ERR",
+	"PPE_DROP_CODE_POLICER",
+};
+
+/*
+ * nss_ppe_stats_str_cc
+ *      PPE statistics strings for cpu code
+ */
+static int8_t *nss_ppe_stats_str_cc[NSS_PPE_STATS_CPU_CODE_MAX] = {
+	"PPE_CPU_CODE_FORWARDING",
+	"PPE_CPU_CODE_EXP_UNKNOWN_L2_PROT",
+	"PPE_CPU_CODE_EXP_PPPOE_WRONG_VER_TYPE",
+	"PPE_CPU_CODE_EXP_WRONG_CODE",
+	"PPE_CPU_CODE_EXP_PPPOE_UNSUPPORTED_PPP_PROT",
+	"PPE_CPU_CODE_EXP_WRONG_VER",
+	"PPE_CPU_CODE_EXP_SMALL_IHL",
+	"PPE_CPU_CODE_EXP_WITH_OPTION",
+	"PPE_CPU_CODE_EXP_HDR_INCOMPLETE",
+	"PPE_CPU_CODE_EXP_IPV4_BAD_TOTAL_LEN",
+	"PPE_CPU_CODE_EXP_DATA_INCOMPLETE",
+	"PPE_CPU_CODE_IPV4_FRAG",
+	"PPE_CPU_CODE_EXP_IPV4_PING_OF_DEATH",
+	"PPE_CPU_CODE_EXP_SNALL_TTL",
+	"PPE_CPU_CODE_EXP_IPV4_UNK_IP_PROT",
+	"PPE_CPU_CODE_EXP_CHECKSUM_ERR",
+	"PPE_CPU_CODE_EXP_INV_SIP",
+	"PPE_CPU_CODE_EXP_INV_DIP",
+	"PPE_CPU_CODE_EXP_LAND_ATTACK",
+	"PPE_CPU_CODE_EXP_IPV4_AH_HDR_INCOMPLETE",
+	"PPE_CPU_CODE_EXP_IPV4_AH_CROSS_BORDER",
+	"PPE_CPU_CODE_EXP_IPV4_ESP_HDR_INCOMPLETE",
+	"PPE_CPU_CODE_EXP_WRONG_VER",
+	"PPE_CPU_CODE_EXP_HDR_INCOMPLETE",
+	"PPE_CPU_CODE_EXP_IPV6_BAD_PAYLOAD_LEN",
+	"PPE_CPU_CODE_EXP_DATA_INCOMPLETE",
+	"PPE_CPU_CODE_EXP_IPV6_WITH_EXT_HDR",
+	"PPE_CPU_CODE_EXP_IPV6_SMALL_HOP_LIMIT",
+	"PPE_CPU_CODE_EXP_INV_SIP",
+	"PPE_CPU_CODE_EXP_INV_DIP",
+	"PPE_CPU_CODE_EXP_LAND_ATTACK",
+	"PPE_CPU_CODE_IPV6_FRAG",
+	"PPE_CPU_CODE_EXP_IPV6_PING_OF_DEATH",
+	"PPE_CPU_CODE_EXP_IPV6_WITH_EXT_HDR",
+	"PPE_CPU_CODE_EXP_IPV6_UNK_NEXT_HDR",
+	"PPE_CPU_CODE_EXP_IPV6_MOBILITY_HDR_INCOMPLETE",
+	"PPE_CPU_CODE_EXP_IPV6_MOBILITY_CROSS_BORDER",
+	"PPE_CPU_CODE_EXP_IPV6_AH_HDR_INCOMPLETE",
+	"PPE_CPU_CODE_EXP_IPV6_AH_CROSS_BORDER",
+	"PPE_CPU_CODE_EXP_IPV6_ESP_HDR_INCOMPLETE",
+	"PPE_CPU_CODE_EXP_IPV6_ESP_CROSS_BORDER",
+	"PPE_CPU_CODE_EXP_IPV6_OTHER_HDR_INCOMPLETE",
+	"PPE_CPU_CODE_EXP_IPV6_OTHER_EXT_CROSS_BORDER",
+	"PPE_CPU_CODE_EXP_HDR_INCOMPLETE",
+	"PPE_CPU_CODE_EXP_TCP_HDR_CROSS_BORDER",
+	"PPE_CPU_CODE_EXP_TCP_SMAE_SP_DP",
+	"PPE_CPU_CODE_EXP_TCP_SMALL_DATA_OFFSET",
+	"PPE_CPU_CODE_EXP_FLAGS_0",
+	"PPE_CPU_CODE_EXP_FLAGS_1",
+	"PPE_CPU_CODE_EXP_FLAGS_2",
+	"PPE_CPU_CODE_EXP_FLAGS_3",
+	"PPE_CPU_CODE_EXP_FLAGS_4",
+	"PPE_CPU_CODE_EXP_FLAGS_5",
+	"PPE_CPU_CODE_EXP_FLAGS_6",
+	"PPE_CPU_CODE_EXP_FLAGS_7",
+	"PPE_CPU_CODE_EXP_CHECKSUM_ERR",
+	"PPE_CPU_CODE_EXP_HDR_INCOMPLETE",
+	"PPE_CPU_CODE_EXP_UDP_HDR_CROSS_BORDER",
+	"PPE_CPU_CODE_EXP_UDP_SMAE_SP_DP",
+	"PPE_CPU_CODE_EXP_BAD_LEN",
+	"PPE_CPU_CODE_EXP_DATA_INCOMPLETE",
+	"PPE_CPU_CODE_EXP_CHECKSUM_ERR",
+	"PPE_CPU_CODE_EXP_UDP_LITE_HDR_INCOMPLETE",
+	"PPE_CPU_CODE_EXP_UDP_LITE_CROSS_BORDER",
+	"PPE_CPU_CODE_EXP_UDP_LITE_SP_DP",
+	"PPE_CPU_CODE_EXP_UDP_LITE_CSM_COV_TO_7",
+	"PPE_CPU_CODE_EXP_UDP_LITE_CSM_TOO_LONG",
+	"PPE_CPU_CODE_EXP_UDP_LITE_CSM_CROSS_BORDER",
+	"PPE_CPU_CODE_EXP_UDP_LITE_CHECKSUM_ERR",
+	"PPE_CPU_CODE_EXP_FAKE_L2_PROT_ERR",
+	"PPE_CPU_CODE_EXP_FAKE_MAC_HEADER_ERR",
+	"PPE_CPU_CODE_BITMAP_MAX",
+	"PPE_CPU_CODE_L2_MRU_FAIL",
+	"PPE_CPU_CODE_L2_MTU_FAIL",
+	"PPE_CPU_CODE_L3_EXP_IP_PREFIX_BC",
+	"PPE_CPU_CODE_L3_MTU_FAIL",
+	"PPE_CPU_CODE_L3_MRU_FAIL",
+	"PPE_CPU_CODE_L3_ICMP_RDT",
+	"PPE_CPU_CODE_L3_EXP_IP_RT_TO_ME",
+	"PPE_CPU_CODE_L3_EXP_IP_TTL_ZERO",
+	"PPE_CPU_CODE_L3_FLOW_SERVICE_CODE_LOOP",
+	"PPE_CPU_CODE_L3_DE_ACCELERATE",
+	"PPE_CPU_CODE_L3_EXP_FLOW_SRC_CHK_FAIL",
+	"PPE_CPU_CODE_L3_FLOW_SYNC_TOGGLE_MISMATCH",
+	"PPE_CPU_CODE_L3_EXP_MTU_DF_FAIL",
+	"PPE_CPU_CODE_L3_PPPOE_MULTICAST",
+	"PPE_CPU_CODE_MGMT_OFFSET",
+	"PPE_CPU_CODE_MGMT_EAPOL",
+	"PPE_CPU_CODE_PPPOE_DIS",
+	"PPE_CPU_CODE_MGMT_IGMP",
+	"PPE_CPU_CODE_ARP_REQ",
+	"PPE_CPU_CODE_ARP_REP",
+	"PPE_CPU_CODE_MGMT_DHCPv4",
+	"PPE_CPU_CODE_MGMT_MLD",
+	"PPE_CPU_CODE_MGMT_NS",
+	"PPE_CPU_CODE_MGMT_NA",
+	"PPE_CPU_CODE_MGMT_DHCPv6",
+	"PPE_CPU_CODE_PTP_OFFSET",
+	"PPE_CPU_CODE_PTP_SYNC",
+	"PPE_CPU_CODE_FOLLOW_UP",
+	"PPE_CPU_CODE_DELAY_REQ",
+	"PPE_CPU_CODE_DELAY_RESP",
+	"PPE_CPU_CODE_PDELAY_REQ",
+	"PPE_CPU_CODE_PDELAY_RESP",
+	"PPE_CPU_CODE_PTP_PDELAY_RESP_FOLLOW_UP",
+	"PPE_CPU_CODE_PTP_ANNOUNCE",
+	"PPE_CPU_CODE_PTP_MANAGEMENT",
+	"PPE_CPU_CODE_PTP_SIGNALING",
+	"PPE_CPU_CODE_PTP_RSV_MSG",
+	"PPE_CPU_CODE_SG_UNKNOWN",
+	"PPE_CPU_CODE_SG_UNKNOWN",
+	"PPE_CPU_CODE_SG_UNKNOWN",
+	"PPE_CPU_CODE_SG_UNKNOWN",
+	"PPE_CPU_CODE_SG_VIO",
+	"PPE_CPU_CODE_SG_VIO",
+	"PPE_CPU_CODE_SG_VIO",
+	"PPE_CPU_CODE_SG_VIO",
+	"PPE_CPU_CODE_L3_ROUTING_IP_TO_ME",
+	"PPE_CPU_CODE_L3_SNAT_ACTION",
+	"PPE_CPU_CODE_L3_DNAT_ACTION",
+	"PPE_CPU_CODE_L3_RT_ACTION",
+	"PPE_CPU_CODE_L3_BR_ACTION",
+	"PPE_CPU_CODE_L3_BRIDGE_ACTION",
+	"PPE_CPU_CODE_L3_ROUTE_PREHEAD_RT_ACTION",
+	"PPE_CPU_CODE_L3_ROUTE_PREHEAD_SNAPT_ACTION",
+	"PPE_CPU_CODE_L3_ROUTE_PREHEAD_DNAPT_ACTION",
+	"PPE_CPU_CODE_L3_ROUTE_PREHEAD_SNAT_ACTION",
+	"PPE_CPU_CODE_L3_ROUTE_PREHEAD_DNAT_ACTION",
+	"PPE_CPU_CODE_L3_NO_ROUTE_NAT_ACTION",
+	"PPE_CPU_CODE_L3_NO_ROUTE_NAT_ERROR",
+	"PPE_CPU_CODE_ROUTE_ACTION",
+	"PPE_CPU_CODE_L3_ROUTE_ACTION",
+	"PPE_CPU_CODE_L3_NO_ROUTE_INVALID_ACTION",
+	"PPE_CPU_CODE_L3_NO_ROUTE_PREHEAD_ACTION",
+	"PPE_CPU_CODE_BRIDGE_ACTION",
+	"PPE_CPU_CODE_FLOW_ACTION",
+	"PPE_CPU_CODE_L3_MISS_ACTION",
+	"PPE_CPU_CODE_L2_MAC_ADDRESS",
+	"PPE_CPU_CODE_HASH_COLLISION",
+	"PPE_CPU_CODE_STATION_MOVE",
+	"PPE_CPU_CODE_LEARN_LIMIT",
+	"PPE_CPU_CODE_L2_LOOKUP_ACTION",
+	"PPE_CPU_CODE_L2_LOOKUP_ACTION",
+	"PPE_CPU_CODE_CTRL_ACTION",
+	"PPE_CPU_CODE_IN_FILTER_ACTION",
+	"PPE_CPU_CODE_IN_XLT_MISS",
+	"PPE_CPU_CODE_EG_FILTER_DROP",
+	"PPE_CPU_CODE_PRE_ACTION",
+	"PPE_CPU_CODE_POST_ACTION",
+	"PPE_CPU_CODE_CODE_ACTION",
+};
+
+/*
+ * nss_ppe_stats_str_sc
+ *      PPE statistics strings for service-code stats
+ */
+static int8_t *nss_ppe_stats_str_sc[NSS_PPE_SC_MAX] = {
 	"SC_NONE           ",
 	"SC_BYPASS_ALL     ",
 	"SC_ADV_QOS_BRIDGED",
@@ -135,8 +490,8 @@ void nss_ppe_stats_sync(struct nss_ctx_i
 {
 	uint32_t sc;
 	spin_lock_bh(&nss_ppe_stats_lock);
-	nss_ppe_debug_stats.conn_stats[NSS_PPE_STATS_V4_L3_FLOWS] = stats_msg->stats.nss_ppe_v4_l3_flows;
-	nss_ppe_debug_stats.conn_stats[NSS_PPE_STATS_V4_L2_FLOWS] = stats_msg->stats.nss_ppe_v4_l2_flows;
+	nss_ppe_debug_stats.conn_stats[NSS_PPE_STATS_V4_L3_FLOWS] += stats_msg->stats.nss_ppe_v4_l3_flows;
+	nss_ppe_debug_stats.conn_stats[NSS_PPE_STATS_V4_L2_FLOWS] += stats_msg->stats.nss_ppe_v4_l2_flows;
 	nss_ppe_debug_stats.conn_stats[NSS_PPE_STATS_V4_CREATE_REQ] += stats_msg->stats.nss_ppe_v4_create_req;
 	nss_ppe_debug_stats.conn_stats[NSS_PPE_STATS_V4_CREATE_FAIL] += stats_msg->stats.nss_ppe_v4_create_fail;
 	nss_ppe_debug_stats.conn_stats[NSS_PPE_STATS_V4_DESTROY_REQ] += stats_msg->stats.nss_ppe_v4_destroy_req;
@@ -149,8 +504,8 @@ void nss_ppe_stats_sync(struct nss_ctx_i
 	nss_ppe_debug_stats.conn_stats[NSS_PPE_STATS_V4_MC_DESTROY_FAIL] += stats_msg->stats.nss_ppe_v4_mc_destroy_fail;
 	nss_ppe_debug_stats.conn_stats[NSS_PPE_STATS_V4_UNKNOWN_INTERFACE] += stats_msg->stats.nss_ppe_v4_unknown_interface;
 
-	nss_ppe_debug_stats.conn_stats[NSS_PPE_STATS_V6_L3_FLOWS] = stats_msg->stats.nss_ppe_v6_l3_flows;
-	nss_ppe_debug_stats.conn_stats[NSS_PPE_STATS_V6_L2_FLOWS] = stats_msg->stats.nss_ppe_v6_l2_flows;
+	nss_ppe_debug_stats.conn_stats[NSS_PPE_STATS_V6_L3_FLOWS] += stats_msg->stats.nss_ppe_v6_l3_flows;
+	nss_ppe_debug_stats.conn_stats[NSS_PPE_STATS_V6_L2_FLOWS] += stats_msg->stats.nss_ppe_v6_l2_flows;
 	nss_ppe_debug_stats.conn_stats[NSS_PPE_STATS_V6_CREATE_REQ] += stats_msg->stats.nss_ppe_v6_create_req;
 	nss_ppe_debug_stats.conn_stats[NSS_PPE_STATS_V6_CREATE_FAIL] += stats_msg->stats.nss_ppe_v6_create_fail;
 	nss_ppe_debug_stats.conn_stats[NSS_PPE_STATS_V6_DESTROY_REQ] += stats_msg->stats.nss_ppe_v6_destroy_req;
@@ -192,7 +547,7 @@ void nss_ppe_stats_sync(struct nss_ctx_i
  * nss_ppe_stats_conn_get()
  *	Get PPE connection statistics.
  */
-static void nss_ppe_stats_conn_get(uint64_t *stats)
+static void nss_ppe_stats_conn_get(uint32_t *stats)
 {
 	if (!stats) {
 		nss_warning("No memory to copy ppe connection stats");
@@ -203,7 +558,7 @@ static void nss_ppe_stats_conn_get(uint6
 	 * Get flow stats
 	 */
 	spin_lock_bh(&nss_ppe_stats_lock);
-	memcpy(stats, nss_ppe_debug_stats.conn_stats, (sizeof(uint64_t) * NSS_PPE_STATS_CONN_MAX));
+	memcpy(stats, nss_ppe_debug_stats.conn_stats, (sizeof(uint32_t) * NSS_PPE_STATS_CONN_MAX));
 	spin_unlock_bh(&nss_ppe_stats_lock);
 }
 
@@ -214,7 +569,7 @@ static void nss_ppe_stats_conn_get(uint6
 static void nss_ppe_stats_sc_get(struct nss_ppe_sc_stats_debug *sc_stats)
 {
 	if (!sc_stats) {
-		nss_warning("No memory to copy ppe service code stats");
+		nss_warning("No memory to copy ppe connection stats");
 		return;
 	}
 
@@ -370,9 +725,10 @@ static ssize_t nss_ppe_conn_stats_read(s
 	char *lbuf = NULL;
 	size_t size_wr = 0;
 	ssize_t bytes_read = 0;
-	uint64_t *stats_shadow;
-	uint64_t ppe_stats[NSS_PPE_STATS_CONN_MAX];
-	uint32_t max_output_lines = NSS_PPE_STATS_CONN_MAX + NSS_STATS_EXTRA_OUTPUT_LINES;
+	uint32_t ppe_stats[NSS_PPE_STATS_CONN_MAX];
+	uint32_t max_output_lines = 2 /* header & footer for session stats */
+				+ NSS_PPE_STATS_CONN_MAX /* PPE flow counters */
+				+ 2;
 	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
 
 	lbuf = kzalloc(size_al, GFP_KERNEL);
@@ -381,14 +737,7 @@ static ssize_t nss_ppe_conn_stats_read(s
 		return 0;
 	}
 
-	stats_shadow = kzalloc(NSS_PPE_STATS_CONN_MAX * 8, GFP_KERNEL);
-	if (unlikely(!stats_shadow)) {
-		nss_warning("Could not allocate memory for local shadow buffer");
-		kfree(lbuf);
-		return 0;
-	}
-
-	memset(ppe_stats, 0, sizeof(uint64_t) * NSS_PPE_STATS_CONN_MAX);
+	memset(ppe_stats, 0, sizeof(uint32_t) * NSS_PPE_STATS_CONN_MAX);
 
 	/*
 	 * Get all stats
@@ -398,19 +747,20 @@ static ssize_t nss_ppe_conn_stats_read(s
 	/*
 	 * flow stats
 	 */
-	spin_lock_bh(&nss_ppe_stats_lock);
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\nppe flow counters start:\n\n");
+
 	for (i = 0; i < NSS_PPE_STATS_CONN_MAX; i++) {
-		stats_shadow[i] = ppe_stats[i];
+		size_wr += scnprintf(lbuf + size_wr, size_al - size_wr,
+				"\t%s = %u\n", nss_ppe_stats_str_conn[i],
+				ppe_stats[i]);
 	}
 
-	spin_unlock_bh(&nss_ppe_stats_lock);
-	size_wr += nss_stats_print("ppe", "ppe flow counters", NSS_STATS_SINGLE_INSTANCE, nss_ppe_stats_str_conn, stats_shadow,
-					NSS_PPE_STATS_CONN_MAX, lbuf, size_wr, size_al);
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\n");
 
-	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\nppe flow counters end\n");
+	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, size_wr);
 
 	kfree(lbuf);
-	kfree(stats_shadow);
 	return bytes_read;
 }
 
@@ -425,7 +775,9 @@ static ssize_t nss_ppe_sc_stats_read(str
 	size_t size_wr = 0;
 	ssize_t bytes_read = 0;
 	struct nss_ppe_sc_stats_debug sc_stats[NSS_PPE_SC_MAX];
-	uint32_t max_output_lines = (NSS_PPE_SC_MAX * NSS_PPE_STATS_SERVICE_CODE_MAX) + NSS_STATS_EXTRA_OUTPUT_LINES;
+	uint32_t max_output_lines = 2 /* header & footer for sc stats */
+				+ NSS_PPE_SC_MAX /* PPE service-code counters */
+				+ 2;
 	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
 
 	lbuf = kzalloc(size_al, GFP_KERNEL);
@@ -444,16 +796,20 @@ static ssize_t nss_ppe_sc_stats_read(str
 	/*
 	 * service code stats
 	 */
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\nppe service code counters start:\n\n");
 
 	for (i = 0; i < NSS_PPE_SC_MAX; i++) {
-		size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "ppe service code type: %s\n",
-					nss_ppe_stats_str_sc_type[i]);
-		size_wr += nss_stats_print("ppe", "ppe service code counters", NSS_STATS_SINGLE_INSTANCE,
-						nss_ppe_stats_str_sc, &sc_stats[i].nss_ppe_sc_cb_unregister,
-						NSS_PPE_STATS_SERVICE_CODE_MAX, lbuf, size_wr, size_al);
+		size_wr += scnprintf(lbuf + size_wr, size_al - size_wr,
+				"\t%s \tcb_unregister:%llu    process_ok:%llu    process_fail:%llu\n",
+				nss_ppe_stats_str_sc[i], sc_stats[i].nss_ppe_sc_cb_unregister,
+				sc_stats[i].nss_ppe_sc_cb_success, sc_stats[i].nss_ppe_sc_cb_failure);
 	}
 
-	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\n");
+
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\nppe service code counters end\n");
+	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, size_wr);
+
 	kfree(lbuf);
 	return bytes_read;
 }
@@ -468,9 +824,10 @@ static ssize_t nss_ppe_l3_stats_read(str
 	char *lbuf = NULL;
 	size_t size_wr = 0;
 	ssize_t bytes_read = 0;
-	uint64_t *stats_shadow;
 	uint32_t ppe_stats[NSS_PPE_STATS_L3_MAX];
-	uint32_t max_output_lines = NSS_PPE_STATS_L3_MAX + NSS_STATS_EXTRA_OUTPUT_LINES;
+	uint32_t max_output_lines = 2 /* header & footer for session stats */
+				+ NSS_PPE_STATS_L3_MAX /* PPE flow counters */
+				+ 2;
 	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
 
 	lbuf = kzalloc(size_al, GFP_KERNEL);
@@ -479,13 +836,6 @@ static ssize_t nss_ppe_l3_stats_read(str
 		return 0;
 	}
 
-	stats_shadow = kzalloc(NSS_PPE_STATS_L3_MAX * 8, GFP_KERNEL);
-	if (unlikely(!stats_shadow)) {
-		nss_warning("Could not allocate memory for local shadow buffer");
-		kfree(lbuf);
-		return 0;
-	}
-
 	memset(ppe_stats, 0, sizeof(uint32_t) * NSS_PPE_STATS_L3_MAX);
 
 	/*
@@ -496,18 +846,20 @@ static ssize_t nss_ppe_l3_stats_read(str
 	/*
 	 * flow stats
 	 */
-	spin_lock_bh(&nss_ppe_stats_lock);
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\nppe l3 debug stats start:\n\n");
+
 	for (i = 0; i < NSS_PPE_STATS_L3_MAX; i++) {
-		stats_shadow[i] = ppe_stats[i];
+		size_wr += scnprintf(lbuf + size_wr, size_al - size_wr,
+				"\t%s = 0x%x\n", nss_ppe_stats_str_l3[i],
+				ppe_stats[i]);
 	}
 
-	spin_unlock_bh(&nss_ppe_stats_lock);
-	size_wr += nss_stats_print("ppe", "ppe l3 debug stats", NSS_STATS_SINGLE_INSTANCE, nss_ppe_stats_str_l3,
-					stats_shadow, NSS_PPE_STATS_L3_MAX, lbuf, size_wr, size_al);
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\n");
+
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\nppe l3 debug stats end\n");
+	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, size_wr);
 
-	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
 	kfree(lbuf);
-	kfree(stats_shadow);
 	return bytes_read;
 }
 
@@ -521,9 +873,10 @@ static ssize_t nss_ppe_code_stats_read(s
 	char *lbuf = NULL;
 	size_t size_wr = 0;
 	ssize_t bytes_read = 0;
-	uint64_t *stats_shadow;
 	uint32_t ppe_stats[NSS_PPE_STATS_CODE_MAX];
-	uint32_t max_output_lines = NSS_PPE_STATS_CODE_MAX + NSS_STATS_EXTRA_OUTPUT_LINES;
+	uint32_t max_output_lines = 2 /* header & footer for session stats */
+				+ NSS_PPE_STATS_CODE_MAX /* PPE flow counters */
+				+ 2;
 	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
 
 	lbuf = kzalloc(size_al, GFP_KERNEL);
@@ -532,13 +885,6 @@ static ssize_t nss_ppe_code_stats_read(s
 		return 0;
 	}
 
-	stats_shadow = kzalloc(NSS_PPE_STATS_CODE_MAX * 8, GFP_KERNEL);
-	if (unlikely(!stats_shadow)) {
-		nss_warning("Could not allocate memory for local shadow buffer");
-		kfree(lbuf);
-		return 0;
-	}
-
 	memset(ppe_stats, 0, sizeof(uint32_t) * NSS_PPE_STATS_CODE_MAX);
 
 	/*
@@ -549,19 +895,20 @@ static ssize_t nss_ppe_code_stats_read(s
 	/*
 	 * flow stats
 	 */
-	spin_lock_bh(&nss_ppe_stats_lock);
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\nppe session stats start:\n\n");
+
 	for (i = 0; i < NSS_PPE_STATS_CODE_MAX; i++) {
-		stats_shadow[i] = ppe_stats[i];
+		size_wr += scnprintf(lbuf + size_wr, size_al - size_wr,
+				"\t%s = %u\n", nss_ppe_stats_str_code[i],
+				ppe_stats[i]);
 	}
 
-	spin_unlock_bh(&nss_ppe_stats_lock);
-	size_wr += nss_stats_print("ppe", "ppe session stats", NSS_STATS_SINGLE_INSTANCE, nss_ppe_stats_str_code, stats_shadow,
-					NSS_PPE_STATS_CODE_MAX, lbuf, size_wr, size_al);
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\n");
 
-	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\nppe session stats end\n");
+	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, size_wr);
 
 	kfree(lbuf);
-	kfree(stats_shadow);
 	return bytes_read;
 }
 
@@ -574,13 +921,12 @@ static ssize_t nss_ppe_port_dc_stats_rea
 	int32_t i;
 
 	/*
-	 * max output lines = #stats + few blank lines for future reference to add new stats.
+	 * max output lines = #stats + 2 start tag line + 2 end tag line + five blank lines
 	 */
-	uint32_t max_output_lines = NSS_PPE_STATS_DROP_CODE_MAX + NSS_STATS_EXTRA_OUTPUT_LINES;
+	uint32_t max_output_lines = (NSS_PPE_STATS_DROP_CODE_MAX + 4) + 5;
 	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
 	size_t size_wr = 0;
 	ssize_t bytes_read = 0;
-	uint64_t *stats_shadow;
 	struct nss_stats_data *data = fp->private_data;
 	uint32_t *ppe_stats;
 
@@ -597,35 +943,38 @@ static ssize_t nss_ppe_port_dc_stats_rea
 		return 0;
 	}
 
-	stats_shadow = kzalloc((NSS_PPE_STATS_DROP_CODE_MAX) * 8, GFP_KERNEL);
-	if (unlikely(!stats_shadow)) {
-		nss_warning("Could not allocate memory for local shadow buffer");
-		kfree(lbuf);
-		kfree(ppe_stats);
-		return 0;
-	}
-
 	/*
 	 * Get drop code counters for specific port
 	 */
 	nss_ppe_port_drop_code_get(ppe_stats, data->edma_id);
+	size_wr = scnprintf(lbuf, size_al, "ppe no drop code stats start:\n\n");
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr,
+				"\t%s = %u\n", nss_ppe_stats_str_dc[0],
+				ppe_stats[0]);
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\nppe no drop code stats end\n\n");
 
 	/*
 	 * Drop code stats
 	 */
-	spin_lock_bh(&nss_ppe_stats_lock);
-	for (i = 0; i < NSS_PPE_STATS_DROP_CODE_MAX; i++) {
-		stats_shadow[i] = ppe_stats[i];
-	}
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "ppe non-zero drop code stats start:\n\n");
+	for (i = 1; i < NSS_PPE_STATS_DROP_CODE_MAX; i++) {
+		/*
+		 * Print only non-zero stats.
+		 */
+		if (!ppe_stats[i]) {
+			continue;
+		}
 
-	spin_unlock_bh(&nss_ppe_stats_lock);
-	size_wr += nss_stats_print("ppe", "ppe drop code stats", NSS_STATS_SINGLE_INSTANCE, nss_ppe_stats_str_dc,
-					stats_shadow, NSS_PPE_STATS_DROP_CODE_MAX, lbuf, size_wr, size_al);
+		size_wr += scnprintf(lbuf + size_wr, size_al - size_wr,
+				"\t%s = %u\n", nss_ppe_stats_str_dc[i],
+				ppe_stats[i]);
+	}
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\nppe non-zero drop code stats end\n\n");
 
 	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
 	kfree(ppe_stats);
 	kfree(lbuf);
-	kfree(stats_shadow);
+
 	return bytes_read;
 }
 
@@ -638,13 +987,12 @@ static ssize_t nss_ppe_exception_cc_stat
 	int32_t i;
 
 	/*
-	 * max output lines = #stats + few blank lines for future reference to add new stats.
+	 * max output lines = #stats + start tag line + end tag line + three blank lines
 	 */
-	uint32_t max_output_lines = NSS_PPE_STATS_CPU_CODE_EXCEPTION_MAX + NSS_STATS_EXTRA_OUTPUT_LINES;
+	uint32_t max_output_lines = (NSS_PPE_STATS_CPU_CODE_EXCEPTION_MAX + 2) + 3;
 	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
 	size_t size_wr = 0;
 	ssize_t bytes_read = 0;
-	uint64_t *stats_shadow;
 	uint32_t *ppe_stats;
 
 	char *lbuf = kzalloc(size_al, GFP_KERNEL);
@@ -660,36 +1008,34 @@ static ssize_t nss_ppe_exception_cc_stat
 		return 0;
 	}
 
-	stats_shadow = kzalloc(NSS_PPE_STATS_CPU_CODE_EXCEPTION_MAX * 8, GFP_KERNEL);
-	if (unlikely(!stats_shadow)) {
-		nss_warning("Could not allocate memory for local shadow buffer");
-		kfree(lbuf);
-		kfree(ppe_stats);
-		return 0;
-	}
-
 	/*
 	 * Get CPU code counters for flow specific exceptions
 	 */
 	nss_ppe_cpu_code_exception_get(ppe_stats);
 
+	size_wr = scnprintf(lbuf, size_al, "ppe non-zero cpu code flow-exception stats start:\n\n");
+
 	/*
 	 * CPU code stats
 	 */
-	spin_lock_bh(&nss_ppe_stats_lock);
 	for (i = 0; i < NSS_PPE_STATS_CPU_CODE_EXCEPTION_MAX; i++) {
-		stats_shadow[i] = ppe_stats[i];
-	}
+		/*
+		 * Print only non-zero stats.
+		 */
+		if (!ppe_stats[i]) {
+			continue;
+		}
 
-	spin_unlock_bh(&nss_ppe_stats_lock);
-	size_wr += nss_stats_print("ppe", "ppe cpu code flow-exception stats", NSS_STATS_SINGLE_INSTANCE,
-					nss_ppe_stats_str_cc, stats_shadow, NSS_PPE_STATS_CPU_CODE_EXCEPTION_MAX,
-					lbuf, size_wr, size_al);
+		size_wr += scnprintf(lbuf + size_wr, size_al - size_wr,
+				"\t%s = %u\n", nss_ppe_stats_str_cc[i],
+				ppe_stats[i]);
+	}
 
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\nppe non-zero cpu code flow-exception stats end\n\n");
 	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
 	kfree(ppe_stats);
 	kfree(lbuf);
-	kfree(stats_shadow);
+
 	return bytes_read;
 }
 
@@ -702,13 +1048,12 @@ static ssize_t nss_ppe_nonexception_cc_s
 	int32_t i;
 
 	/*
-	 * max output lines = #stats + few blank lines for future reference to add new stats.
+	 * max output lines = #stats + start tag line + end tag line + three blank lines
 	 */
-	uint32_t max_output_lines = NSS_PPE_STATS_CPU_CODE_NONEXCEPTION_MAX + NSS_STATS_EXTRA_OUTPUT_LINES;
+	uint32_t max_output_lines = (NSS_PPE_STATS_CPU_CODE_NONEXCEPTION_MAX + 2) + 3;
 	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
 	size_t size_wr = 0;
 	ssize_t bytes_read = 0;
-	uint64_t *stats_shadow;
 	uint32_t *ppe_stats;
 
 	char *lbuf = kzalloc(size_al, GFP_KERNEL);
@@ -724,14 +1069,6 @@ static ssize_t nss_ppe_nonexception_cc_s
 		return 0;
 	}
 
-	stats_shadow = kzalloc(NSS_PPE_STATS_CPU_CODE_NONEXCEPTION_MAX * 8, GFP_KERNEL);
-	if (unlikely(!stats_shadow)) {
-		nss_warning("Could not allocate memory for local shadow buffer");
-		kfree(lbuf);
-		kfree(ppe_stats);
-		return 0;
-	}
-
 	/*
 	 * Get CPU code counters for non flow exceptions
 	 */
@@ -740,20 +1077,23 @@ static ssize_t nss_ppe_nonexception_cc_s
 	/*
 	 * CPU code stats
 	 */
-
-	spin_lock_bh(&nss_ppe_stats_lock);
+	size_wr = scnprintf(lbuf, size_al, "ppe non-zero cpu code non-flow exception stats start:\n\n");
 	for (i = 0; i < NSS_PPE_STATS_CPU_CODE_NONEXCEPTION_MAX; i++) {
-		stats_shadow[i] = ppe_stats[i];
-	}
+		/*
+		 * Print only non-zero stats.
+		 */
+		if (!ppe_stats[i]) {
+			continue;
+		}
 
-	spin_unlock_bh(&nss_ppe_stats_lock);
-	size_wr += nss_stats_print("ppe", "ppe cpu code non-flow exception stats", NSS_STATS_SINGLE_INSTANCE,
-					&nss_ppe_stats_str_cc[NSS_PPE_STATS_CPU_CODE_NONEXCEPTION_START],
-					stats_shadow, NSS_PPE_STATS_CPU_CODE_NONEXCEPTION_MAX, lbuf, size_wr, size_al);
+		size_wr += scnprintf(lbuf + size_wr, size_al - size_wr,
+				"\t%s = %u\n", nss_ppe_stats_str_cc[i + NSS_PPE_STATS_CPU_CODE_NONEXCEPTION_START],
+				ppe_stats[i]);
+	}
 
+	size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\nppe non-zero cpu code non-flow exception stats end\n\n");
 	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
 	kfree(ppe_stats);
-	kfree(stats_shadow);
 	kfree(lbuf);
 
 	return bytes_read;
@@ -801,38 +1141,49 @@ void nss_ppe_stats_dentry_create(void)
 {
 	int i;
 	struct dentry *ppe_dentry = NULL;
+	struct dentry *ppe_conn_d = NULL;
+	struct dentry *ppe_sc_d = NULL;
+	struct dentry *ppe_l3_d = NULL;
+	struct dentry *ppe_ppe_code_d = NULL;
 	struct dentry *ppe_code_d = NULL;
 	struct dentry *ppe_drop_d = NULL;
+	struct dentry *ppe_port_dc_d = NULL;
 	struct dentry *ppe_cpu_d = NULL;
+	struct dentry *ppe_exception_d = NULL;
+	struct dentry *ppe_nonexception_d = NULL;
 	char file_name[10];
 
 	ppe_dentry = debugfs_create_dir("ppe", nss_top_main.stats_dentry);
-	if (!ppe_dentry) {
+	if (unlikely(ppe_dentry == NULL)) {
 		nss_warning("Failed to create qca-nss-drv/stats/ppe directory");
 		return;
 	}
 
-	if (!debugfs_create_file("connection", 0400, ppe_dentry, &nss_top_main, &nss_ppe_conn_stats_ops)) {
+	ppe_conn_d = debugfs_create_file("connection", 0400, ppe_dentry,
+					&nss_top_main, &nss_ppe_conn_stats_ops);
+	if (unlikely(ppe_conn_d == NULL)) {
 		nss_warning("Failed to create qca-nss-drv/stats/ppe/connection file");
-		debugfs_remove_recursive(ppe_dentry);
 		return;
 	}
 
-	if (!debugfs_create_file("sc_stats", 0400, ppe_dentry, &nss_top_main, &nss_ppe_sc_stats_ops)) {
+	ppe_sc_d = debugfs_create_file("sc_stats", 0400, ppe_dentry,
+					&nss_top_main, &nss_ppe_sc_stats_ops);
+	if (unlikely(ppe_sc_d == NULL)) {
 		nss_warning("Failed to create qca-nss-drv/stats/ppe/sc_stats file");
-		debugfs_remove_recursive(ppe_dentry);
 		return;
 	}
 
-	if (!debugfs_create_file("l3", 0400, ppe_dentry, &nss_top_main, &nss_ppe_l3_stats_ops)) {
-		nss_warning("Failed to create qca-nss-drv/stats/ppe/l3 file");
-		debugfs_remove_recursive(ppe_dentry);
+	ppe_l3_d = debugfs_create_file("l3", 0400, ppe_dentry,
+					&nss_top_main, &nss_ppe_l3_stats_ops);
+	if (unlikely(ppe_l3_d == NULL)) {
+		nss_warning("Failed to create qca-nss-drv/stats/ppe/l3 filed");
 		return;
 	}
 
-	if (!debugfs_create_file("ppe_code", 0400, ppe_dentry, &nss_top_main, &nss_ppe_code_stats_ops)) {
+	ppe_ppe_code_d = debugfs_create_file("ppe_code", 0400, ppe_dentry,
+						&nss_top_main, &nss_ppe_code_stats_ops);
+	if (unlikely(ppe_ppe_code_d == NULL)) {
 		nss_warning("Failed to create qca-nss-drv/stats/ppe/ppe_code file");
-		debugfs_remove_recursive(ppe_dentry);
 		return;
 	}
 
@@ -840,31 +1191,33 @@ void nss_ppe_stats_dentry_create(void)
 	 * ppe exception and drop code stats
 	 */
 	ppe_code_d = debugfs_create_dir("code", ppe_dentry);
-	if (!ppe_code_d) {
+	if (unlikely(ppe_code_d == NULL)) {
 		nss_warning("Failed to create qca-nss-drv/stats/ppe/code directory");
 		return;
 	}
 
 	ppe_cpu_d = debugfs_create_dir("cpu", ppe_code_d);
-	if (!ppe_cpu_d) {
+	if (unlikely(ppe_cpu_d == NULL)) {
 		nss_warning("Failed to create qca-nss-drv/stats/ppe/code/cpu directory");
 		return;
 	}
 
-	if (!debugfs_create_file("exception", 0400, ppe_cpu_d, &nss_top_main, &nss_ppe_exception_cc_stats_ops)) {
+	ppe_exception_d = debugfs_create_file("exception", 0400, ppe_cpu_d,
+					&nss_top_main, &nss_ppe_exception_cc_stats_ops);
+	if (unlikely(ppe_exception_d == NULL)) {
 		nss_warning("Failed to create qca-nss-drv/stats/ppe/code/exception file");
-		debugfs_remove_recursive(ppe_cpu_d);
 		return;
 	}
 
-	if (!debugfs_create_file("non-exception", 0400, ppe_cpu_d, &nss_top_main, &nss_ppe_nonexception_cc_stats_ops)) {
+	ppe_nonexception_d = debugfs_create_file("non-exception", 0400, ppe_cpu_d,
+					&nss_top_main, &nss_ppe_nonexception_cc_stats_ops);
+	if (unlikely(ppe_nonexception_d == NULL)) {
 		nss_warning("Failed to create qca-nss-drv/stats/ppe/code/non-exception file");
-		debugfs_remove_recursive(ppe_cpu_d);
 		return;
 	}
 
 	ppe_drop_d = debugfs_create_dir("drop", ppe_code_d);
-	if (!ppe_drop_d) {
+	if (unlikely(ppe_drop_d == NULL)) {
 		nss_warning("Failed to create qca-nss-drv/stats/ppe/code/drop directory");
 		return;
 	}
@@ -875,51 +1228,11 @@ void nss_ppe_stats_dentry_create(void)
 			snprintf(file_name, sizeof(file_name), "%d", i);
 		}
 
-		if (!debugfs_create_file((i == 0) ? "cpu" : file_name, 0400, ppe_drop_d,
-			(void *)(nss_ptr_t)i, &nss_ppe_port_dc_stats_ops)) {
+		ppe_port_dc_d = debugfs_create_file((i == 0) ? "cpu" : file_name, 0400, ppe_drop_d,
+					(void *)(nss_ptr_t)i, &nss_ppe_port_dc_stats_ops);
+		if (unlikely(ppe_port_dc_d == NULL)) {
 			nss_warning("Failed to create qca-nss-drv/stats/ppe/code/drop/%d file", i);
-			debugfs_remove_recursive(ppe_drop_d);
 			return;
 		}
 	}
 }
-
-/*
- * nss_ppe_stats_notify()
- *	Sends notifications to all the registered modules.
- *
- * Leverage NSS-FW statistics timing to update Netlink.
- */
-void nss_ppe_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num)
-{
-	struct nss_ppe_stats_notification ppe_stats;
-
-	spin_lock_bh(&nss_ppe_stats_lock);
-	ppe_stats.core_id = nss_ctx->id;
-	ppe_stats.if_num = if_num;
-	memcpy(ppe_stats.ppe_stats_conn, nss_ppe_debug_stats.conn_stats, sizeof(ppe_stats.ppe_stats_conn));
-	memcpy(ppe_stats.ppe_stats_sc, nss_ppe_debug_stats.sc_stats, sizeof(ppe_stats.ppe_stats_sc));
-	spin_unlock_bh(&nss_ppe_stats_lock);
-
-	atomic_notifier_call_chain(&nss_ppe_stats_notifier, NSS_STATS_EVENT_NOTIFY, &ppe_stats);
-}
-
-/*
- * nss_ppe_stats_unregister_notifier()
- *	Deregisters statistics notifier.
- */
-int nss_ppe_stats_unregister_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_unregister(&nss_ppe_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_ppe_stats_unregister_notifier);
-
-/*
- * nss_ppe_stats_register_notifier()
- *	Registers statistics notifier.
- */
-int nss_ppe_stats_register_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_register(&nss_ppe_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_ppe_stats_register_notifier);
--- a/nss_ppe_stats.h
+++ b/nss_ppe_stats.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017-2018, 2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -22,8 +22,6 @@
 #ifndef __NSS_PPE_STATS_H
 #define __NSS_PPE_STATS_H
 
-#include <nss_cmn.h>
-
 /*
  * NSS PPE connection statistics
  */
@@ -72,16 +70,6 @@ enum nss_ppe_stats_conn {
 };
 
 /*
- * NSS PPE SC statistics
- */
-enum nss_ppe_stats_service_code {
-	NSS_PPE_STATS_SERVICE_CODE_CB_UNREGISTER,
-	NSS_PPE_STATS_SERVICE_CODE_PROCESS_OK,
-	NSS_PPE_STATS_SERVICE_CODE_PROCESS_FAIL,
-	NSS_PPE_STATS_SERVICE_CODE_MAX
-};
-
-/*
  * NSS PPE L3 statistics
  */
 enum nss_ppe_stats_l3 {
@@ -412,7 +400,7 @@ struct nss_ppe_sc_stats_debug {
  * NSS PPE statistics
  */
 struct nss_ppe_stats_debug {
-	uint64_t conn_stats[NSS_PPE_STATS_CONN_MAX];
+	uint32_t conn_stats[NSS_PPE_STATS_CONN_MAX];
 	uint32_t l3_stats[NSS_PPE_STATS_L3_MAX];
 	uint32_t code_stats[NSS_PPE_STATS_CODE_MAX];
 	struct nss_ppe_sc_stats_debug sc_stats[NSS_PPE_SC_MAX];
@@ -426,21 +414,9 @@ struct nss_ppe_stats_debug {
  */
 extern struct nss_ppe_stats_debug nss_ppe_debug_stats;
 
-/**
- * nss_ppe_stats_notification
- *	PPE transmission statistics structure.
- */
-struct nss_ppe_stats_notification {
-	struct nss_ppe_sc_stats_debug ppe_stats_sc[NSS_PPE_SC_MAX];	/* PPE service code stats. */
-	uint64_t ppe_stats_conn[NSS_PPE_STATS_CONN_MAX];		/* PPE connection statistics. */
-	uint32_t core_id;						/* Core ID. */
-	uint32_t if_num;						/* Interface number. */
-};
-
 /*
  * NSS PPE statistics APIs
  */
-extern void nss_ppe_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num);
 extern void nss_ppe_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_ppe_sync_stats_msg *stats_msg, uint16_t if_num);
 extern void nss_ppe_stats_dentry_create(void);
 
--- a/nss_ppe_strings.c
+++ /dev/null
@@ -1,532 +0,0 @@
-/*
- ***************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ***************************************************************************
- */
-
-#include "nss_stats.h"
-#include "nss_core.h"
-#include "nss_ppe.h"
-#include "nss_strings.h"
-#include "nss_ppe_strings.h"
-
-/*
- * nss_ppe_stats_str_conn
- *	PPE statistics strings for nss flow stats
- */
-struct nss_stats_info nss_ppe_stats_str_conn[NSS_PPE_STATS_CONN_MAX] = {
-	{"v4 routed flows",			NSS_STATS_TYPE_SPECIAL},
-	{"v4 bridge flows",			NSS_STATS_TYPE_SPECIAL},
-	{"v4 conn create req",			NSS_STATS_TYPE_SPECIAL},
-	{"v4 conn create fail",			NSS_STATS_TYPE_SPECIAL},
-	{"v4 conn destroy req",			NSS_STATS_TYPE_SPECIAL},
-	{"v4 conn destroy fail",		NSS_STATS_TYPE_SPECIAL},
-	{"v4 conn MC create req",		NSS_STATS_TYPE_SPECIAL},
-	{"v4 conn MC create fail",		NSS_STATS_TYPE_SPECIAL},
-	{"v4 conn MC update req",		NSS_STATS_TYPE_SPECIAL},
-	{"v4 conn MC update fail",		NSS_STATS_TYPE_SPECIAL},
-	{"v4 conn MC delete req",		NSS_STATS_TYPE_SPECIAL},
-	{"v4 conn MC delete fail",		NSS_STATS_TYPE_SPECIAL},
-	{"v4 conn unknown if",			NSS_STATS_TYPE_SPECIAL},
-	{"v6 routed flows",			NSS_STATS_TYPE_SPECIAL},
-	{"v6 bridge flows",			NSS_STATS_TYPE_SPECIAL},
-	{"v6 conn create req",			NSS_STATS_TYPE_SPECIAL},
-	{"v6 conn create fail",			NSS_STATS_TYPE_SPECIAL},
-	{"v6 conn destroy req",			NSS_STATS_TYPE_SPECIAL},
-	{"v6 conn destroy fail",		NSS_STATS_TYPE_SPECIAL},
-	{"v6 conn MC create req",		NSS_STATS_TYPE_SPECIAL},
-	{"v6 conn MC create fail",		NSS_STATS_TYPE_SPECIAL},
-	{"v6 conn MC update req",		NSS_STATS_TYPE_SPECIAL},
-	{"v6 conn MC update fail",		NSS_STATS_TYPE_SPECIAL},
-	{"v6 conn MC delete req",		NSS_STATS_TYPE_SPECIAL},
-	{"v6 conn MC delete fail",		NSS_STATS_TYPE_SPECIAL},
-	{"v6 conn unknown if",			NSS_STATS_TYPE_SPECIAL},
-	{"conn fail - vp full",			NSS_STATS_TYPE_SPECIAL},
-	{"conn fail - nexthop full",		NSS_STATS_TYPE_SPECIAL},
-	{"conn fail - flow full",		NSS_STATS_TYPE_SPECIAL},
-	{"conn fail - host full",		NSS_STATS_TYPE_SPECIAL},
-	{"conn fail - pub-ip full",		NSS_STATS_TYPE_SPECIAL},
-	{"conn fail - port not setup",		NSS_STATS_TYPE_SPECIAL},
-	{"conn fail - rw fifo full",		NSS_STATS_TYPE_SPECIAL},
-	{"conn fail - flow cmd failure",	NSS_STATS_TYPE_SPECIAL},
-	{"conn fail - unknown proto",		NSS_STATS_TYPE_SPECIAL},
-	{"conn fail - ppe not responding",	NSS_STATS_TYPE_SPECIAL},
-	{"conn fail - CE opaque invalid",	NSS_STATS_TYPE_SPECIAL},
-	{"conn fail - fqg full",		NSS_STATS_TYPE_SPECIAL}
-};
-
-/*
- * nss_ppe_stats_str_conn_strings_read()
- *	Read ppe NSS flow statistics names
- */
-static ssize_t nss_ppe_stats_str_conn_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_ppe_stats_str_conn, NSS_PPE_STATS_CONN_MAX);
-}
-
-/*
- * nss_ppe_stats_str_conn_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(ppe_stats_str_conn);
-
-/*
- * nss_ppe_stats_str_l3
- *	PPE statistics strings for nss debug stats
- */
-struct nss_stats_info nss_ppe_stats_str_l3[NSS_PPE_STATS_L3_MAX] = {
-	{"L3 dbg reg 0",	NSS_STATS_TYPE_SPECIAL},
-	{"L3 dbg reg 1",	NSS_STATS_TYPE_SPECIAL},
-	{"L3 dbg reg 2",	NSS_STATS_TYPE_SPECIAL},
-	{"L3 dbg reg 3",	NSS_STATS_TYPE_SPECIAL},
-	{"L3 dbg reg 4",	NSS_STATS_TYPE_SPECIAL},
-	{"L3 dbg reg port",	NSS_STATS_TYPE_SPECIAL}
-};
-
-/*
- * nss_ppe_stats_str_l3_strings_read()
- *	Read ppe NSS debug statistics names
- */
-static ssize_t nss_ppe_stats_str_l3_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_ppe_stats_str_l3, NSS_PPE_STATS_L3_MAX);
-}
-
-/*
- * nss_ppe_stats_str_l3_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(ppe_stats_str_l3);
-
-/*
- * nss_ppe_stats_str_code
- *	PPE statistics strings for nss debug stats
- */
-struct nss_stats_info nss_ppe_stats_str_code[NSS_PPE_STATS_CODE_MAX] = {
-	{"CPU_CODE",	NSS_STATS_TYPE_SPECIAL},
-	{"DROP_CODE",	NSS_STATS_TYPE_SPECIAL}
-};
-
-/*
- * nss_ppe_stats_str_code_strings_read()
- *	Read ppe NSS debug statistics names
- */
-static ssize_t nss_ppe_stats_str_code_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_ppe_stats_str_code, NSS_PPE_STATS_CODE_MAX);
-}
-
-/*
- * nss_ppe_stats_str_code_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(ppe_stats_str_code);
-
-/*
- * nss_ppe_stats_str_dc
- *	PPE statistics strings for drop code
- */
-struct nss_stats_info nss_ppe_stats_str_dc[NSS_PPE_STATS_DROP_CODE_MAX] = {
-	{"DROP_CODE_NONE",					NSS_STATS_TYPE_SPECIAL},
-	{"DROP_CODE_EXP_UNKNOWN_L2_PORT",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_PPPOE_WRONG_VER_TYPE",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_PPPOE_WRONG_CODE",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_PPPOE_UNSUPPORTED_PPP_PROT",		NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV4_WRONG_VER",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV4_SMALL_IHL",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV4_WITH_OPTION",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV4_HDR_INCOMPLETE",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV4_BAD_TOTAL_LEN",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV4_DATA_INCOMPLETE",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV4_FRAG",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV4_PING_OF_DEATH",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV4_SNALL_TTL",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV4_UNK_IP_PROT",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV4_CHECKSUM_ERR",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV4_INV_SIP",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV4_INV_DIP",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV4_LAND_ATTACK",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV4_AH_HDR_INCOMPLETE",		NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV4_AH_HDR_CROSS_BORDER",		NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV4_ESP_HDR_INCOMPLETE",		NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV6_WRONG_VER",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV6_HDR_INCOMPLETE",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV6_BAD_PAYLOAD_LEN",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV6_DATA_INCOMPLETE",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV6_WITH_EXT_HDR",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV6_SMALL_HOP_LIMIT",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV6_INV_SIP",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV6_INV_DIP",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV6_LAND_ATTACK",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV6_FRAG",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV6_PING_OF_DEATH",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV6_WITH_MORE_EXT_HDR",		NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV6_UNK_LAST_NEXT_HDR",		NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV6_MOBILITY_HDR_INCOMPLETE",		NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV6_MOBILITY_HDR_CROSS_BORDER",	NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV6_AH_HDR_INCOMPLETE",		NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV6_AH_HDR_CROSS_BORDER",		NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV6_ESP_HDR_INCOMPLETE",		NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV6_ESP_HDR_CROSS_BORDER",		NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV6_OTHER_EXT_HDR_INCOMPLETE",		NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_IPV6_OTHER_EXT_HDR_CROSS_BORDER",	NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_TCP_HDR_INCOMPLETE",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_TCP_HDR_CROSS_BORDER",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_TCP_SMAE_SP_DP",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_TCP_SMALL_DATA_OFFSET",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_TCP_FLAGS_0",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_TCP_FLAGS_1",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_TCP_FLAGS_2",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_TCP_FLAGS_3",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_TCP_FLAGS_4",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_TCP_FLAGS_5",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_TCP_FLAGS_6",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_TCP_FLAGS_7",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_TCP_CHECKSUM_ERR",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_UDP_HDR_INCOMPLETE",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_UDP_HDR_CROSS_BORDER",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_UDP_SMAE_SP_DP",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_UDP_BAD_LEN",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_UDP_DATA_INCOMPLETE",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_UDP_CHECKSUM_ERR",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_UDP_LITE_HDR_INCOMPLETE",		NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_UDP_LITE_HDR_CROSS_BORDER",		NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_UDP_LITE_SMAE_SP_DP",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_UDP_LITE_CSM_COV_1_TO_7",		NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_UDP_LITE_CSM_COV_TOO_LONG",		NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_UDP_LITE_CSM_COV_CROSS_BORDER",		NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EXP_UDP_LITE_CHECKSUM_ERR",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L3_MC_BRIDGE_ACTION",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L3_NO_ROUTE_PREHEAD_NAT_ACTION",		NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L3_NO_ROUTE_PREHEAD_NAT_ERROR",		NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L3_ROUTE_ACTION",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L3_NO_ROUTE_ACTION",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L3_NO_ROUTE_NH_INVALID_ACTION",		NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L3_NO_ROUTE_PREHEAD_ACTION",		NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L3_BRIDGE_ACTION",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L3_FLOW_ACTION",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L3_FLOW_MISS_ACTION",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L2_EXP_MRU_FAIL",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L2_EXP_MTU_FAIL",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L3_EXP_IP_PREFIX_BC",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L3_EXP_MTU_FAIL",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L3_EXP_MRU_FAIL",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L3_EXP_ICMP_RDT",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_FAKE_MAC_HEADER_ERR",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L3_EXP_IP_RT_TTL_ZERO",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L3_FLOW_SERVICE_CODE_LOOP",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L3_FLOW_DE_ACCELEARTE",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L3_EXP_FLOW_SRC_IF_CHK_FAIL",		NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L3_FLOW_SYNC_TOGGLE_MISMATCH",		NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L3_EXP_MTU_DF_FAIL",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L3_EXP_PPPOE_MULTICAST",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_IPV4_SG_UNKNOWN",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_IPV6_SG_UNKNOWN",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_ARP_SG_UNKNOWN",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_ND_SG_UNKNOWN",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_IPV4_SG_VIO",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_IPV6_SG_VIO",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_ARP_SG_VIO",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_ND_SG_VIO",					NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L2_NEW_MAC_ADDRESS",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L2_HASH_COLLISION",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L2_STATION_MOVE",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L2_LEARN_LIMIT",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L2_SA_LOOKUP_ACTION",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_L2_DA_LOOKUP_ACTION",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_APP_CTRL_ACTION",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_IN_VLAN_FILTER_ACTION",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_IN_VLAN_XLT_MISS",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_EG_VLAN_FILTER_DROP",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_ACL_PRE_ACTION",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_ACL_POST_ACTION",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_MC_BC_SA",					NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_NO_DESTINATION",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_STG_IN_FILTER",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_STG_EG_FILTER",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_SOURCE_FILTER_FAIL",			NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_TRUNK_SEL_FAIL",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_TX_EN_FAIL",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_VLAN_TAG_FMT",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_CRC_ERR",					NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_PAUSE_FRAME",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_PROMISC",					NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_ISOLATION",					NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_MGMT_APP",					NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_FAKE_L2_PROT_ERR",				NSS_STATS_TYPE_DROP},
-	{"DROP_CODE_POLICER",					NSS_STATS_TYPE_DROP}
-};
-
-/*
- * nss_ppe_stats_str_dc_strings_read()
- *	Read ppe drop code statistics names
- */
-static ssize_t nss_ppe_stats_str_dc_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_ppe_stats_str_dc, NSS_PPE_STATS_DROP_CODE_MAX);
-}
-
-/*
- * nss_ppe_stats_str_dc_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(ppe_stats_str_dc);
-
-/*
- * nss_ppe_stats_str_sc
- *	PPE statistics strings for service-code stats
- */
-struct nss_stats_info nss_ppe_stats_str_sc[NSS_PPE_STATS_SERVICE_CODE_MAX] = {
-	{"cb_unregister",	NSS_STATS_TYPE_SPECIAL},
-	{"process_ok",		NSS_STATS_TYPE_SPECIAL},
-	{"process_fail",	NSS_STATS_TYPE_ERROR}
-};
-
-/*
- * nss_ppe_stats_str_sc_strings_read()
- *	Read ppe service code statistics names
- */
-static ssize_t nss_ppe_stats_str_sc_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_ppe_stats_str_sc, NSS_PPE_STATS_SERVICE_CODE_MAX);
-}
-
-/*
- * nss_ppe_stats_str_sc_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(ppe_stats_str_sc);
-
-/*
- * nss_ppe_stats_str_cc
- *	PPE statistics strings for cpu code
- */
-struct nss_stats_info nss_ppe_stats_str_cc[NSS_PPE_STATS_CPU_CODE_MAX] = {
-	{"CPU_CODE_FORWARDING",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_UNKNOWN_L2_PROT",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_PPPOE_WRONG_VER_TYPE",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_WRONG_CODE",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_PPPOE_UNSUPPORTED_PPP_PROT",	NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_WRONG_VER",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_SMALL_IHL",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_WITH_OPTION",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_HDR_INCOMPLETE",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_IPV4_BAD_TOTAL_LEN",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_DATA_INCOMPLETE",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_IPV4_FRAG",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_IPV4_PING_OF_DEATH",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_SNALL_TTL",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_IPV4_UNK_IP_PROT",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_CHECKSUM_ERR",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_INV_SIP",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_INV_DIP",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_LAND_ATTACK",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_IPV4_AH_HDR_INCOMPLETE",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_IPV4_AH_CROSS_BORDER",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_IPV4_ESP_HDR_INCOMPLETE",	NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_WRONG_VER",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_HDR_INCOMPLETE",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_IPV6_BAD_PAYLOAD_LEN",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_DATA_INCOMPLETE",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_IPV6_WITH_EXT_HDR",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_IPV6_SMALL_HOP_LIMIT",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_INV_SIP",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_INV_DIP",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_LAND_ATTACK",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_IPV6_FRAG",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_IPV6_PING_OF_DEATH",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_IPV6_WITH_EXT_HDR",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_IPV6_UNK_NEXT_HDR",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_IPV6_MOBILITY_HDR_INCOMPLETE",	NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_IPV6_MOBILITY_CROSS_BORDER",	NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_IPV6_AH_HDR_INCOMPLETE",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_IPV6_AH_CROSS_BORDER",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_IPV6_ESP_HDR_INCOMPLETE",	NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_IPV6_ESP_CROSS_BORDER",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_IPV6_OTHER_HDR_INCOMPLETE",	NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_IPV6_OTHER_EXT_CROSS_BORDER",	NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_HDR_INCOMPLETE",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_TCP_HDR_CROSS_BORDER",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_TCP_SMAE_SP_DP",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_TCP_SMALL_DATA_OFFSET",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_FLAGS_0",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_FLAGS_1",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_FLAGS_2",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_FLAGS_3",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_FLAGS_4",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_FLAGS_5",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_FLAGS_6",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_FLAGS_7",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_CHECKSUM_ERR",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_HDR_INCOMPLETE",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_UDP_HDR_CROSS_BORDER",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_UDP_SMAE_SP_DP",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_BAD_LEN",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_DATA_INCOMPLETE",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_CHECKSUM_ERR",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_UDP_LITE_HDR_INCOMPLETE",	NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_UDP_LITE_CROSS_BORDER",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_UDP_LITE_SP_DP",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_UDP_LITE_CSM_COV_TO_7",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_UDP_LITE_CSM_TOO_LONG",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_UDP_LITE_CSM_CROSS_BORDER",	NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_UDP_LITE_CHECKSUM_ERR",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_FAKE_L2_PROT_ERR",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EXP_FAKE_MAC_HEADER_ERR",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_BITMAP_MAX",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L2_MRU_FAIL",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L2_MTU_FAIL",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_EXP_IP_PREFIX_BC",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_MTU_FAIL",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_MRU_FAIL",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_ICMP_RDT",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_EXP_IP_RT_TO_ME",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_EXP_IP_TTL_ZERO",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_FLOW_SERVICE_CODE_LOOP",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_DE_ACCELERATE",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_EXP_FLOW_SRC_CHK_FAIL",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_FLOW_SYNC_TOGGLE_MISMATCH",	NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_EXP_MTU_DF_FAIL",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_PPPOE_MULTICAST",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_MGMT_OFFSET",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_MGMT_EAPOL",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_PPPOE_DIS",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_MGMT_IGMP",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_ARP_REQ",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_ARP_REP",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_MGMT_DHCPv4",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_MGMT_MLD",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_MGMT_NS",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_MGMT_NA",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_MGMT_DHCPv6",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_PTP_OFFSET",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_PTP_SYNC",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_FOLLOW_UP",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_DELAY_REQ",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_DELAY_RESP",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_PDELAY_REQ",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_PDELAY_RESP",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_PTP_PDELAY_RESP_FOLLOW_UP",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_PTP_ANNOUNCE",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_PTP_MANAGEMENT",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_PTP_SIGNALING",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_PTP_RSV_MSG",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_SG_UNKNOWN",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_SG_UNKNOWN",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_SG_UNKNOWN",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_SG_UNKNOWN",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_SG_VIO",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_SG_VIO",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_SG_VIO",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_SG_VIO",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_ROUTING_IP_TO_ME",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_SNAT_ACTION",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_DNAT_ACTION",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_RT_ACTION",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_BR_ACTION",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_BRIDGE_ACTION",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_ROUTE_PREHEAD_RT_ACTION",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_ROUTE_PREHEAD_SNAPT_ACTION",	NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_ROUTE_PREHEAD_DNAPT_ACTION",	NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_ROUTE_PREHEAD_SNAT_ACTION",	NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_ROUTE_PREHEAD_DNAT_ACTION",	NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_NO_ROUTE_NAT_ACTION",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_NO_ROUTE_NAT_ERROR",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_ROUTE_ACTION",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_ROUTE_ACTION",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_NO_ROUTE_INVALID_ACTION",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_NO_ROUTE_PREHEAD_ACTION",		NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_BRIDGE_ACTION",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_FLOW_ACTION",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L3_MISS_ACTION",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L2_MAC_ADDRESS",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_HASH_COLLISION",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_STATION_MOVE",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_LEARN_LIMIT",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L2_LOOKUP_ACTION",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_L2_LOOKUP_ACTION",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_CTRL_ACTION",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_IN_FILTER_ACTION",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_IN_XLT_MISS",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_EG_FILTER_DROP",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_PRE_ACTION",				NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_POST_ACTION",			NSS_STATS_TYPE_EXCEPTION},
-	{"CPU_CODE_CODE_ACTION",			NSS_STATS_TYPE_EXCEPTION}
-};
-
-/*
- * nss_ppe_stats_str_cc_strings_read()
- *	Read ppe cpu code statistics names
- */
-static ssize_t nss_ppe_stats_str_cc_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_ppe_stats_str_cc, NSS_PPE_STATS_CPU_CODE_MAX);
-}
-
-/*
- * nss_ppe_stats_str_cc_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(ppe_stats_str_cc);
-
-/*
- * nss_ppe_strings_dentry_create()
- *	Create ppe statistics strings debug entry.
- */
-void nss_ppe_strings_dentry_create(void)
-{
-	struct dentry *ppe_d = NULL;
-
-	if (!nss_top_main.strings_dentry) {
-		nss_warning("qca-nss-drv/strings is not present");
-		return;
-	}
-
-	ppe_d = debugfs_create_dir("ppe", nss_top_main.strings_dentry);
-	if (!ppe_d) {
-		nss_warning("Failed to create qca-nss-drv/strings/ppe directory");
-		return;
-	}
-
-	if (!debugfs_create_file("stats_str_conn", 0400, ppe_d, &nss_top_main, &nss_ppe_stats_str_conn_strings_ops)) {
-		nss_warning("Failed to create qca-nss-drv/strings/ppe/stats_str_conn file");
-		debugfs_remove_recursive(ppe_d);
-		return;
-	}
-
-	if (!debugfs_create_file("stats_str_sc", 0400, ppe_d, &nss_top_main, &nss_ppe_stats_str_sc_strings_ops)) {
-		nss_warning("Failed to create qca-nss-drv/strings/ppe/stats_str_sc file");
-		debugfs_remove_recursive(ppe_d);
-		return;
-	}
-
-	if (!debugfs_create_file("stats_str_l3", 0400, ppe_d, &nss_top_main, &nss_ppe_stats_str_l3_strings_ops)) {
-		nss_warning("Failed to create qca-nss-drv/strings/ppe/stats_str_l3 file");
-		debugfs_remove_recursive(ppe_d);
-		return;
-	}
-
-	if (!debugfs_create_file("stats_str_code", 0400, ppe_d, &nss_top_main, &nss_ppe_stats_str_code_strings_ops)) {
-		nss_warning("Failed to create qca-nss-drv/strings/ppe/stats_str_code file");
-		debugfs_remove_recursive(ppe_d);
-		return;
-	}
-
-	if (!debugfs_create_file("stats_str_dc", 0400, ppe_d, &nss_top_main, &nss_ppe_stats_str_dc_strings_ops)) {
-		nss_warning("Failed to create qca-nss-drv/strings/ppe/stats_str_dc file");
-		debugfs_remove_recursive(ppe_d);
-		return;
-	}
-
-	if (!debugfs_create_file("stats_str_cc", 0400, ppe_d, &nss_top_main, &nss_ppe_stats_str_cc_strings_ops)) {
-		nss_warning("Failed to create qca-nss-drv/strings/ppe/stats_str_cc file");
-		debugfs_remove_recursive(ppe_d);
-		return;
-	}
-}
--- a/nss_ppe_strings.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- ***************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ***************************************************************************
- */
-
-#ifndef __NSS_PPE_STRINGS_H
-#define __NSS_PPE_STRINGS_H
-
-#include "nss_ppe_stats.h"
-
-extern struct nss_stats_info nss_ppe_stats_str_conn[NSS_PPE_STATS_CONN_MAX];
-extern struct nss_stats_info nss_ppe_stats_str_sc[NSS_PPE_STATS_SERVICE_CODE_MAX];
-extern struct nss_stats_info nss_ppe_stats_str_l3[NSS_PPE_STATS_L3_MAX];
-extern struct nss_stats_info nss_ppe_stats_str_code[NSS_PPE_STATS_CODE_MAX];
-extern struct nss_stats_info nss_ppe_stats_str_dc[NSS_PPE_STATS_DROP_CODE_MAX];
-extern struct nss_stats_info nss_ppe_stats_str_cc[NSS_PPE_STATS_CPU_CODE_MAX];
-extern void nss_ppe_strings_dentry_create(void);
-
-#endif /* __NSS_PPE_STRINGS_H */
--- a/nss_ppe_vp.c
+++ b/nss_ppe_vp.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -16,19 +16,11 @@
  **************************************************************************
  */
 
-/*
- * Header file for qca-ssdk APIs
- */
-#include <ref/ref_vsi.h>
-
 #include "nss_ppe_vp.h"
 #include "nss_ppe_vp_stats.h"
 
 #define NSS_PPE_VP_TX_TIMEOUT 1000 /* 1 Second */
 
-static struct nss_vp_mapping *vp_map[NSS_MAX_DYNAMIC_INTERFACES] = {NULL};
-unsigned char nss_ppe_vp_cmd[NSS_PPE_VP_MAX_CMD_STR] __read_mostly;
-
 /*
  * Private data structure
  */
@@ -38,25 +30,17 @@ static struct nss_ppe_vp_pvt {
 	int response;
 	void *cb;
 	void *app_data;
-	nss_ppe_port_t ppe_port_num;
 } ppe_vp_pvt;
 
+int nss_ppe_vp_enable __read_mostly = 0;
+int nss_ppe_vp_disable __read_mostly = 0;
+
 DEFINE_SPINLOCK(nss_ppe_vp_stats_lock);
-DEFINE_SPINLOCK(nss_ppe_vp_map_lock);
 
 struct nss_ppe_vp_stats_debug nss_ppe_vp_debug_stats;
 static struct dentry *nss_ppe_vp_dentry;
 
 /*
- * nss_ppe_vp_get_map_index()
- *	Get the index of the NSS-VP number mapping array.
- */
-static inline int32_t nss_ppe_vp_get_map_index(nss_if_num_t if_num)
-{
-	return (if_num - NSS_DYNAMIC_IF_START);
-}
-
-/*
  * nss_ppe_vp_verify_ifnum()
  *	Verify PPE VP interface number.
  */
@@ -66,122 +50,12 @@ static inline bool nss_ppe_vp_verify_ifn
 }
 
 /*
- * nss_ppe_vp_map_dealloc()
- *	Deallocate memory for the NSS interface number and PPE VP number mapping.
- */
-static inline void nss_ppe_vp_map_dealloc(struct nss_vp_mapping *map)
-{
-	vfree(map);
-}
-
-/*
- * nss_ppe_vp_map_alloc()
- *	Allocate memory for the NSS interface number and PPE VP number mapping.
- */
-static inline struct nss_vp_mapping *nss_ppe_vp_map_alloc(void)
-{
-	struct nss_vp_mapping *nss_vp_info = vzalloc(sizeof(struct nss_vp_mapping));
-	if (!nss_vp_info) {
-		nss_warning("No memory for allocating NSS-VP mapping instance");
-	}
-
-	return nss_vp_info;
-}
-
-/*
- * nss_ppe_vp_proc_help()
- *	Print usage information for ppe_vp configure sysctl.
- */
-static void nss_ppe_vp_proc_help(void)
-{
-	nss_info_always("== for dynamic interface types read following file ==");
-	nss_info_always("/sys/kernel/debug/qca-nss-drv/stats/dynamic_if/type_names");
-	nss_info_always("NSS PPE VP create: echo <interface name> <dynamic interface type> > /proc/sys/nss/ppe_vp/create");
-	nss_info_always("NSS PPE VP destroy: echo <interface name> <dynamic interface type> > /proc/sys/nss/ppe_vp/destroy");
-}
-
-/*
- * nss_ppe_vp_del_map()
- *	Delete mapping between NSS interface number and VP number.
- */
-static bool nss_ppe_vp_del_map(struct nss_ctx_instance *nss_ctx, nss_if_num_t if_num)
-{
-	int32_t idx;
-	nss_ppe_port_t ppe_port_num;
-	struct nss_vp_mapping *nss_vp_info;
-	uint16_t vp_index;
-
-	nss_assert((if_num >= NSS_DYNAMIC_IF_START) && (if_num < (NSS_DYNAMIC_IF_START + NSS_MAX_DYNAMIC_INTERFACES)));
-
-	idx = nss_ppe_vp_get_map_index(if_num);
-	if ((idx < 0) || (idx >= NSS_MAX_DYNAMIC_INTERFACES)) {
-		nss_warning("%px: Invalid index. Cannot delete the PPE VP mapping. idx:%u", nss_ctx, idx);
-		return false;
-	}
-
-	spin_lock_bh(&nss_ppe_vp_map_lock);
-	nss_vp_info = vp_map[idx];
-	if (!nss_vp_info) {
-		spin_unlock_bh(&nss_ppe_vp_map_lock);
-		nss_warning("%px: Could not find the vp num in the mapping. NSS if num:%u", nss_ctx, if_num);
-		return false;
-	}
-
-	ppe_port_num = nss_vp_info->ppe_port_num;
-
-	nss_ppe_vp_map_dealloc(nss_vp_info);
-	vp_map[idx] = NULL;
-	spin_unlock_bh(&nss_ppe_vp_map_lock);
-
-	/*
-	 * Clear the PPE VP stats once PPE VP is deleted
-	 */
-	vp_index = ppe_port_num - NSS_PPE_VP_START;
-	spin_lock_bh(&nss_ppe_vp_stats_lock);
-	memset(&nss_ppe_vp_debug_stats.vp_stats[vp_index], 0, sizeof(struct nss_ppe_vp_statistics_debug));
-	spin_unlock_bh(&nss_ppe_vp_stats_lock);
-
-	nss_info("%px: Deleted NSS interface number and PPE VP number mapping successfully: NSS if num:%u at index:%u", nss_ctx, if_num, idx);
-
-	return true;
-}
-
-/*
- * nss_ppe_vp_add_map()
- *	Add mapping between NSS interface number and VP number.
+ * nss_ppe_vp_get_context()
+ *	Get NSS context instance for ppe_vp
  */
-static bool nss_ppe_vp_add_map(struct nss_ctx_instance *nss_ctx ,nss_if_num_t if_num, struct nss_vp_mapping *nss_vp_info)
+struct nss_ctx_instance *nss_ppe_vp_get_context(void)
 {
-	uint32_t idx;
-	nss_ppe_port_t ppe_port_num;
-
-	nss_assert((if_num >= NSS_DYNAMIC_IF_START) && (if_num < (NSS_DYNAMIC_IF_START + NSS_MAX_DYNAMIC_INTERFACES)));
-
-	if (!nss_vp_info) {
-		nss_warning("%px: Received invalid argument.", nss_ctx);
-		return false;
-	}
-
-	idx = nss_ppe_vp_get_map_index(if_num);
-	if ((idx < 0) || (idx >= NSS_MAX_DYNAMIC_INTERFACES)) {
-		nss_warning("%px: Invalid index. Cannot add the PPE VP mapping. idx:%u", nss_ctx, idx);
-		return false;
-	}
-
-	spin_lock_bh(&nss_ppe_vp_map_lock);
-	if (vp_map[idx]) {
-		spin_unlock_bh(&nss_ppe_vp_map_lock);
-		nss_warning("%px: Mapping exists already. NSS if num:%d index:%u, VP num:%u", nss_ctx, if_num, idx, vp_map[idx]->ppe_port_num);
-		return false;
-	}
-
-	vp_map[idx] = nss_vp_info;
-	ppe_port_num = vp_map[idx]->ppe_port_num;
-	spin_unlock_bh(&nss_ppe_vp_map_lock);
-
-	nss_info("%px: Mapping added successfully. NSS if num:%d index:%u, VP num:%u", nss_ctx, if_num, idx, ppe_port_num);
-
-	return true;
+	return (struct nss_ctx_instance *)&nss_top_main.nss[nss_top_main.ppe_handler_id];
 }
 
 /*
@@ -191,107 +65,21 @@ static bool nss_ppe_vp_add_map(struct ns
 static void nss_ppe_vp_callback(void *app_data, struct nss_ppe_vp_msg *npvm)
 {
 	if (npvm->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_warning("ppe_vp error response %d", npvm->cm.response);
-		ppe_vp_pvt.response = NSS_TX_FAILURE;
-		complete(&ppe_vp_pvt.complete);
-		return;
+		nss_warning("ppe_vp error response %d\n", npvm->cm.response);
+		ppe_vp_pvt.response = npvm->cm.response;
 	}
 
-	if (npvm->cm.type == NSS_IF_PPE_PORT_CREATE) {
-		ppe_vp_pvt.ppe_port_num = npvm->msg.if_msg.ppe_port_create.ppe_port_num;
-		nss_trace("PPE VP callback success VP num: %u", npvm->msg.if_msg.ppe_port_create.ppe_port_num);
-	}
 	ppe_vp_pvt.response = NSS_TX_SUCCESS;
-
 	complete(&ppe_vp_pvt.complete);
 }
 
 /*
- * nss_ppe_vp_parse_vp_cmd()
- *	Parse PPE VP create and destroy message and return the NSS interface number.
- * Command usage:
- * echo <interface name> <dynamic interface type> /proc/sys/nss/ppe_vp/create>
- * echo ath0 6 > /proc/sys/nss/ppe_vp/create
- * Since ath0 has only one type i.e. ath0 is NSS_DYNAMIC_INTERFACE_TYPE_VAP, the above command can be rewritten as
- * echo ath0 > /proc/sys/nss/ppe_vp/create => Here 6 can be ignored.
- */
-static nss_if_num_t nss_ppe_vp_parse_vp_cmd(struct ctl_table *ctl, int write, void __user *buffer, size_t *lenp, loff_t *ppos)
-{
-	int32_t if_num;
-	struct net_device *dev;
-	uint32_t  dynamic_if_type = (uint32_t)NSS_DYNAMIC_INTERFACE_TYPE_NONE;
-	struct nss_ctx_instance *nss_ctx = nss_ppe_vp_get_context();
-	char *pos;
-	char cmd_buf[NSS_PPE_VP_MAX_CMD_STR] = {0}, dev_name[NSS_PPE_VP_MAX_CMD_STR] = {0};
-	size_t count = *lenp;
-	int ret = proc_dostring(ctl, write, buffer, lenp, ppos);
-
-	if (!write) {
-		nss_ppe_vp_proc_help();
-		return ret;
-	}
-
-	if (!nss_ctx) {
-		nss_warning("%px: NSS Context not found.", nss_ctx);
-		return -ENODEV;
-	}
-
-	NSS_VERIFY_CTX_MAGIC(nss_ctx);
-
-	if (count >= NSS_PPE_VP_MAX_CMD_STR) {
-		nss_ppe_vp_proc_help();
-		nss_warning("%px: Input string too big", nss_ctx);
-		return -E2BIG;
-	}
-
-	if (copy_from_user(cmd_buf, buffer, count)) {
-		nss_warning("%px: Cannot copy user's entry to kernel memory", nss_ctx);
-		return -EFAULT;
-	}
-
-	if ((pos = strrchr(cmd_buf, '\n')) != NULL) {
-		*pos = '\0';
-	}
-
-	if (sscanf(cmd_buf, "%s %u", dev_name, &dynamic_if_type) < 0) {
-		nss_warning("%px: PPE VP command parse failed", nss_ctx);
-		return -EFAULT;
-	}
-
-	dev = dev_get_by_name(&init_net, dev_name);
-	if (!dev) {
-		nss_warning("%px: Cannot find the net device", nss_ctx);
-		return -ENODEV;
-	}
-
-	nss_info("%px: Dynamic interface type: %u", nss_ctx, dynamic_if_type);
-	if ((dynamic_if_type < NSS_DYNAMIC_INTERFACE_TYPE_NONE) || (dynamic_if_type >= NSS_DYNAMIC_INTERFACE_TYPE_MAX)) {
-		nss_warning("%px: Invalid dynamic interface type: %d", nss_ctx, dynamic_if_type);
-		dev_put(dev);
-		return -EFAULT;
-	}
-
-	if_num = nss_cmn_get_interface_number_by_dev_and_type(dev, dynamic_if_type);
-	if (if_num < 0) {
-		nss_warning("%px: Invalid interface number:%s", nss_ctx, dev_name);
-		dev_put(dev);
-		return -EFAULT;
-	}
-
-	nss_info("%px: PPE VP create/destroy for, nss_if_num:%d dev_name:%s dynamic_if_type:%u", nss_ctx, if_num, dev_name, dynamic_if_type);
-	dev_put(dev);
-
-	return if_num;
-}
-
-/*
  * nss_ppe_vp_tx_msg()
  *	Transmit a ppe_vp message to NSS FW
  */
 nss_tx_status_t nss_ppe_vp_tx_msg(struct nss_ctx_instance *nss_ctx, struct nss_ppe_vp_msg *msg)
 {
 	struct nss_cmn_msg *ncm = &msg->cm;
-	nss_if_num_t if_num = ncm->interface;
 
 	/*
 	 * Trace messages.
@@ -301,13 +89,13 @@ nss_tx_status_t nss_ppe_vp_tx_msg(struct
 	/*
 	 * Sanity check the message
 	 */
-	if (!((ncm->type == NSS_IF_PPE_PORT_CREATE) || (ncm->type == NSS_IF_PPE_PORT_DESTROY))) {
-		nss_warning("%px: Invalid message type: %d", nss_ctx, ncm->type);
+	if (ncm->type >= NSS_PPE_VP_MSG_MAX) {
+		nss_warning("%px: message type out of range: %d\n", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
-	if (!(if_num >= NSS_DYNAMIC_IF_START && (if_num < (NSS_DYNAMIC_IF_START + NSS_MAX_DYNAMIC_INTERFACES)))) {
-		nss_warning("%px: invalid interface %d", nss_ctx, ncm->interface);
+	if (!nss_ppe_vp_verify_ifnum(ncm->interface)) {
+		nss_warning("%px: invalid interface %d\n", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
@@ -324,294 +112,63 @@ nss_tx_status_t nss_ppe_vp_tx_msg_sync(s
 	int ret = 0;
 
 	down(&ppe_vp_pvt.sem);
+	npvm->cm.cb = (nss_ptr_t)nss_ppe_vp_callback;
+	npvm->cm.app_data = (nss_ptr_t)NULL;
 
 	status = nss_ppe_vp_tx_msg(nss_ctx, npvm);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%px: ppe_tx_msg failed", nss_ctx);
+		nss_warning("%px: ppe_tx_msg failed\n", nss_ctx);
 		up(&ppe_vp_pvt.sem);
 		return status;
 	}
 
 	ret = wait_for_completion_timeout(&ppe_vp_pvt.complete, msecs_to_jiffies(NSS_PPE_VP_TX_TIMEOUT));
 	if (!ret) {
-		nss_warning("%px: ppe_vp msg tx failed due to timeout", nss_ctx);
+		nss_warning("%px: ppe_vp msg tx failed due to timeout\n", nss_ctx);
 		ppe_vp_pvt.response = NSS_TX_FAILURE;
 	}
 
 	status = ppe_vp_pvt.response;
 	up(&ppe_vp_pvt.sem);
-
 	return status;
 }
 
 /*
- * nss_ppe_vp_get_context()
- *	Get NSS context instance for ppe_vp
- */
-struct nss_ctx_instance *nss_ppe_vp_get_context(void)
-{
-	return (struct nss_ctx_instance *)&nss_top_main.nss[nss_top_main.ppe_handler_id];
-}
-EXPORT_SYMBOL(nss_ppe_vp_get_context);
-
-/*
- * nss_ppe_vp_get_ppe_port_by_nssif()
- *	Get vp number for a given NSS interface number.
+ * nss_ppe_vp_tx_config_msg
+ *	API to send ppe_vp support configure message to NSS FW
  */
-nss_ppe_port_t nss_ppe_vp_get_ppe_port_by_nssif(struct nss_ctx_instance *nss_ctx, nss_if_num_t if_num)
+nss_tx_status_t nss_ppe_vp_tx_config_msg(enum nss_dynamic_interface_type type, bool enable)
 {
-	uint32_t idx;
-	nss_ppe_port_t ppe_port_num;
-
-	if (!((if_num >= NSS_DYNAMIC_IF_START) && (if_num < (NSS_DYNAMIC_IF_START + NSS_MAX_DYNAMIC_INTERFACES)))) {
-		nss_warning("%px: NSS invalid nss if num: %u", nss_ctx, if_num);
-		return -1;
-	}
-
-	idx = nss_ppe_vp_get_map_index(if_num);
-	if (idx < 0 || idx >= NSS_MAX_DYNAMIC_INTERFACES) {
-		nss_warning("%px: NSS invalid index: %d nss if num: %u",nss_ctx, idx, if_num);
-		return -1;
-	}
-
-	spin_lock_bh(&nss_ppe_vp_map_lock);
-	if (!vp_map[idx]) {
-		spin_unlock_bh(&nss_ppe_vp_map_lock);
-		nss_warning("%px: NSS interface and VP mapping is not present for nss if num: %u",nss_ctx, if_num);
-		return -1;
-	}
-	ppe_port_num = vp_map[idx]->ppe_port_num;
-	spin_unlock_bh(&nss_ppe_vp_map_lock);
-
-	nss_info("%px: VP num %d nss_if: %d",nss_ctx, ppe_port_num, if_num);
-
-	return ppe_port_num;
-}
-EXPORT_SYMBOL(nss_ppe_vp_get_ppe_port_by_nssif);
-
-/*
- * nss_ppe_vp_destroy()
- *	Destroy PPE virtual port for the given nss interface number.
- */
-nss_tx_status_t nss_ppe_vp_destroy(struct nss_ctx_instance *nss_ctx, nss_if_num_t if_num)
-{
-	nss_tx_status_t status;
+	struct nss_ctx_instance *nss_ctx = nss_ppe_vp_get_context();
+	struct nss_ppe_vp_config_msg *npvcm;
 	struct nss_ppe_vp_msg *npvm;
-	uint32_t idx;
-	int32_t vsi_id_valid = false;
-	int32_t vsi_id;
-
-	NSS_VERIFY_CTX_MAGIC(nss_ctx);
-
-	idx = nss_ppe_vp_get_map_index(if_num);
-	if (idx < 0 || idx >= NSS_MAX_DYNAMIC_INTERFACES) {
-		nss_warning("%px: Cannot destroy PPE VP. Invalid index: %d. nss_if_num: %u", nss_ctx, idx, if_num);
-		return -1;
-	}
-
-	spin_lock_bh(&nss_ppe_vp_map_lock);
-	if (vp_map[idx]) {
-		vsi_id = vp_map[idx]->vsi_id;
-		vsi_id_valid = vp_map[idx]->vsi_id_valid;
-	}
-	spin_unlock_bh(&nss_ppe_vp_map_lock);
-
-	if (vsi_id_valid) {
-		/*
-		 * Send the dettach VSI message to the Firmware.
-		 */
-		if (nss_if_vsi_unassign(nss_ctx, if_num, vsi_id)) {
-			nss_warning("%px: PPE VP destroy failed. Failed to detach VSI to PPE VP interface %d vsi:%d", nss_ctx, if_num, vsi_id);
-			return NSS_TX_FAILURE;
-		}
-
-		if (ppe_vsi_free(NSS_PPE_VP_SWITCH_ID, vsi_id)) {
-			nss_warning("%px: PPE VP destroy failed. Failed to free PPE VSI. nss_if:%d vsi:%d", nss_ctx, if_num, vsi_id);
-			return NSS_TX_FAILURE;
-		}
-
-		nss_info("%px: PPE VP VSI detached successfully. VSI ID freed successfully. NSS if num:%u, VSI ID:%u", nss_ctx, if_num, vsi_id);
-	}
-
-	npvm = kzalloc(sizeof(struct nss_ppe_vp_msg), GFP_KERNEL);
-	if (!npvm) {
-		nss_warning("%px: Unable to allocate memeory of PPE VP message", nss_ctx);
-		return NSS_TX_FAILURE;
-	}
-
-	nss_trace("%px: PPE_VP will be destroyed for an interface: %d", nss_ctx, if_num);
-
-	/*
-	 * Destroy PPE VP for a dynamic interface.
-	 */
-	nss_cmn_msg_init(&npvm->cm, if_num, NSS_IF_PPE_PORT_DESTROY, 0, nss_ppe_vp_callback, NULL);
-
-	status = nss_ppe_vp_tx_msg_sync(nss_ctx, npvm);
-	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%px: Unable to send PPE VP destroy message", nss_ctx);
-		kfree(npvm);
-		return NSS_TX_FAILURE;
-	}
-
-	kfree(npvm);
-
-	/*
-	 * Delete mapping between the NSS interface number and the VP number.
-	 */
-	if (!nss_ppe_vp_del_map(nss_ctx, if_num)) {
-		nss_warning("%px: Failed to delete the mapping for nss_if:%d", nss_ctx, if_num);
-		return NSS_TX_FAILURE;
-	}
-
-	return status;
-}
-EXPORT_SYMBOL(nss_ppe_vp_destroy);
-
-/*
- * nss_ppe_vp_create()
- *	Create PPE virtual port for the given nss interface number.
- */
-nss_tx_status_t nss_ppe_vp_create(struct nss_ctx_instance *nss_ctx, nss_if_num_t if_num)
-{
-	uint32_t vsi_id;
 	nss_tx_status_t status;
-	struct nss_ppe_vp_msg *npvm;
-	struct nss_vp_mapping *nss_vp_info;
-
-	NSS_VERIFY_CTX_MAGIC(nss_ctx);
 
-	/*
-	 * TODO: No need to create VSI for tunnel interfaces. Only for VAP interfaces VSI is needed.
-	 * Allocate the VSI for the dynamic interface on which VP will be created.
-	 */
-	if (ppe_vsi_alloc(NSS_PPE_VP_SWITCH_ID, &vsi_id)) {
-		nss_warning("%px, Failed to alloc VSI ID, PPE VP create failed. nss_if:%u", nss_ctx, if_num);
-		return NSS_TX_FAILURE;
+	if (type >= NSS_DYNAMIC_INTERFACE_TYPE_MAX) {
+		nss_warning("%px: Dynamic if msg drooped as type is wrong:%d\n", nss_ctx, type);
+		return -1;
 	}
 
 	npvm = kzalloc(sizeof(struct nss_ppe_vp_msg), GFP_KERNEL);
 	if (!npvm) {
-		nss_warning("%px: Unable to allocate memeory of PPE VP message", nss_ctx);
-		goto free_vsi;
+		nss_warning("%px: Unable to allocate message\n", nss_ctx);
+		return -1;
 	}
 
-	nss_trace("%px: PPE_VP will be created for an interface: %d", nss_ctx, if_num);
+	nss_cmn_msg_init(&npvm->cm, NSS_PPE_VP_INTERFACE, NSS_PPE_VP_MSG_CONFIG,
+				sizeof(struct nss_ppe_vp_config_msg), NULL, NULL);
 
-	/*
-	 * Create PPE VP for a dynamic interface.
-	 */
-	nss_cmn_msg_init(&npvm->cm, if_num, NSS_IF_PPE_PORT_CREATE,
-			sizeof(struct nss_if_ppe_port_create), nss_ppe_vp_callback, NULL);
+	npvcm = &npvm->msg.vp_config;
+	npvcm->type = type;
+	npvcm->vp_enable = enable;
 
 	status = nss_ppe_vp_tx_msg_sync(nss_ctx, npvm);
 	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%px: Unable to send ppe_vp create message", nss_ctx);
-		goto free_alloc;
-	}
-
-	/*
-	 * Send the attach VSI message to the Firmware.
-	 */
-	if (nss_if_vsi_assign(nss_ctx, if_num, vsi_id) != NSS_TX_SUCCESS) {
-		nss_warning("%px: Failed to attach VSI to PPE VP interface. nss_if:%u vsi:%u", nss_ctx, if_num, vsi_id);
-		goto destroy_vp;
-	}
-
-	nss_vp_info = nss_ppe_vp_map_alloc();
-	if (!nss_vp_info) {
-		nss_warning("%px: No memory for allocating NSS-VP mapping instance", nss_ctx);
-		goto detach_vsi;
-	}
-
-	nss_vp_info->vsi_id = vsi_id;
-	nss_vp_info->vsi_id_valid = true;
-	nss_vp_info->if_num = if_num;
-	nss_vp_info->ppe_port_num = ppe_vp_pvt.ppe_port_num;
-
-	nss_info("%px: PPE VP allocated VSI ID:%u NSS interface number:%u VP no from Firmware:%u", nss_ctx, vsi_id, if_num, nss_vp_info->ppe_port_num);
-
-	/*
-	 * Add mapping between the NSS interface number and the VP number.
-	 */
-	if (!nss_ppe_vp_add_map(nss_ctx, if_num, nss_vp_info)) {
-		nss_warning("%px: Failed to add mapping for NSS interface number: %d", nss_ctx, if_num);
-		goto free_nss_vp_info;
+		nss_warning("%px: Unable to send ppe_vp config message for type:%d\n", nss_ctx, type);
 	}
 
 	kfree(npvm);
-
 	return status;
-
-free_nss_vp_info:
-	nss_ppe_vp_map_dealloc(nss_vp_info);
-
-detach_vsi:
-	nss_trace("%px: Detaching VSI ID :%u NSS Interface no:%u", nss_ctx, vsi_id, if_num);
-	if (nss_if_vsi_unassign(nss_ctx, if_num, vsi_id)) {
-		nss_warning("%px: Failed to free PPE VP VSI. nss_if:%u vsi:%u", nss_ctx, if_num, vsi_id);
-	}
-
-destroy_vp:
-	nss_trace("%px: Destroy Vp for NSS Interface num:%u VP num:%u", nss_ctx, if_num, npvm->msg.if_msg.ppe_port_create.ppe_port_num);
-	if (nss_ppe_vp_destroy(nss_ctx, if_num)) {
-		nss_warning("%px: PPE VP destroy failed, nss_if:%u", nss_ctx, if_num);
-	}
-
-free_alloc:
-	kfree(npvm);
-
-free_vsi:
-	nss_trace("%px: Free VSI ID :%u NSS Interface no:%u", nss_ctx, vsi_id, if_num);
-	if (ppe_vsi_free(NSS_PPE_VP_SWITCH_ID, vsi_id)) {
-		nss_warning("%px: Failed to free PPE VP VSI. NSS if num:%u vsi:%u", nss_ctx, if_num, vsi_id);
-	}
-
-	return NSS_TX_FAILURE;
-}
-EXPORT_SYMBOL(nss_ppe_vp_create);
-
-/*
- * nss_ppe_vp_destroy_notify()
- *	Get PPE VP destroy notification from NSS
- */
-static void nss_ppe_vp_destroy_notify(struct nss_ctx_instance *nss_ctx, struct nss_ppe_vp_destroy_notify_msg *destroy_notify)
-{
-	nss_if_num_t nss_if_num;
-	uint32_t i;
-	int32_t vsi_id;
-	bool vsi_id_valid = false;
-	nss_ppe_port_t ppe_port_num = destroy_notify->ppe_port_num;
-
-	/*
-	 * Find NSS interface number corresponding to the VP num.
-	 */
-	spin_lock_bh(&nss_ppe_vp_map_lock);
-	for (i = 0; i < NSS_MAX_DYNAMIC_INTERFACES; i++) {
-		if (vp_map[i] && (ppe_port_num == vp_map[i]->ppe_port_num)) {
-			nss_if_num = vp_map[i]->if_num;
-			vsi_id = vp_map[i]->vsi_id;
-			vsi_id_valid = vp_map[i]->vsi_id_valid;
-			break;
-		}
-	}
-	spin_unlock_bh(&nss_ppe_vp_map_lock);
-
-	if (i == NSS_MAX_DYNAMIC_INTERFACES) {
-		nss_warning("%px: Could not find the NSS interface number mapping for VP number: %u\n", nss_ctx, ppe_port_num);
-		return;
-	}
-
-	/*
-	 * Delete the nss_if_num to VP num mapping and reset the stats entry for this VP.
-	 */
-	if (!nss_ppe_vp_del_map(nss_ctx, nss_if_num)) {
-		nss_warning("%px: Failed to delete the mapping for nss_if: %d\n", nss_ctx, nss_if_num);
-		return;
-	}
-
-	if (vsi_id_valid && ppe_vsi_free(NSS_PPE_VP_SWITCH_ID, vsi_id)) {
-		nss_warning("%px: Failed to free PPE VSI. nss_if: %d vsi: %d\n", nss_ctx, nss_if_num, vsi_id);
-	}
 }
 
 /*
@@ -624,48 +181,34 @@ static void nss_ppe_vp_handler(struct ns
 	nss_ppe_vp_msg_callback_t cb;
 	void *ctx;
 
-	NSS_VERIFY_CTX_MAGIC(nss_ctx);
-
-	nss_trace("%px ppe_vp msg: %px\n", nss_ctx, msg);
+	nss_trace("nss_ctx: %px ppe_vp msg: %px\n", nss_ctx, msg);
 	BUG_ON(!nss_ppe_vp_verify_ifnum(ncm->interface));
 
 	/*
+	 * Trace messages.
+	 */
+	nss_ppe_vp_log_rx_msg(msg);
+
+	/*
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_PPE_VP_MSG_MAX) {
-		nss_warning("%px: received invalid message %d for PPE_VP interface", nss_ctx, ncm->type);
+		nss_warning("%px: received invalid message %d for PPE_VP interface\n", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_ppe_vp_msg)) {
-		nss_warning("%px: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%px: Length of message is greater than required: %d\n", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
-	/*
-	 * Trace messages.
-	 */
-	nss_ppe_vp_log_rx_msg(msg);
-
 	switch (msg->cm.type) {
 	case NSS_PPE_VP_MSG_SYNC_STATS:
 		/*
 		 * Per VP stats msg
 		 */
 		nss_ppe_vp_stats_sync(nss_ctx, &msg->msg.stats, ncm->interface);
-		break;
-
-	case NSS_PPE_VP_MSG_DESTROY_NOTIFY:
-		/*
-		 * VP destroy notification
-		 */
-		nss_ppe_vp_destroy_notify(nss_ctx, &msg->msg.destroy_notify);
-		break;
-	}
-
-	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
-		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
-		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[ncm->interface].app_data;
+		return;
 	}
 
 	/*
@@ -690,76 +233,83 @@ static void nss_ppe_vp_handler(struct ns
 }
 
 /*
- * nss_ppe_vp_destroy_handler()
- *	PPE VP destroy handler.
+ * nss_ppe_vp_proc_help
+ *	Print usage information for ppe_vp configure sysctl.
  */
-static int nss_ppe_vp_destroy_handler(struct ctl_table *ctl, int write, void __user *buffer, size_t *lenp, loff_t *ppos)
+void nss_ppe_vp_proc_help(void)
 {
-	struct nss_ctx_instance *nss_ctx = nss_ppe_vp_get_context();
-	int32_t if_num;
-	nss_tx_status_t nss_tx_status;
+	printk("== for dynamic interface types read following file ==\n");
+	printk("/sys/kernel/debug/qca-nss-drv/stats/dynamic_if/type_names\n");
+}
 
-	if (!nss_ctx) {
-		nss_warning("%px: NSS Context not found.", nss_ctx);
-		return -ENODEV;
-	}
+/*
+ * nss_ppe_vp_enable_handler
+ *	Enable VP support for specfic dynamic interface type.
+ */
+static int nss_ppe_vp_enable_handler(struct ctl_table *table, int write, void __user *buffer,
+					size_t *lenp, loff_t *ppos)
+{
+	nss_tx_status_t status;
+	enum nss_dynamic_interface_type type;
+
+	int ret = proc_dointvec(table, write, buffer, lenp, ppos);
+	if (ret)
+		return ret;
 
-	NSS_VERIFY_CTX_MAGIC(nss_ctx);
+	nss_info("%s:%d start\n", __func__, __LINE__);
 
-	if_num = nss_ppe_vp_parse_vp_cmd(ctl, write, buffer, lenp, ppos);
-	if (if_num < 0) {
-		nss_warning("%px: Invalid interface number: %d", nss_ctx, if_num);
-		return -EFAULT;
+	if (!write) {
+		nss_info("print dynamic interface type table\n");
+		nss_ppe_vp_proc_help();
+		return ret;
 	}
 
-	if (nss_ppe_vp_get_ppe_port_by_nssif(nss_ctx, if_num) < 0) {
-		nss_warning("%px: VP is not present for interface: %d", nss_ctx, if_num);
-		return -EEXIST;
+	type = nss_ppe_vp_enable;
+	if ((type <= NSS_DYNAMIC_INTERFACE_TYPE_NONE) || (type >= NSS_DYNAMIC_INTERFACE_TYPE_MAX)) {
+		nss_warning("incorrect type: %u", nss_ppe_vp_enable);
+		nss_ppe_vp_proc_help();
+		return -EINVAL;
 	}
 
-	nss_tx_status = nss_ppe_vp_destroy(nss_ctx, if_num);
-	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%px: Sending message failed, cannot destroy PPE_VP node nss_if: %u", nss_ctx, if_num);
-		return -EBUSY;
+	status = nss_ppe_vp_tx_config_msg(type, true);
+	if (status != NSS_TX_SUCCESS) {
+		nss_warning("failed to enable VP support for type: %u", type);
+		return -EINVAL;
 	}
 
 	return 0;
 }
 
 /*
- * nss_ppe_vp_create_handler()
- *	PPE VP create handler.
+ * nss_ppe_vp_disable_handler
+ *	Disable VP support for a given dynamic interface type.
  */
-static int nss_ppe_vp_create_handler(struct ctl_table *ctl, int write, void __user *buffer, size_t *lenp, loff_t *ppos)
+static int nss_ppe_vp_disable_handler(struct ctl_table *table, int write, void __user *buffer,
+					size_t *lenp, loff_t *ppos)
 {
-	int32_t if_num;
-	struct nss_ctx_instance *nss_ctx = nss_ppe_vp_get_context();
-	nss_tx_status_t nss_tx_status;
-
-	if (!nss_ctx) {
-		nss_warning("%px: NSS Context not found.", nss_ctx);
-		return -ENODEV;
-	}
+	nss_tx_status_t status;
+	enum nss_dynamic_interface_type type;
 
-	NSS_VERIFY_CTX_MAGIC(nss_ctx);
+	int ret = proc_dointvec(table, write, buffer, lenp, ppos);
+	if (ret)
+		return ret;
 
-	if_num = nss_ppe_vp_parse_vp_cmd(ctl, write, buffer, lenp, ppos);
-	if (if_num < 0) {
-		nss_warning("%px: Invalid interface number: %d", nss_ctx, if_num);
-		return -EFAULT;
+	if (!write) {
+		nss_ppe_vp_proc_help();
+		return ret;
 	}
 
-	nss_info("%px: NSS interface number: %d", nss_ctx, if_num);
-
-	if (nss_ppe_vp_get_ppe_port_by_nssif(nss_ctx, if_num) > 0) {
-		nss_warning("%px: VP is already present for nss_if_num: %d", nss_ctx, if_num);
-		return -EEXIST;
+	type = nss_ppe_vp_disable;
+	if ((type <= NSS_DYNAMIC_INTERFACE_TYPE_NONE) || (type >= NSS_DYNAMIC_INTERFACE_TYPE_MAX)) {
+		nss_warning("incorrect type: %u", nss_ppe_vp_enable);
+		nss_ppe_vp_proc_help();
+		return -EINVAL;
 	}
 
-	nss_tx_status = nss_ppe_vp_create(nss_ctx, if_num);
-	if (nss_tx_status != NSS_TX_SUCCESS) {
-		nss_warning("%px: Sending message failed, cannot create PPE VP node for nss_if_num: %u", nss_ctx, if_num);
-		return -EBUSY;
+	status = nss_ppe_vp_tx_config_msg(type, false);
+	if (status != NSS_TX_SUCCESS) {
+		nss_warning("failed to disable VP support for type: %u", type);
+		return -EINVAL;
 	}
 
 	return 0;
@@ -767,18 +317,18 @@ static int nss_ppe_vp_create_handler(str
 
 static struct ctl_table nss_ppe_vp_table[] = {
 	{
-		.procname       = "create",
-		.data           = &nss_ppe_vp_cmd,
-		.maxlen         = sizeof(nss_ppe_vp_cmd),
+		.procname	= "enable",
+		.data           = &nss_ppe_vp_enable,
+		.maxlen         = sizeof(int),
 		.mode           = 0644,
-		.proc_handler   = &nss_ppe_vp_create_handler,
+		.proc_handler   = &nss_ppe_vp_enable_handler,
 	},
 	{
-		.procname       = "destroy",
-		.data           = &nss_ppe_vp_cmd,
-		.maxlen         = sizeof(nss_ppe_vp_cmd),
+		.procname	= "disable",
+		.data           = &nss_ppe_vp_disable,
+		.maxlen         = sizeof(int),
 		.mode           = 0644,
-		.proc_handler   = &nss_ppe_vp_destroy_handler,
+		.proc_handler   = &nss_ppe_vp_disable_handler,
 	},
 	{ }
 };
@@ -839,7 +389,7 @@ void nss_ppe_vp_register_handler(void)
 
 	nss_ppe_vp_dentry = nss_ppe_vp_stats_dentry_create();
 	if (nss_ppe_vp_dentry == NULL) {
-		nss_warning("%px: Not able to create debugfs entry", nss_ctx);
+		nss_warning("%px: Not able to create debugfs entry\n", nss_ctx);
 		return;
 	}
 
--- a/nss_ppe_vp.h
+++ b/nss_ppe_vp.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -30,8 +30,7 @@
 #define NSS_PPE_VP_MAX_NUM 192
 #define NSS_PPE_VP_START 64
 #define NSS_PPE_VP_NODE_STATS_MAX 32
-#define NSS_PPE_VP_SWITCH_ID 0
-#define NSS_PPE_VP_MAX_CMD_STR 200
+
 
 /*
  * ppe_vp nss debug stats lock
@@ -44,7 +43,7 @@ extern spinlock_t nss_ppe_vp_stats_lock;
  */
 enum nss_ppe_vp_msg_error_type {
 	NSS_PPE_VP_MSG_ERROR_TYPE_UNKNOWN,	/* Unknown message error */
-	PPE_VP_MSG_ERROR_TYPE_INVALID_DI,	/* Invalid dynamic interface type */
+	NSS_PPE_VP_MSG_ERROR_TYPE_INVALID_DI,	/* Invalid dynamic interface type error */
 	NSS_PPE_VP_MSG_ERROR_TYPE_MAX		/* Maximum error type */
 };
 
@@ -53,18 +52,27 @@ enum nss_ppe_vp_msg_error_type {
  *	Message types for Packet Processing Engine (PPE) requests and responses.
  */
 enum nss_ppe_vp_message_types {
+	NSS_PPE_VP_MSG_CONFIG,
 	NSS_PPE_VP_MSG_SYNC_STATS,
-	NSS_PPE_VP_MSG_DESTROY_NOTIFY,
 	NSS_PPE_VP_MSG_MAX,
 };
 
 /*
+ * nss_ppe_vp_config_msg
+ *	Message to enable/disable VP support for a specific dynamic interface type.
+ */
+struct nss_ppe_vp_config_msg {
+	enum nss_dynamic_interface_type type;	/* Interface type */
+	bool vp_enable;				/* VP support enable */
+};
+
+/*
  * nss_ppe_vp_statistics
  *	Message structure for ppe_vp statistics
  */
 struct nss_ppe_vp_statistics {
 	uint32_t nss_if;			/* NSS interface number corresponding to VP */
-	nss_ppe_port_t ppe_port_num;			/* VP number */
+	uint32_t vp_num;			/* VP number */
 	uint32_t rx_drop;			/* Rx drops due to VP node inactive */
 	uint32_t tx_drop;			/* Tx drops due to VP node inactive */
 	uint32_t packet_big_err;		/* Number of packets not sent to PPE because packet was too large */
@@ -83,42 +91,21 @@ struct nss_ppe_vp_sync_stats_msg {
 };
 
 /*
- * nss_ppe_vp_destroy_notify_msg
- *	Message received as part of destroy notification from Firmware to Host.
- */
-struct nss_ppe_vp_destroy_notify_msg {
-	nss_ppe_port_t ppe_port_num;			/* VP number */
-};
-
-/*
  * nss_ppe_vp_msg
  *	Message for receiving ppe_vp NSS to host messages.
  */
 struct nss_ppe_vp_msg {
-	struct nss_cmn_msg cm;		/* Common message header. */
+	struct nss_cmn_msg cm;		/**< Common message header. */
 
 	/*
 	 * Payload.
 	 */
 	union {
-		union nss_if_msgs if_msg;
-				/* NSS interface base messages. */
+		struct nss_ppe_vp_config_msg vp_config;
+				/**< Enable/disable VP support for specific type */
 		struct nss_ppe_vp_sync_stats_msg stats;
-				/* Synchronization statistics. */
-		struct nss_ppe_vp_destroy_notify_msg destroy_notify;
-				/* Information for the VP destroyed in Firmware. */
-	} msg;			/* Message payload. */
-};
-
-/*
- * nss_vp_mapping
- *	Structure to maintain the one-to-one mapping between the NSS interface number and VP number.
- */
-struct nss_vp_mapping {
-	nss_if_num_t if_num;	/* NSS interface number. */
-	nss_ppe_port_t ppe_port_num;	/* PPE port number corresponding to the NSS interface number. */
-	uint32_t vsi_id;	/* VSI ID allocated for NSS interface */
-	bool vsi_id_valid;	/* Set to true if vsi_id field has a valid VSI else set to false. */
+				/**< Synchronization statistics. */
+	} msg;			/**< Message payload. */
 };
 
 typedef void (*nss_ppe_vp_msg_callback_t)(void *app_data, struct nss_ppe_vp_msg *msg);
--- a/nss_ppe_vp_log.c
+++ b/nss_ppe_vp_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -25,6 +25,15 @@
 #include "nss_ppe_vp.h"
 
 /*
+ * nss_ppe_vp_log_message_types_str
+ *	PPE message strings
+ */
+static int8_t *nss_ppe_vp_log_message_types_str[NSS_PPE_VP_MSG_MAX] __maybe_unused = {
+	"PPE VP Config",
+	"PPE VP Stats",
+};
+
+/*
  * nss_ppe_vp_log_error_response_types_str
  *	Strings for error types for PPE-VP messages
  */
@@ -34,16 +43,15 @@ static int8_t *nss_ppe_vp_log_error_resp
 };
 
 /*
- * nss_ppe_vp_log_destroy_notify_msg()
- *	Log NSS PPE VP destroy notification message.
+ * nss_ppe_vp_log_config_msg()
+ *	Log NSS PPE VP configuration message.
  */
-static void nss_ppe_vp_log_destroy_notify_msg(struct nss_ppe_vp_msg *npvm)
+static void nss_ppe_vp_log_config_msg(struct nss_ppe_vp_msg *npvm)
 {
-	struct nss_ppe_vp_destroy_notify_msg *npdnm __maybe_unused = &npvm->msg.destroy_notify;
-
-	nss_trace("%px: NSS PPE VP destroy notification message:\n"
-			"VP number: %u\n",
-			npdnm, npdnm->ppe_port_num);
+	struct nss_ppe_vp_config_msg *npcm __maybe_unused = &npvm->msg.vp_config;
+	nss_trace("%px: NSS PPE VP configuration message:\n"
+		"Dynamic interface type: %d is_vp_support_enable: %d\n",
+		npcm, npcm->type, npcm->vp_enable);
 }
 
 /*
@@ -53,25 +61,8 @@ static void nss_ppe_vp_log_destroy_notif
 static void nss_ppe_vp_log_verbose(struct nss_ppe_vp_msg *npvm)
 {
 	switch (npvm->cm.type) {
-
-	case NSS_IF_PPE_PORT_CREATE:
-		nss_info("%px: PPE interface create message type:%d\n", npvm, npvm->cm.type);
-		break;
-
-	case NSS_IF_PPE_PORT_DESTROY:
-		nss_info("%px: PPE interface destroy message type:%d\n", npvm, npvm->cm.type);
-		break;
-
-	case NSS_IF_VSI_ASSIGN:
-		nss_info("%px: PPE interface VSI assign message type:%d\n", npvm, npvm->cm.type);
-		break;
-
-	case NSS_IF_VSI_UNASSIGN:
-		nss_info("%px: PPE interface VSI unassign message type:%d\n", npvm, npvm->cm.type);
-		break;
-
-	case NSS_PPE_VP_MSG_DESTROY_NOTIFY:
-		nss_ppe_vp_log_destroy_notify_msg(npvm);
+	case NSS_PPE_VP_MSG_CONFIG:
+		nss_ppe_vp_log_config_msg(npvm);
 		break;
 
 	case NSS_PPE_VP_MSG_SYNC_STATS:
@@ -92,13 +83,12 @@ static void nss_ppe_vp_log_verbose(struc
  */
 void nss_ppe_vp_log_tx_msg(struct nss_ppe_vp_msg *npvm)
 {
-
-	if (!((npvm->cm.type == NSS_IF_PPE_PORT_CREATE) || (npvm->cm.type == NSS_IF_PPE_PORT_DESTROY))) {
+	if (npvm->cm.type >= NSS_PPE_VP_MSG_MAX) {
 		nss_warning("%px: Invalid message type\n", npvm);
 		return;
 	}
 
-	nss_info("%px: type:%d\n", npvm, npvm->cm.type);
+	nss_info("%px: type[%d]:%s\n", npvm, npvm->cm.type, nss_ppe_vp_log_message_types_str[npvm->cm.type]);
 	nss_ppe_vp_log_verbose(npvm);
 }
 
@@ -114,20 +104,23 @@ void nss_ppe_vp_log_rx_msg(struct nss_pp
 	}
 
 	if (npvm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (npvm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%px: type: %d, response[%d]: %s\n", npvm, npvm->cm.type,
+		nss_info("%px: type[%d]:%s, response[%d]:%s\n", npvm, npvm->cm.type,
+			nss_ppe_vp_log_message_types_str[npvm->cm.type],
 			npvm->cm.response, nss_cmn_response_str[npvm->cm.response]);
 		goto verbose;
 	}
 
 	if (npvm->cm.error >= NSS_PPE_VP_MSG_ERROR_TYPE_MAX) {
-		nss_warning("%px: msg failure - type: %d, response[%d]: %s, error[%d]:Invalid error\n",
-			npvm, npvm->cm.type, npvm->cm.response, nss_cmn_response_str[npvm->cm.response],
+		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
+			npvm, npvm->cm.type, nss_ppe_vp_log_message_types_str[npvm->cm.type],
+			npvm->cm.response, nss_cmn_response_str[npvm->cm.response],
 			npvm->cm.error);
 		goto verbose;
 	}
 
-	nss_info("%px: msg nack - type: %d, response[%d]: %s, error[%d]: %s\n",
-		npvm, npvm->cm.type, npvm->cm.response, nss_cmn_response_str[npvm->cm.response],
+	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+		npvm, npvm->cm.type, nss_ppe_vp_log_message_types_str[npvm->cm.type],
+		npvm->cm.response, nss_cmn_response_str[npvm->cm.response],
 		npvm->cm.error, nss_ppe_vp_log_error_response_types_str[npvm->cm.error]);
 
 verbose:
--- a/nss_ppe_vp_stats.c
+++ b/nss_ppe_vp_stats.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -69,7 +69,7 @@ struct nss_stats_info nss_ppe_vp_stats_r
  *	PPE VP statistics strings
  */
 struct nss_stats_info nss_ppe_vp_stats_str[NSS_PPE_VP_STATS_MAX] = {
-	{"ppe_port_num"		, NSS_STATS_TYPE_SPECIAL},
+	{"vp_num"		, NSS_STATS_TYPE_SPECIAL},
 	{"nss_if"		, NSS_STATS_TYPE_SPECIAL},
 	{"rx_packets"		, NSS_STATS_TYPE_COMMON},
 	{"rx_bytes"		, NSS_STATS_TYPE_COMMON},
@@ -109,10 +109,17 @@ void nss_ppe_vp_stats_sync(struct nss_ct
 		count--;
 
 		/*
+		 * If nss interface is changed from previous entry, reset the stats.
+		 */
+		vp_index = stats_msg->vp_stats[count].vp_num - NSS_PPE_VP_START;
+		if (nss_ppe_vp_debug_stats.vp_stats[vp_index].nss_if != stats_msg->vp_stats[count].nss_if) {
+			memset(&nss_ppe_vp_debug_stats.vp_stats[vp_index], 0, sizeof(struct nss_ppe_vp_statistics_debug));
+		}
+
+		/*
 		 * Update stats in global array
 		 */
-		vp_index = stats_msg->vp_stats[count].ppe_port_num - NSS_PPE_VP_START;
-		nss_ppe_vp_debug_stats.vp_stats[vp_index].ppe_port_num = stats_msg->vp_stats[count].ppe_port_num;
+		nss_ppe_vp_debug_stats.vp_stats[vp_index].vp_num = stats_msg->vp_stats[count].vp_num;
 		nss_ppe_vp_debug_stats.vp_stats[vp_index].nss_if = stats_msg->vp_stats[count].nss_if;
 		nss_ppe_vp_debug_stats.vp_stats[vp_index].rx_packets += stats_msg->vp_stats[count].stats.rx_packets;
 		nss_ppe_vp_debug_stats.vp_stats[vp_index].rx_bytes += stats_msg->vp_stats[count].stats.rx_bytes;
@@ -125,8 +132,8 @@ void nss_ppe_vp_stats_sync(struct nss_ct
 			nss_ppe_vp_debug_stats.vp_stats[vp_index].tx_dropped[i] += stats_msg->vp_stats[count].stats.rx_dropped[i];
 		}
 
-		nss_trace("sync count:%d ppe_port_num %d rx_packets %d tx_packets %d\n",
-				count, stats_msg->vp_stats[count].ppe_port_num,
+		nss_trace("sync count:%d vp_num %d rx_packets %d tx_packets %d\n",
+				count, stats_msg->vp_stats[count].vp_num,
 				stats_msg->vp_stats[count].stats.rx_packets,
 				stats_msg->vp_stats[count].stats.tx_packets);
 	}
--- a/nss_ppe_vp_stats.h
+++ b/nss_ppe_vp_stats.h
@@ -28,7 +28,7 @@
  * NSS PPE-VP statistics
  */
 struct nss_ppe_vp_statistics_debug {
-	uint64_t ppe_port_num;			/* VP number */
+	uint64_t vp_num;			/* VP number */
 	uint64_t nss_if;			/* NSS interface number corresponding to VP */
 	uint64_t rx_packets;                    /* Number of packets received. */
 	uint64_t rx_bytes;                    	/* Number of bytes received. */
--- a/nss_pptp.c
+++ b/nss_pptp.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2015-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2015-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -365,7 +365,7 @@ struct nss_ctx_instance *nss_register_pp
 	int i = 0;
 
 	nss_assert(nss_ctx);
-	nss_assert(nss_pptp_verify_if_num(if_num));
+	nss_assert(nss_pptp_verify_if_num());
 
 	nss_ctx->subsys_dp_register[if_num].type = type;
 
--- a/nss_project.c
+++ b/nss_project.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017-2018, 2020-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2018, 2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -21,9 +21,6 @@
 #include "nss_tx_rx_common.h"
 
 static int nss_project_wt_stats_enable;
-static uint8_t nss_project_pri_mq_map[NSS_PROJECT_PRI_MQ_MAP_MAX_SIZE] = {0, 1, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};
-module_param_array(nss_project_pri_mq_map, byte, NULL, 0);
-MODULE_PARM_DESC(nss_project_pri_mq_map, "Priority to multi-queue mapping");
 
 /*
  * nss_project_free_wt_stats()
@@ -267,57 +264,6 @@ static int nss_project_wt_stats_handler(
 }
 
 /*
- * nss_project_pri_mq_map_send_cfg()
- *	Sends message to firmware to configure priority to multi-queue mapping.
- */
-static nss_tx_status_t nss_project_pri_mq_map_send_cfg(struct nss_ctx_instance *nss_ctx)
-{
-	struct nss_project_msg *npm;
-	struct nss_cmn_msg *ncm;
-	nss_tx_status_t ret;
-
-	npm = kzalloc(sizeof(*npm), GFP_ATOMIC);
-	if (!npm) {
-		nss_warning("%px: Failed to allocate buffer for message\n", nss_ctx);
-		return NSS_TX_FAILURE;
-	}
-
-	/*
-	 * Populate the message
-	 */
-	ncm = &npm->cm;
-	nss_cmn_msg_init(ncm, NSS_PROJECT_INTERFACE,
-		NSS_PROJECT_MSG_SET_QUEUE_PRI_MAP_CFG,
-		sizeof(struct nss_project_msg_pri_mq_map_cfg),
-		NULL, NULL);
-	memcpy(npm->msg.pri_mq_map_cfg.pri_mq_map, nss_project_pri_mq_map,
-		sizeof(nss_project_pri_mq_map));
-	ret = nss_core_send_cmd(nss_ctx, npm, sizeof(*npm), NSS_NBUF_PAYLOAD_SIZE);
-	kfree(npm);
-	return ret;
-}
-
-/*
- * nss_project_pri_mq_map_configure()
- * 	API to configure priority to multi-queue mapping.
- */
-nss_tx_status_t nss_project_pri_mq_map_configure(struct nss_ctx_instance *nss_ctx)
-{
-	/*
-	 * Check if multi-queue configuration is enabled.
-	 */
-	if (!nss_core_is_mq_enabled()) {
-		nss_warning("%px: Multi-queue is disabled. Please enable multi-queue before configuring mapping\n", nss_ctx);
-		return NSS_TX_FAILURE_NOT_SUPPORTED;
-	}
-
-	/*
-	 * Send configuration message to NSS.
-	 */
-	return nss_project_pri_mq_map_send_cfg(nss_ctx);
-}
-
-/*
  * Tree of ctl_tables used to put the wt_stats proc node in the correct place in
  * the file system. Allows the command $ echo 1 > proc/sys/dev/nss/project/wt_stats
  * to enable worker thread statistics (echoing 0 into the same target will disable).
--- a/nss_pvxlan.c
+++ b/nss_pvxlan.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -80,22 +80,22 @@ static bool nss_pvxlan_hdl_instance_free
 {
 	struct nss_pvxlan_handle *h;
 
-	spin_lock_bh(&nss_pvxlan_spinlock);
+	spin_lock(&nss_pvxlan_spinlock);
 	h = nss_pvxlan_hdl[if_num - NSS_DYNAMIC_IF_START];
 	if (!h) {
-		spin_unlock_bh(&nss_pvxlan_spinlock);
+		spin_unlock(&nss_pvxlan_spinlock);
 		nss_warning("%px: Instance does not exist: %d", nss_ctx, if_num);
 		return false;
 	}
 
 	if (h->if_num != if_num) {
-		spin_unlock_bh(&nss_pvxlan_spinlock);
+		spin_unlock(&nss_pvxlan_spinlock);
 		nss_warning("%px: Not correct if_num: %d", nss_ctx, if_num);
 		return false;
 	}
 
 	nss_pvxlan_hdl[if_num - NSS_DYNAMIC_IF_START] = NULL;
-	spin_unlock_bh(&nss_pvxlan_spinlock);
+	spin_unlock(&nss_pvxlan_spinlock);
 	kfree(h);
 	return true;
 }
@@ -119,9 +119,9 @@ static bool nss_pvxlan_hdl_instance_allo
 	}
 	h->if_num = if_num;
 
-	spin_lock_bh(&nss_pvxlan_spinlock);
+	spin_lock(&nss_pvxlan_spinlock);
 	if (nss_pvxlan_hdl[if_num - NSS_DYNAMIC_IF_START] != NULL) {
-		spin_unlock_bh(&nss_pvxlan_spinlock);
+		spin_unlock(&nss_pvxlan_spinlock);
 		kfree(h);
 		nss_warning("%px: The handle has been taken by another thread :%d", nss_ctx, if_num);
 		return false;
@@ -130,7 +130,7 @@ static bool nss_pvxlan_hdl_instance_allo
 	h->msg_callback = notify_cb;
 	h->app_data = app_data;
 	nss_pvxlan_hdl[if_num - NSS_DYNAMIC_IF_START] = h;
-	spin_unlock_bh(&nss_pvxlan_spinlock);
+	spin_unlock(&nss_pvxlan_spinlock);
 
 	return true;
 }
@@ -201,13 +201,13 @@ static void nss_pvxlan_msg_handler(struc
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
 		uint32_t if_num = ncm->interface - NSS_DYNAMIC_IF_START;
-		spin_lock_bh(&nss_pvxlan_spinlock);
+		spin_lock(&nss_pvxlan_spinlock);
 		h = nss_pvxlan_hdl[if_num];
 		if (h) {
 			ncm->cb = (nss_ptr_t)h->msg_callback;
 			ncm->app_data = (nss_ptr_t)h->app_data;
 		}
-		spin_unlock_bh(&nss_pvxlan_spinlock);
+		spin_unlock(&nss_pvxlan_spinlock);
 
 	}
 
--- a/nss_qrfs.c
+++ b/nss_qrfs.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017-2021 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -415,65 +415,6 @@ nss_tx_status_t nss_qrfs_set_flow_rule(s
 EXPORT_SYMBOL(nss_qrfs_set_flow_rule);
 
 /*
- * nss_qrfs_configure_flow_rule()
- *	Configures a QRFS flow rule to NSS firmware
- */
-nss_tx_status_t nss_qrfs_configure_flow_rule(uint32_t *dst_addr, uint32_t *src_addr, uint16_t dst_port, uint16_t src_port, uint32_t version, uint16_t proto, uint16_t cpu, enum nss_qrfs_msg_types type) {
-
-        struct nss_qrfs_msg nqm;
-        struct nss_qrfs_flow_rule_msg *nqfrm;
-        nss_tx_status_t status;
-        struct nss_ctx_instance *nss_ctx = NULL;
-	nss_qrfs_msg_callback_t cb = NULL;
-        int i;
-
-
-	memset(&nqm, 0, sizeof(struct nss_qrfs_msg));
-	nss_qrfs_msg_init(&nqm, NSS_QRFS_INTERFACE, type,
-			sizeof(struct nss_qrfs_flow_rule_msg), cb, (void *)nss_ctx);
-	if (type == NSS_QRFS_MSG_FLOW_ADD) {
-                nqfrm = &nqm.msg.flow_add;
-		cb = nss_qrfs_flow_add_msg_callback;
-	} else if (type == NSS_QRFS_MSG_FLOW_DELETE) {
-                nqfrm = &nqm.msg.flow_delete;
-		cb = nss_qrfs_flow_delete_msg_callback;
-	} else {
-		nss_warning("QRFS configure rule failed, not supported message type.\n");
-		return NSS_TX_FAILURE_BAD_PARAM;
-	}
-
-
-	nqfrm->protocol = proto;
-	nqfrm->ip_version = version;
-
-	if (version == 4) {
-		nqfrm->src_addr[0] = src_addr[0];
-		nqfrm->dst_addr[0] = dst_addr[0];
-	} else {
-		memcpy(nqfrm->src_addr, src_addr, sizeof(uint32_t) * 4);
-		memcpy(nqfrm->dst_addr, dst_addr, sizeof(uint32_t) * 4);
-	}
-
-	nqfrm->src_port = src_port;
-        nqfrm->dst_port = dst_port;
-        nqfrm->cpu = cpu;
-	nqfrm->if_num = 0;
-
-        for(i = 0; i < NSS_CORE_MAX; i++) {
-                nss_ctx = nss_qrfs_get_ctx(i);
-                status = nss_qrfs_tx_msg(nss_ctx, &nqm);
-
-		if (status) {
-			nss_warning("%px: QRFS configure rule failed, error code: %d\n", nss_ctx, status);
-			return NSS_TX_FAILURE;
-		}
-        }
-
-	return NSS_TX_SUCCESS;
-}
-EXPORT_SYMBOL(nss_qrfs_configure_flow_rule);
-
-/*
  * nss_qrfs_register_handler()
  */
 void nss_qrfs_register_handler(struct nss_ctx_instance *nss_ctx)
--- a/nss_qvpn.c
+++ b/nss_qvpn.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -16,11 +16,9 @@
 
 #include "nss_tx_rx_common.h"
 #include "nss_qvpn_stats.h"
-#include "nss_qvpn_strings.h"
 #include "nss_qvpn_log.h"
 
 #define NSS_QVPN_TX_TIMEOUT 1000	/* 1 Second */
-#define NSS_QVPN_INTERFACE_MAX_LONG BITS_TO_LONGS(NSS_MAX_NET_INTERFACES)	/**< QVPN interface mapping bits. */
 
 /*
  * Private data structure
@@ -51,6 +49,36 @@ static bool nss_qvpn_verify_if_num(uint3
 }
 
 /*
+ * nss_qvpn_tunnel_stats_sync
+ *	Update qvpn interface statistics.
+ */
+static void nss_qvpn_tunnel_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_cmn_msg *ncm)
+{
+	struct nss_qvpn_msg *ndcm = (struct nss_qvpn_msg *)ncm;
+	struct nss_top_instance *nss_top = nss_ctx->nss_top;
+	struct nss_qvpn_stats_sync_msg  *msg_stats = &ndcm->msg.stats;
+	uint64_t *if_stats;
+
+	spin_lock_bh(&nss_top->stats_lock);
+
+	/*
+	 * Update common node stats
+	 */
+	if_stats = nss_top->stats_node[ncm->interface];
+	if_stats[NSS_STATS_NODE_RX_PKTS] += msg_stats->node_stats.rx_packets;
+	if_stats[NSS_STATS_NODE_RX_BYTES] += msg_stats->node_stats.rx_bytes;
+	if_stats[NSS_STATS_NODE_RX_QUEUE_0_DROPPED] += msg_stats->node_stats.rx_dropped[0];
+	if_stats[NSS_STATS_NODE_RX_QUEUE_1_DROPPED] += msg_stats->node_stats.rx_dropped[1];
+	if_stats[NSS_STATS_NODE_RX_QUEUE_2_DROPPED] += msg_stats->node_stats.rx_dropped[2];
+	if_stats[NSS_STATS_NODE_RX_QUEUE_3_DROPPED] += msg_stats->node_stats.rx_dropped[3];
+
+	if_stats[NSS_STATS_NODE_TX_PKTS] += msg_stats->node_stats.tx_packets;
+	if_stats[NSS_STATS_NODE_TX_BYTES] += msg_stats->node_stats.tx_bytes;
+
+	spin_unlock_bh(&nss_top->stats_lock);
+}
+
+/*
  * nss_qvpn_handler()
  *	Handle NSS to HLOS messages for QVPN
  */
@@ -86,8 +114,7 @@ static void nss_qvpn_handler(struct nss_
 	nss_qvpn_log_rx_msg((struct nss_qvpn_msg *)ncm);
 
 	if (ncm->type == NSS_QVPN_MSG_TYPE_SYNC_STATS) {
-		nss_qvpn_stats_tunnel_sync(nss_ctx, ncm);
-		nss_qvpn_stats_notify(nss_ctx, ncm->interface);
+		nss_qvpn_tunnel_stats_sync(nss_ctx, ncm);
 	}
 
 	/*
@@ -96,7 +123,7 @@ static void nss_qvpn_handler(struct nss_
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
 		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
-		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[ncm->interface].app_data;
+		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[nss_ctx->id][ncm->interface].app_data;
 	}
 
 	/*
@@ -340,5 +367,4 @@ void nss_qvpn_register_handler(void)
 	sema_init(&qvpn_pvt.sem, 1);
 	init_completion(&qvpn_pvt.complete);
 	nss_qvpn_stats_dentry_create();
-	nss_qvpn_strings_dentry_create();
 }
--- a/nss_qvpn_stats.c
+++ b/nss_qvpn_stats.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, 2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -16,38 +16,6 @@
 
 #include "nss_core.h"
 #include <nss_qvpn.h>
-#include "nss_qvpn_stats.h"
-#include "nss_qvpn_strings.h"
-
-/*
- * Declare atomic notifier data structure for statistics.
- */
-ATOMIC_NOTIFIER_HEAD(nss_qvpn_stats_notifier);
-
-/*
- * Spinlock to protect qvpn statistics update/read
- */
-DEFINE_SPINLOCK(nss_qvpn_stats_lock);
-
-uint64_t nss_qvpn_stats[NSS_MAX_NET_INTERFACES][NSS_STATS_NODE_MAX]; /* to store the qvpn statistics */
-
-/*
- * nss_qvpn_stats_iface_type()
- *	Return a string for each interface type.
- */
-static const char *nss_qvpn_stats_iface_type(enum nss_dynamic_interface_type type)
-{
-	switch (type) {
-	case NSS_DYNAMIC_INTERFACE_TYPE_QVPN_INNER:
-		return "qvpn_inner";
-
-	case NSS_DYNAMIC_INTERFACE_TYPE_QVPN_OUTER:
-		return "qvpn_outer";
-
-	default:
-		return "invalid_interface";
-	}
-}
 
 /*
  * nss_qvpn_stats_read()
@@ -55,70 +23,51 @@ static const char *nss_qvpn_stats_iface_
  */
 static ssize_t nss_qvpn_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
 {
-	/*
-	 * Max output lines = #stats +
-	 * few blank lines for banner printing + Number of Extra outputlines
-	 * for future reference to add new stats
-	 */
-	uint32_t max_output_lines = NSS_STATS_NODE_MAX + NSS_STATS_EXTRA_OUTPUT_LINES;
-	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
 	struct nss_ctx_instance *nss_ctx = nss_qvpn_get_context();
 	enum nss_dynamic_interface_type type;
-	unsigned long *ifmap;
-	uint64_t *stats_shadow;
 	ssize_t bytes_read = 0;
-	size_t size_wr = 0;
+	size_t len = 0, size;
 	uint32_t if_num;
-	int32_t i;
-	int count;
-	char *lbuf;
+	unsigned long *ifmap;
+	char *buf;
 
 	ifmap = nss_qvpn_ifmap_get();
-	count = bitmap_weight(ifmap, NSS_MAX_NET_INTERFACES);
-	if (count) {
-		size_al = size_al * count;
-	}
+	size = NSS_QVPN_STATS_SIZE_PER_IF * bitmap_weight(ifmap, NSS_MAX_NET_INTERFACES);
 
-	lbuf = vzalloc(size_al);
-	if (unlikely(!lbuf)) {
-		nss_warning("Could not allocate memory for local statistics buffer");
-		return -ENOMEM;
-	}
-
-	stats_shadow = vzalloc(NSS_STATS_NODE_MAX * 8);
-	if (unlikely(!stats_shadow)) {
-		nss_warning("Could not allocate memory for local shadow buffer");
-		vfree(lbuf);
-		return -ENOMEM;
+	buf = kzalloc(size, GFP_KERNEL);
+	if (!buf) {
+		nss_warning("Could not allocate memory for local statistics buffer\n");
+		return 0;
 	}
 
 	/*
 	 * Common node stats for each QVPN dynamic interface.
 	 */
-	size_wr += nss_stats_banner(lbuf, size_wr, size_al, "qvpn stats", NSS_STATS_SINGLE_CORE);
+	len += nss_stats_banner(buf, len, size, "qvpn", NSS_STATS_SINGLE_CORE);
 	for_each_set_bit(if_num, ifmap, NSS_MAX_NET_INTERFACES) {
-
 		type = nss_dynamic_interface_get_type(nss_ctx, if_num);
-		if ((type != NSS_DYNAMIC_INTERFACE_TYPE_QVPN_INNER) &&
-			(type != NSS_DYNAMIC_INTERFACE_TYPE_QVPN_OUTER)) {
-			continue;
-		}
 
-		spin_lock_bh(&nss_qvpn_stats_lock);
-		for (i = 0; i < NSS_STATS_NODE_MAX; i++) {
-			stats_shadow[i] = nss_qvpn_stats[if_num][i];
+		switch (type) {
+		case NSS_DYNAMIC_INTERFACE_TYPE_QVPN_INNER:
+			len += scnprintf(buf + len, size - len, "\nInner if_num:%03u", if_num);
+			break;
+
+		case NSS_DYNAMIC_INTERFACE_TYPE_QVPN_OUTER:
+			len += scnprintf(buf + len, size - len, "\nOuter if_num:%03u", if_num);
+			break;
+
+		default:
+			len += scnprintf(buf + len, size - len, "\nUnknown(%d) if_num:%03u", type, if_num);
+			break;
 		}
-		spin_unlock_bh(&nss_qvpn_stats_lock);
 
-		size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\n%s if_num:%03u\n",
-					nss_qvpn_stats_iface_type(type), if_num);
-		size_wr += nss_stats_print("qvpn", NULL, NSS_STATS_SINGLE_INSTANCE, nss_qvpn_strings_stats,
-						stats_shadow, NSS_STATS_NODE_MAX, lbuf, size_wr, size_al);
+		len += scnprintf(buf + len, size - len, "\n-------------------\n");
+		len += nss_stats_fill_common_stats(if_num, NSS_STATS_SINGLE_INSTANCE, buf, len, size - len, "qvpn");
 	}
 
-	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
-	vfree(lbuf);
-	vfree(stats_shadow);
+	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, buf, len);
+	kfree(buf);
+
 	return bytes_read;
 }
 
@@ -128,72 +77,6 @@ static ssize_t nss_qvpn_stats_read(struc
 NSS_STATS_DECLARE_FILE_OPERATIONS(qvpn)
 
 /*
- * nss_qvpn_stats_tunnel_sync
- *	Update qvpn interface statistics.
- */
-void nss_qvpn_stats_tunnel_sync(struct nss_ctx_instance *nss_ctx, struct nss_cmn_msg *ncm)
-{
-	struct nss_qvpn_msg *ndcm = (struct nss_qvpn_msg *)ncm;
-	struct nss_qvpn_stats_sync_msg  *msg_stats = &ndcm->msg.stats;
-
-	spin_lock_bh(&nss_qvpn_stats_lock);
-
-	/*
-	 * Update common node stats
-	 */
-	nss_qvpn_stats[ncm->interface][NSS_STATS_NODE_RX_PKTS] += msg_stats->node_stats.rx_packets;
-	nss_qvpn_stats[ncm->interface][NSS_STATS_NODE_RX_BYTES] += msg_stats->node_stats.rx_bytes;
-	nss_qvpn_stats[ncm->interface][NSS_STATS_NODE_RX_QUEUE_0_DROPPED] += msg_stats->node_stats.rx_dropped[0];
-	nss_qvpn_stats[ncm->interface][NSS_STATS_NODE_RX_QUEUE_1_DROPPED] += msg_stats->node_stats.rx_dropped[1];
-	nss_qvpn_stats[ncm->interface][NSS_STATS_NODE_RX_QUEUE_2_DROPPED] += msg_stats->node_stats.rx_dropped[2];
-	nss_qvpn_stats[ncm->interface][NSS_STATS_NODE_RX_QUEUE_3_DROPPED] += msg_stats->node_stats.rx_dropped[3];
-
-	nss_qvpn_stats[ncm->interface][NSS_STATS_NODE_TX_PKTS] += msg_stats->node_stats.tx_packets;
-	nss_qvpn_stats[ncm->interface][NSS_STATS_NODE_TX_BYTES] += msg_stats->node_stats.tx_bytes;
-
-	spin_unlock_bh(&nss_qvpn_stats_lock);
-}
-
-/*
- * nss_qvpn_stats_notify()
- *	Sends notifications to all the registered modules.
- *
- * Leverage NSS-FW statistics timing to update Netlink.
- */
-void nss_qvpn_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num)
-{
-	struct nss_qvpn_stats_notification qvpn_stats;
-
-	spin_lock_bh(&nss_qvpn_stats_lock);
-	qvpn_stats.core_id = nss_ctx->id;
-	qvpn_stats.if_num = if_num;
-	memcpy(qvpn_stats.stats_ctx, nss_qvpn_stats[if_num], sizeof(qvpn_stats.stats_ctx));
-	spin_unlock_bh(&nss_qvpn_stats_lock);
-
-	atomic_notifier_call_chain(&nss_qvpn_stats_notifier, NSS_STATS_EVENT_NOTIFY, &qvpn_stats);
-}
-
-/*
- * nss_qvpn_stats_unregister_notifier()
- *	Deregisters statistics notifier.
- */
-int nss_qvpn_stats_unregister_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_unregister(&nss_qvpn_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_qvpn_stats_unregister_notifier);
-
-/*
- * nss_qvpn_stats_register_notifier()
- *	Registers statistics notifier.
- */
-int nss_qvpn_stats_register_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_register(&nss_qvpn_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_qvpn_stats_register_notifier);
-
-/*
  * nss_qvpn_stats_dentry_create()
  *	Create QVPN statistics debug entry.
  */
--- a/nss_qvpn_stats.h
+++ b/nss_qvpn_stats.h
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019, 2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -17,8 +17,10 @@
 #ifndef _NSS_QVPN_STATS_H_
 #define _NSS_QVPN_STATS_H_
 
-extern void nss_qvpn_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num);
-extern void nss_qvpn_stats_tunnel_sync(struct nss_ctx_instance *nss_ctx, struct nss_cmn_msg *ncm);
-extern void nss_qvpn_stats_dentry_create(void);
+/*
+ * nss_qvpn_stats_dentry_create
+ *	Creates QVPN interface statistics debug entry.
+ */
+void nss_qvpn_stats_dentry_create(void);
 
 #endif /* _NSS_QVPN_STATS_H_ */
--- a/nss_qvpn_strings.c
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- *****************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- *****************************************************************************
- */
-
-#include "nss_stats.h"
-#include "nss_core.h"
-#include "nss_strings.h"
-#include "nss_qvpn_strings.h"
-
-/*
- * nss_qvpn_strings_stats
- *	qvpn statistics strings.
- */
-struct nss_stats_info nss_qvpn_strings_stats[NSS_STATS_NODE_MAX] = {
-	{"rx_pkts",                     NSS_STATS_TYPE_COMMON},
-	{"rx_byts",                     NSS_STATS_TYPE_COMMON},
-	{"tx_pkts",                     NSS_STATS_TYPE_COMMON},
-	{"tx_byts",                     NSS_STATS_TYPE_COMMON},
-	{"rx_queue[0]_drops",           NSS_STATS_TYPE_DROP},
-	{"rx_queue[1]_drops",           NSS_STATS_TYPE_DROP},
-	{"rx_queue[2]_drops",           NSS_STATS_TYPE_DROP},
-	{"rx_queue[3]_drops",           NSS_STATS_TYPE_DROP}
-};
-
-/*
- * nss_qvpn_strings_read()
- *	Read qvpn statistics names
- */
-static ssize_t nss_qvpn_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_qvpn_strings_stats, NSS_STATS_NODE_MAX);
-}
-
-/*
- * nss_qvpn_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(qvpn);
-
-/*
- * nss_qvpn_strings_dentry_create()
- *	Create qvpn statistics strings debug entry.
- */
-void nss_qvpn_strings_dentry_create(void)
-{
-	nss_strings_create_dentry("qvpn", &nss_qvpn_strings_ops);
-}
--- a/nss_qvpn_strings.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- ****************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ****************************************************************************
- */
-
-#ifndef __NSS_QVPN_STRINGS_H
-#define __NSS_QVPN_STRINGS_H
-
-#include "nss_qvpn_stats.h"
-
-extern struct nss_stats_info nss_qvpn_strings_stats[NSS_STATS_NODE_MAX];
-extern void nss_qvpn_strings_dentry_create(void);
-
-#endif /* __NSS_QVPN_STRINGS_H */
--- a/nss_rmnet_rx.c
+++ b/nss_rmnet_rx.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -29,7 +29,7 @@
 #define NSS_RMNET_RX_GET_INDEX(if_num)	(if_num - NSS_DYNAMIC_IF_START)
 
 /*
- * Spinlock to protect the global data structure rmnet handle.
+ * Spinlock to protect the global data structure virt_handle.
  */
 DEFINE_SPINLOCK(nss_rmnet_rx_lock);
 
@@ -243,8 +243,6 @@ static int nss_rmnet_rx_handle_destroy_s
 	rmnet_rx_handle[index_h2n] = NULL;
 	spin_unlock_bh(&nss_rmnet_rx_lock);
 
-	kfree(handle->stats_h2n);
-	kfree(handle->stats_n2h);
 	kfree(handle->pvt);
 	kfree(handle);
 
@@ -527,27 +525,6 @@ error1:
 EXPORT_SYMBOL(nss_rmnet_rx_create_sync_nexthop);
 
 /*
- * nss_rmnet_rx_create()
- *	Create rmnet_n2h and rmnet_h2n interfaces with generic next hops and associate it with same netdev.
- *
- * When rmnet and eth_rx is running at the same core, we directly send packets to eth_rx node.
- * When they are running at different cores, the packets needs to arrive eth_rx through C2C.
- */
-struct nss_rmnet_rx_handle *nss_rmnet_rx_create(struct net_device *netdev)
-{
-	uint32_t nexthop_n2h = NSS_N2H_INTERFACE;
-	uint32_t nexthop_h2n = NSS_C2C_TX_INTERFACE;
-
-	if (nss_top_main.rmnet_rx_handler_id == 0) {
-		nexthop_h2n = NSS_ETH_RX_INTERFACE;
-	}
-
-
-	return nss_rmnet_rx_create_sync_nexthop(netdev, nexthop_n2h, nexthop_h2n);
-}
-EXPORT_SYMBOL(nss_rmnet_rx_create);
-
-/*
  * nss_rmnet_rx_tx_buf()
  *	HLOS interface has received a packet which we redirect to the NSS, if appropriate to do so.
  */
--- a/nss_rps.c
+++ b/nss_rps.c
@@ -1,12 +1,9 @@
 /*
  **************************************************************************
- * Copyright (c) 2013-2017, 2019-2021 The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
- *
+ * Copyright (c) 2013-2017, 2019-2020 The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
- *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -281,7 +278,6 @@ static nss_tx_status_t nss_rps_cfg(struc
 	return NSS_SUCCESS;
 }
 
-#ifdef NSS_DRV_IPV4_ENABLE
 /*
  * nss_rps_ipv4_hash_bitmap_cfg()
  *	Send Message to NSS to configure hash_bitmap.
@@ -310,9 +306,7 @@ static nss_tx_status_t nss_rps_ipv4_hash
 	up(&nss_rps_cfg_pvt.sem);
 	return NSS_SUCCESS;
 }
-#endif
 
-#ifdef NSS_DRV_IPV6_ENABLE
 /*
  * nss_rps_ipv6_hash_bitmap_cfg()
  *	Send Message to NSS to configure hash_bitmap.
@@ -341,7 +335,6 @@ static nss_tx_status_t nss_rps_ipv6_hash
 	up(&nss_rps_cfg_pvt.sem);
 	return NSS_SUCCESS;
 }
-#endif
 
 /*
  * nss_rps_pri_map_cfg()
@@ -461,8 +454,8 @@ static int nss_rps_hash_bitmap_cfg_handl
 				void __user *buffer, size_t *lenp, loff_t *ppos)
 {
 	struct nss_top_instance *nss_top = &nss_top_main;
-	struct nss_ctx_instance *nss_ctx __attribute__((unused)) = &nss_top->nss[0];
-	int ret, current_state;
+	struct nss_ctx_instance *nss_ctx = &nss_top->nss[0];
+	int ret, ret_ipv4, ret_ipv6, current_state;
 
 	current_state = nss_rps_hash_bitmap;
 	ret = proc_dointvec(ctl, write, buffer, lenp, ppos);
@@ -476,45 +469,32 @@ static int nss_rps_hash_bitmap_cfg_handl
 		return ret;
 	}
 
-#if !defined(NSS_DRV_IPV4_ENABLE) || !defined(NSS_DRV_IPV6_ENABLE)
-	nss_info_always("%px: Feature is not supported\n", nss_ctx);
-	return 0;
-#else
 	if (nss_rps_hash_bitmap <= (NSS_RPS_MAX_CORE_HASH_BITMAP)) {
 		nss_info("Configuring NSS RPS hash_bitmap\n");
-#ifdef NSS_DRV_IPV4_ENABLE
-		{
-			int ret_ipv4;
-			ret_ipv4 = nss_rps_ipv4_hash_bitmap_cfg(nss_ctx, nss_rps_hash_bitmap);
-
-			if (ret_ipv4 != NSS_SUCCESS) {
-				nss_warning("%px: ipv4 hash_bitmap config message failed\n", nss_ctx);
-				nss_rps_hash_bitmap = current_state;
-				return ret_ipv4;
-			}
+		ret_ipv4 = nss_rps_ipv4_hash_bitmap_cfg(nss_ctx, nss_rps_hash_bitmap);
+
+		if (ret_ipv4 != NSS_SUCCESS) {
+			nss_warning("%px: ipv4 hash_bitmap config message failed\n", nss_ctx);
+			nss_rps_hash_bitmap = current_state;
+			return ret_ipv4;
 		}
-#endif
-#ifdef NSS_DRV_IPV6_ENABLE
-		{
-			int ret_ipv6;
-			ret_ipv6 = nss_rps_ipv6_hash_bitmap_cfg(nss_ctx, nss_rps_hash_bitmap);
-
-			if (ret_ipv6 != NSS_SUCCESS) {
-				nss_warning("%px: ipv6 hash_bitmap config message failed\n", nss_ctx);
-				nss_rps_hash_bitmap = current_state;
-				if (nss_rps_ipv4_hash_bitmap_cfg(nss_ctx, nss_rps_hash_bitmap != NSS_SUCCESS)) {
-					nss_warning("%px: ipv4 and ipv6 have different hash_bitmaps.\n", nss_ctx);
-				}
-				return ret_ipv6;
+
+		ret_ipv6 = nss_rps_ipv6_hash_bitmap_cfg(nss_ctx, nss_rps_hash_bitmap);
+
+		if (ret_ipv6 != NSS_SUCCESS) {
+			nss_warning("%px: ipv6 hash_bitmap config message failed\n", nss_ctx);
+			nss_rps_hash_bitmap = current_state;
+			if (nss_rps_ipv4_hash_bitmap_cfg(nss_ctx, nss_rps_hash_bitmap != NSS_SUCCESS)) {
+				nss_warning("%px: ipv4 and ipv6 have different hash_bitmaps.\n", nss_ctx);
 			}
+			return ret_ipv6;
 		}
-#endif
+
 		return 0;
 	}
 
 	nss_info_always("Invalid input value. Valid values are less than %d\n", (NSS_RPS_MAX_CORE_HASH_BITMAP));
 	return ret;
-#endif
 }
 
 /* nss_rps_pri_map_cfg_handler()
--- a/nss_stats.c
+++ b/nss_stats.c
@@ -1,12 +1,9 @@
 /*
  **************************************************************************
  * Copyright (c) 2013-2020, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
- *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
- *
  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
@@ -392,9 +389,7 @@ void nss_stats_create_dentry(char *name,
 /*
  * gmac_stats_ops
  */
-#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 NSS_STATS_DECLARE_FILE_OPERATIONS(gmac);
-#endif
 
 /*
  * wt_stats_ops
@@ -449,9 +444,7 @@ void nss_stats_init(void)
 	/*
 	 * gmac_stats
 	 */
-#ifdef NSS_DATA_PLANE_GENERIC_SUPPORT
 	nss_stats_create_dentry("gmac", &nss_gmac_stats_ops);
-#endif
 
 	/*
 	 * Per-project stats
--- a/nss_tls.c
+++ b/nss_tls.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2020-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -18,10 +18,10 @@
 
 #include "nss_tx_rx_common.h"
 #include "nss_tls_log.h"
-#include "nss_tls_stats.h"
-#include "nss_tls_strings.h"
 
 #define NSS_TLS_INTERFACE_MAX_LONG BITS_TO_LONGS(NSS_MAX_NET_INTERFACES)
+#define NSS_TLS_STATS_MAX_LINES (NSS_STATS_NODE_MAX + 32)
+#define NSS_TLS_STATS_SIZE_PER_IF (NSS_STATS_MAX_STR_LENGTH * NSS_TLS_STATS_MAX_LINES)
 #define NSS_TLS_TX_TIMEOUT 3000 /* 3 Seconds */
 
 /*
@@ -35,6 +35,93 @@ static struct nss_tls_pvt {
 } tls_pvt;
 
 /*
+ * nss_tls_stats_sync()
+ *	Update tls node statistics.
+ */
+static void nss_tls_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_cmn_msg *ncm)
+{
+	struct nss_tls_msg *ndcm = (struct nss_tls_msg *)ncm;
+	struct nss_top_instance *nss_top = nss_ctx->nss_top;
+	struct nss_tls_ctx_stats *msg_stats = &ndcm->msg.stats;
+	uint64_t *if_stats;
+	int i;
+
+	spin_lock_bh(&nss_top->stats_lock);
+
+	/*
+	 * Update common node stats,
+	 * Note: TLS only supports a single queue for RX
+	 */
+	if_stats = nss_top->stats_node[ncm->interface];
+	if_stats[NSS_STATS_NODE_RX_PKTS] += msg_stats->pkt.rx_packets;
+	if_stats[NSS_STATS_NODE_RX_BYTES] += msg_stats->pkt.rx_bytes;
+
+	for (i = 0; i < NSS_MAX_NUM_PRI; i++)
+		if_stats[NSS_STATS_NODE_RX_QUEUE_0_DROPPED + i] += msg_stats->pkt.rx_dropped[i];
+
+	if_stats[NSS_STATS_NODE_TX_PKTS] += msg_stats->pkt.tx_packets;
+	if_stats[NSS_STATS_NODE_TX_BYTES] += msg_stats->pkt.tx_bytes;
+
+	spin_unlock_bh(&nss_top->stats_lock);
+}
+
+/*
+ * nss_tls_stats_read()
+ *	Read tls node statiistics.
+ */
+static ssize_t nss_tls_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
+{
+	struct nss_ctx_instance *nss_ctx = nss_tls_get_context();
+	enum nss_dynamic_interface_type type;
+	ssize_t bytes_read = 0;
+	size_t len = 0, size;
+	uint32_t if_num;
+	char *buf;
+
+	size = NSS_TLS_STATS_SIZE_PER_IF * bitmap_weight(tls_pvt.if_map, NSS_MAX_NET_INTERFACES);
+
+	buf = kzalloc(size, GFP_KERNEL);
+	if (!buf) {
+		nss_warning("Could not allocate memory for local statistics buffer");
+		return 0;
+	}
+
+	/*
+	 * Common node stats for each TLS dynamic interface.
+	 */
+	for_each_set_bit(if_num, tls_pvt.if_map, NSS_MAX_NET_INTERFACES) {
+		type = nss_dynamic_interface_get_type(nss_ctx, if_num);
+
+		switch (type) {
+		case NSS_DYNAMIC_INTERFACE_TYPE_TLS_INNER:
+			len += scnprintf(buf + len, size - len, "\nInner if_num:%03u", if_num);
+			break;
+
+		case NSS_DYNAMIC_INTERFACE_TYPE_TLS_OUTER:
+			len += scnprintf(buf + len, size - len, "\nOuter if_num:%03u", if_num);
+			break;
+
+		default:
+			len += scnprintf(buf + len, size - len, "\nUnknown(%d) if_num:%03u", type, if_num);
+			break;
+		}
+
+		len += scnprintf(buf + len, size - len, "\n-------------------\n");
+		len = nss_stats_fill_common_stats(if_num, NSS_STATS_SINGLE_INSTANCE, buf, len, size - len, "tls");
+	}
+
+	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, buf, len);
+	kfree(buf);
+
+	return bytes_read;
+}
+
+/*
+ * nss_tls_stats_ops
+ */
+NSS_STATS_DECLARE_FILE_OPERATIONS(tls)
+
+/*
  * nss_tls_verify_ifnum()
  *	Verify if the interface number is a TLS interface.
  */
@@ -80,17 +167,15 @@ static void nss_tls_handler(struct nss_c
 		return;
 	}
 
-	if (ncm->type == NSS_TLS_MSG_TYPE_CTX_SYNC) {
+	if (ncm->type == NSS_TLS_MSG_TYPE_CTX_SYNC)
 		nss_tls_stats_sync(nss_ctx, ncm);
-		nss_tls_stats_notify(nss_ctx, ncm->interface);
-	}
 
 	/*
 	 * Update the callback and app_data for NOTIFY messages
 	 */
 	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
 		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
-		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[ncm->interface].app_data;
+		ncm->app_data = (nss_ptr_t)nss_ctx->nss_rx_interface_handlers[nss_ctx->id][ncm->interface].app_data;
 	}
 
 	/*
@@ -144,15 +229,6 @@ static void nss_tls_sync_resp(void *app_
 }
 
 /*
- * nss_tls_ifmap_get()
- *	Return TLS active interfaces map.
- */
-unsigned long *nss_tls_ifmap_get(void)
-{
-	return tls_pvt.if_map;
-}
-
-/*
  * nss_tls_tx_buf()
  *	Transmit buffer over TLS interface
  */
@@ -470,6 +546,5 @@ void nss_tls_register_handler(void)
 {
 	sema_init(&tls_pvt.sem, 1);
 	init_completion(&tls_pvt.complete);
-	nss_tls_stats_dentry_create();
-	nss_tls_strings_dentry_create();
+	nss_stats_create_dentry("tls", &nss_tls_stats_ops);
 }
--- a/nss_tls_stats.c
+++ /dev/null
@@ -1,206 +0,0 @@
-/*
- ******************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ******************************************************************************
- */
-
-#include "nss_core.h"
-#include "nss_tls.h"
-#include "nss_tls_stats.h"
-#include "nss_tls_strings.h"
-
-/*
- * Declare atomic notifier data structure for statistics.
- */
-ATOMIC_NOTIFIER_HEAD(nss_tls_stats_notifier);
-
-/*
- * Spinlock to protect tls statistics update/read
- */
-DEFINE_SPINLOCK(nss_tls_stats_lock);
-
-uint64_t nss_tls_stats[NSS_MAX_NET_INTERFACES][NSS_TLS_STATS_MAX];
-
-/*
- * nss_tls_stats_iface_type()
- *	Return a string for each interface type.
- */
-static const char *nss_tls_stats_iface_type(enum nss_dynamic_interface_type type)
-{
-	switch (type) {
-	case NSS_DYNAMIC_INTERFACE_TYPE_TLS_INNER:
-		return "tls_inner";
-
-	case NSS_DYNAMIC_INTERFACE_TYPE_TLS_OUTER:
-		return "tls_outer";
-
-	default:
-		return "invalid_interface";
-	}
-}
-
-/*
- * nss_tls_stats_read()
- *	Read tls node statiistics.
- */
-static ssize_t nss_tls_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	/*
-	 * Max output lines = #stats +
-	 * few blank lines for banner printing + Number of Extra outputlines
-	 * for future reference to add new stats
-	 */
-	uint32_t max_output_lines = NSS_TLS_STATS_MAX + NSS_STATS_EXTRA_OUTPUT_LINES;
-	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
-	struct nss_ctx_instance *nss_ctx = nss_tls_get_context();
-	enum nss_dynamic_interface_type type;
-	unsigned long *ifmap;
-	uint64_t *stats_shadow;
-	ssize_t bytes_read = 0;
-	size_t size_wr = 0;
-	uint32_t if_num;
-	int32_t i;
-	int count;
-	char *lbuf;
-
-	ifmap = nss_tls_ifmap_get();
-	count = bitmap_weight(ifmap, NSS_MAX_NET_INTERFACES);
-	if (count) {
-		size_al = size_al * count;
-	}
-
-	lbuf = vzalloc(size_al);
-	if (unlikely(!lbuf)) {
-		nss_warning("Could not allocate memory for local statistics buffer");
-		return -ENOMEM;
-	}
-
-	stats_shadow = vzalloc(NSS_TLS_STATS_MAX * 8);
-	if (unlikely(!stats_shadow)) {
-		nss_warning("Could not allocate memory for local shadow buffer");
-		vfree(lbuf);
-		return -ENOMEM;
-	}
-
-	/*
-	 * Common node stats for each TLS dynamic interface.
-	 */
-	size_wr += nss_stats_banner(lbuf, size_wr, size_al, "tls stats", NSS_STATS_SINGLE_CORE);
-	for_each_set_bit(if_num, ifmap, NSS_MAX_NET_INTERFACES) {
-
-		type = nss_dynamic_interface_get_type(nss_ctx, if_num);
-		if ((type != NSS_DYNAMIC_INTERFACE_TYPE_TLS_INNER) &&
-			(type != NSS_DYNAMIC_INTERFACE_TYPE_TLS_OUTER)) {
-			continue;
-		}
-
-		spin_lock_bh(&nss_tls_stats_lock);
-		for (i = 0; i < NSS_TLS_STATS_MAX; i++) {
-			stats_shadow[i] = nss_tls_stats[if_num][i];
-		}
-		spin_unlock_bh(&nss_tls_stats_lock);
-
-		size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\n%s if_num:%03u\n",
-					nss_tls_stats_iface_type(type), if_num);
-		size_wr += nss_stats_print("tls", NULL, NSS_STATS_SINGLE_INSTANCE, nss_tls_strings_stats,
-						stats_shadow, NSS_TLS_STATS_MAX, lbuf, size_wr, size_al);
-	}
-
-	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
-	vfree(lbuf);
-	vfree(stats_shadow);
-	return bytes_read;
-}
-
-/*
- * nss_tls_stats_ops
- */
-NSS_STATS_DECLARE_FILE_OPERATIONS(tls);
-
-/*
- * nss_tls_stats_dentry_create()
- *	Create tls statistics debug entry.
- */
-void nss_tls_stats_dentry_create(void)
-{
-	nss_stats_create_dentry("tls", &nss_tls_stats_ops);
-}
-
-/*
- * nss_tls_stats_sync()
- *	Update tls node statistics.
- */
-void nss_tls_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_cmn_msg *ncm)
-{
-	struct nss_tls_msg *ndcm = (struct nss_tls_msg *)ncm;
-	struct nss_tls_ctx_stats *ndccs = &ndcm->msg.stats;
-	uint64_t *ctx_stats;
-	uint32_t *msg_stats;
-	int i;
-
-	spin_lock_bh(&nss_tls_stats_lock);
-
-	/*
-	 * Update common node stats,
-	 * Note: TLS only supports a single queue for RX
-	 */
-	msg_stats = (uint32_t *)ndccs;
-	ctx_stats = nss_tls_stats[ncm->interface];
-
-	for (i = 0; i < NSS_TLS_STATS_MAX; i++, ctx_stats++, msg_stats++) {
-		*ctx_stats += *msg_stats;
-	}
-
-	spin_unlock_bh(&nss_tls_stats_lock);
-}
-
-/*
- * nss_tls_stats_notify()
- *	Sends notifications to all the registered modules.
- *
- * Leverage NSS-FW statistics timing to update Netlink.
- */
-void nss_tls_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num)
-{
-	struct nss_tls_stats_notification tls_stats;
-
-	spin_lock_bh(&nss_tls_stats_lock);
-	tls_stats.core_id = nss_ctx->id;
-	tls_stats.if_num = if_num;
-	memcpy(tls_stats.stats_ctx, nss_tls_stats[if_num], sizeof(tls_stats.stats_ctx));
-	spin_unlock_bh(&nss_tls_stats_lock);
-
-	atomic_notifier_call_chain(&nss_tls_stats_notifier, NSS_STATS_EVENT_NOTIFY, &tls_stats);
-}
-
-/*
- * nss_tls_stats_unregister_notifier()
- *	Deregisters statistics notifier.
- */
-int nss_tls_stats_unregister_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_unregister(&nss_tls_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_tls_stats_unregister_notifier);
-
-/*
- * nss_tls_stats_register_notifier()
- *	Registers statistics notifier.
- */
-int nss_tls_stats_register_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_register(&nss_tls_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_tls_stats_register_notifier);
--- a/nss_tls_stats.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- ******************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ******************************************************************************
- */
-
-#ifndef __NSS_TLS_STATS_H
-#define __NSS_TLS_STATS_H
-
-#include <nss_cmn.h>
-
-extern void nss_tls_stats_notify(struct nss_ctx_instance *nss_ctx, uint32_t if_num);
-extern void nss_tls_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_cmn_msg *ncm);
-extern void nss_tls_stats_dentry_create(void);
-
-#endif /* __NSS_TLS_STATS_H */
--- a/nss_tls_strings.c
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- ******************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ******************************************************************************
- */
-
-#include "nss_stats.h"
-#include "nss_core.h"
-#include "nss_strings.h"
-#include "nss_tls_strings.h"
-
-/*
- * nss_tls_strings_stats
- *	tls statistics strings.
- */
-struct nss_stats_info nss_tls_strings_stats[NSS_TLS_STATS_MAX] = {
-	{"rx_pkts",			NSS_STATS_TYPE_COMMON},
-	{"rx_byts",			NSS_STATS_TYPE_COMMON},
-	{"tx_pkts",			NSS_STATS_TYPE_COMMON},
-	{"tx_byts",			NSS_STATS_TYPE_COMMON},
-	{"rx_queue[0]_drops",		NSS_STATS_TYPE_DROP},
-	{"rx_queue[1]_drops",		NSS_STATS_TYPE_DROP},
-	{"rx_queue[2]_drops",		NSS_STATS_TYPE_DROP},
-	{"rx_queue[3]_drops",		NSS_STATS_TYPE_DROP},
-	{"single_rec",			NSS_STATS_TYPE_SPECIAL},
-	{"multi_rec",			NSS_STATS_TYPE_SPECIAL},
-	{"tx_inval_reqs",		NSS_STATS_TYPE_SPECIAL},
-	{"rx_ccs_rec",			NSS_STATS_TYPE_SPECIAL},
-	{"fail_ccs",			NSS_STATS_TYPE_ERROR},
-	{"eth_node_deactive",		NSS_STATS_TYPE_SPECIAL},
-	{"crypto_alloc_success",	NSS_STATS_TYPE_SPECIAL},
-	{"crypto_free_req",		NSS_STATS_TYPE_SPECIAL},
-	{"crypto_free_success",		NSS_STATS_TYPE_SPECIAL},
-	{"fail_crypto_alloc",		NSS_STATS_TYPE_EXCEPTION},
-	{"fail_crypto_lookup",		NSS_STATS_TYPE_EXCEPTION},
-	{"fail_req_alloc",		NSS_STATS_TYPE_ERROR},
-	{"fail_pbuf_stats",		NSS_STATS_TYPE_ERROR},
-	{"fail_ctx_active",		NSS_STATS_TYPE_ERROR},
-	{"hw_len_error",		NSS_STATS_TYPE_ERROR},
-	{"hw_token_error",		NSS_STATS_TYPE_ERROR},
-	{"hw_bypass_error",		NSS_STATS_TYPE_ERROR},
-	{"hw_crypto_error",		NSS_STATS_TYPE_ERROR},
-	{"hw_hash_error",		NSS_STATS_TYPE_ERROR},
-	{"hw_config_error",		NSS_STATS_TYPE_ERROR},
-	{"hw_algo_error",		NSS_STATS_TYPE_ERROR},
-	{"hw_hash_ovf_error",		NSS_STATS_TYPE_ERROR},
-	{"hw_auth_error",		NSS_STATS_TYPE_ERROR},
-	{"hw_pad_verify_error",		NSS_STATS_TYPE_ERROR},
-	{"hw_timeout_error",		NSS_STATS_TYPE_ERROR},
-	{"no_desc_in",			NSS_STATS_TYPE_EXCEPTION},
-	{"no_desc_out",			NSS_STATS_TYPE_EXCEPTION},
-	{"no_reqs",			NSS_STATS_TYPE_EXCEPTION}
-};
-
-/*
- * nss_tls_strings_read()
- *	Read tls statistics names
- */
-static ssize_t nss_tls_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_tls_strings_stats, NSS_TLS_STATS_MAX);
-}
-
-/*
- * nss_tls_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(tls);
-
-/*
- * nss_tls_strings_dentry_create()
- *	Create tls statistics strings debug entry.
- */
-void nss_tls_strings_dentry_create(void)
-{
-	nss_strings_create_dentry("tls", &nss_tls_strings_ops);
-}
--- a/nss_trustsec_rx.c
+++ /dev/null
@@ -1,214 +0,0 @@
-/*
- * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-#include "nss_tx_rx_common.h"
-#include "nss_trustsec_rx_stats.h"
-#include "nss_trustsec_rx_log.h"
-
-#define NSS_TRUSTSEC_RX_TIMEOUT 3000 /* 3 Seconds */
-
-/*
- * Private data structure for trustsec_rx interface
- */
-static struct nss_trustsec_rx_pvt {
-	struct semaphore sem;
-	struct completion complete;
-	int response;
-} ttx;
-
-/*
- * nss_trustsec_rx_handler()
- *	Handle NSS -> HLOS messages for trustsec_rx
- */
-static void nss_trustsec_rx_handler(struct nss_ctx_instance *nss_ctx, struct nss_cmn_msg *ncm,
-				__attribute__((unused))void *app_data)
-{
-	nss_trustsec_rx_msg_callback_t cb;
-	struct nss_trustsec_rx_msg *msg = (struct nss_trustsec_rx_msg *)ncm;
-
-	BUG_ON(ncm->interface != NSS_TRUSTSEC_RX_INTERFACE);
-
-	/*
-	 * Trace messages.
-	 */
-	nss_trustsec_rx_log_rx_msg(msg);
-
-	/*
-	 * Is this a valid request/response packet?
-	 */
-	if (ncm->type >= NSS_TRUSTSEC_RX_MSG_MAX) {
-		nss_warning("%px: received invalid message %d for trustsec_rx interface", nss_ctx, ncm->type);
-		return;
-	}
-
-	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_trustsec_rx_msg)) {
-		nss_warning("%px: message size incorrect: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
-		return;
-	}
-
-	/*
-	 * Log failures
-	 */
-	nss_core_log_msg_failures(nss_ctx, ncm);
-
-	switch (ncm->type) {
-	case NSS_TRUSTSEC_RX_MSG_STATS_SYNC:
-		/*
-		 * Update trustsec_rx statistics.
-		 */
-		nss_trustsec_rx_stats_sync(nss_ctx, &msg->msg.stats_sync);
-		break;
-	}
-
-	/*
-	 * Update the callback and app_data for NOTIFY messages, trustsec_rx sends all notify messages
-	 * to the same callback/app_data.
-	 */
-	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
-		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
-		ncm->app_data = (nss_ptr_t)nss_ctx->subsys_dp_register[ncm->interface].ndev;
-	}
-
-	/*
-	 * Do we have a call back
-	 */
-	if (!ncm->cb) {
-		return;
-	}
-
-	/*
-	 * callback
-	 */
-	cb = (nss_trustsec_rx_msg_callback_t)ncm->cb;
-
-	cb((void *)ncm->app_data, msg);
-}
-
-/*
- * nss_trustsec_rx_msg()
- *	Transmit a trustsec_rx message to NSSFW
- */
-static nss_tx_status_t nss_trustsec_rx_msg(struct nss_ctx_instance *nss_ctx, struct nss_trustsec_rx_msg *msg)
-{
-	struct nss_cmn_msg *ncm = &msg->cm;
-
-	/*
-	 * Trace messages.
-	 */
-	nss_trustsec_rx_log_tx_msg(msg);
-
-	/*
-	 * Sanity check the message
-	 */
-	if (ncm->interface != NSS_TRUSTSEC_RX_INTERFACE) {
-		nss_warning("%px: tx request for another interface: %d", nss_ctx, ncm->interface);
-		return NSS_TX_FAILURE;
-	}
-
-	if (ncm->type > NSS_TRUSTSEC_RX_MSG_MAX) {
-		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
-		return NSS_TX_FAILURE;
-	}
-
-	return nss_core_send_cmd(nss_ctx, msg, sizeof(*msg), NSS_NBUF_PAYLOAD_SIZE);
-}
-
-/*
- * nss_trustsec_rx_callback
- *	Callback to handle the completion of NSS ->HLOS messages.
- */
-static void nss_trustsec_rx_callback(void *app_data, struct nss_trustsec_rx_msg *msg)
-{
-	if (msg->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_warning("trustsec_rx error response %d\n", msg->cm.response);
-		ttx.response = NSS_TX_FAILURE;
-		complete(&ttx.complete);
-		return;
-	}
-
-	ttx.response = NSS_TX_SUCCESS;
-	complete(&ttx.complete);
-}
-
-/*
- * nss_trustsec_rx_msg_sync()
- *	Send a message to trustsec_rx interface & wait for the response.
- */
-nss_tx_status_t nss_trustsec_rx_msg_sync(struct nss_ctx_instance *nss_ctx, struct nss_trustsec_rx_msg *msg)
-{
-	nss_tx_status_t status;
-	int ret = 0;
-
-	down(&ttx.sem);
-
-	msg->cm.cb = (nss_ptr_t)nss_trustsec_rx_callback;
-	msg->cm.app_data = (nss_ptr_t)NULL;
-
-	status = nss_trustsec_rx_msg(nss_ctx, msg);
-	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%px: nss_trustsec_rx_msg failed\n", nss_ctx);
-		up(&ttx.sem);
-		return status;
-	}
-
-	ret = wait_for_completion_timeout(&ttx.complete, msecs_to_jiffies(NSS_TRUSTSEC_RX_TIMEOUT));
-	if (!ret) {
-		nss_warning("%px: trustsec_rx tx failed due to timeout\n", nss_ctx);
-		ttx.response = NSS_TX_FAILURE;
-	}
-
-	status = ttx.response;
-	up(&ttx.sem);
-
-	return status;
-}
-EXPORT_SYMBOL(nss_trustsec_rx_msg_sync);
-
-/*
- * nss_trustsec_rx_get_ctx()
- *	Return a TrustSec TX NSS context.
- */
-struct nss_ctx_instance *nss_trustsec_rx_get_ctx()
-{
-	return &nss_top_main.nss[nss_top_main.trustsec_rx_handler_id];
-}
-EXPORT_SYMBOL(nss_trustsec_rx_get_ctx);
-
-/*
- * nss_trustsec_rx_msg_init()
- *	Initialize trustsec_rx message.
- */
-void nss_trustsec_rx_msg_init(struct nss_trustsec_rx_msg *msg, uint16_t if_num, uint32_t type, uint32_t len,
-				nss_trustsec_rx_msg_callback_t cb, void *app_data)
-{
-	nss_cmn_msg_init(&msg->cm, if_num, type, len, (void *)cb, app_data);
-}
-EXPORT_SYMBOL(nss_trustsec_rx_msg_init);
-
-/*
- * nss_trustsec_rx_register_handler()
- *	Registering handler for sending msg to trustsec_rx node on NSS.
- */
-void nss_trustsec_rx_register_handler(void)
-{
-	struct nss_ctx_instance *nss_ctx = nss_trustsec_rx_get_ctx();
-
-	nss_core_register_handler(nss_ctx, NSS_TRUSTSEC_RX_INTERFACE, nss_trustsec_rx_handler, NULL);
-
-	nss_trustsec_rx_stats_dentry_create();
-
-	sema_init(&ttx.sem, 1);
-	init_completion(&ttx.complete);
-}
--- a/nss_trustsec_rx_log.c
+++ /dev/null
@@ -1,220 +0,0 @@
-/*
- * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-/*
- * nss_trustsec_rx_log.c
- *	NSS TRUSTSEC_RX logger file.
- */
-
-#include "nss_core.h"
-
-/*
- * nss_trustsec_rx_log_message_types_str
- *	TRUSTSEC_RX message strings
- */
-static int8_t *nss_trustsec_rx_log_message_types_str[NSS_TRUSTSEC_RX_MSG_MAX] __maybe_unused = {
-	"TRUSTSEC_RX Configure Message",
-	"TRUSTSEC_RX Unconfigure Message",
-	"TRUSTSEC_RX Stats Sync",
-	"TRUSTSEC_RX Config vp num Message",
-	"TRUSTSEC_RX Unconfig vp num Message",
-};
-
-/*
- * nss_trustsec_rx_log_error_response_types_str
- *	Strings for error types for TRUSTSEC_RX messages
- */
-static int8_t *nss_trustsec_rx_log_error_response_types_str[NSS_TRUSTSEC_RX_ERR_MAX] __maybe_unused = {
-	"TRUSTSEC_RX No error",
-	"TRUSTSEC_RX Destination interface is not found",
-	"TRUSTSEC_RX IP version is incorrect",
-	"TRUSTSEC_RX Entry already exist",
-	"TRUSTSEC_RX IP rule cannot be added",
-	"TRUSTSEC_RX Entry cannot be found",
-	"TRUSTSEC_RX source interface is not configured",
-	"TRUSTSEC_RX Unknown trustsec message",
-	"TRUSTSEC_RX configure vp number failed",
-	"TRUSTSEC_RX unconfigure vp number failed",
-};
-
-/*
- * nss_trustsec_rx_log_config_vp_msg
- *	Log NSS TrustSec Rx configure vp message
- */
-static void nss_trustsec_rx_log_config_vp_msg(struct nss_trustsec_rx_msg *ntm)
-{
-	struct nss_trustsec_rx_vp_msg *vpm __maybe_unused = &ntm->msg.cfg;
-	nss_trace("%px: NSS trustsec_rx message: Configure VP\n"
-		"VP number: %u\n",
-		vpm,
-		vpm->num);
-}
-
-/*
- * nss_trustsec_rx_log_unconfig_vp_msg
- *	Log NSS TrustSec Rx uncfg vp message
- */
-static void nss_trustsec_rx_log_unconfig_vp_msg(struct nss_trustsec_rx_msg *ntm)
-{
-	struct nss_trustsec_rx_vp_msg *vpm __maybe_unused = &ntm->msg.uncfg;
-	nss_trace("%px: NSS trustsec_rx message: Unconfigure VP\n"
-		"VP number: %u\n",
-		vpm,
-		vpm->num);
-}
-
-/*
- * nss_trustsec_rx_log_configure_msg()
- *	Log NSS TRUSTSEC_RX configure message.
- */
-static void nss_trustsec_rx_log_configure_msg(struct nss_trustsec_rx_msg *ntm)
-{
-	struct nss_trustsec_rx_configure_msg *cfg __maybe_unused = &ntm->msg.configure;
-	nss_trace("%px: NSS trustsec_rx message: Config\n"
-		"IP version: %u\n",
-		cfg,
-		cfg->ip_version);
-
-	if (cfg->ip_version == NSS_TRUSTSEC_RX_FLAG_IPV4) {
-		nss_trace("Src IP: %pI4\n"
-			"Dest IP: %pI4\n",
-			&(cfg->src_ip.ip.ipv4),
-			&(cfg->dest_ip.ip.ipv4));
-	} else {
-		nss_trace("Src IP: %pI6\n"
-			"Dest IP: %pI6\n",
-			&(cfg->src_ip.ip.ipv6),
-			&(cfg->dest_ip.ip.ipv6));
-	}
-
-	nss_trace("Src Port: %u\n Dest Port: %u\n\n",
-		cfg->src_port, cfg->dest_port);
-	nss_trace("%px: Destination interface number: %u", cfg, cfg->dest);
-}
-
-/*
- * nss_trustsec_rx_log_unconfigure_msg()
- *	Log NSS TRUSTSEC_RX unconfigure message.
- */
-static void nss_trustsec_rx_log_unconfigure_msg(struct nss_trustsec_rx_msg *ntm)
-{
-	struct nss_trustsec_rx_unconfigure_msg *uncfg __maybe_unused = &ntm->msg.unconfigure;
-	nss_trace("%px: NSS trustsec_rx message: Unconfig\n"
-		"IP version: %u\n",
-		uncfg,
-		uncfg->ip_version);
-
-	if (uncfg->ip_version == NSS_TRUSTSEC_RX_FLAG_IPV4) {
-		nss_trace("Src IP: %pI4\n"
-			"Dest IP: %pI4\n",
-			&(uncfg->src_ip.ip.ipv4),
-			&(uncfg->dest_ip.ip.ipv4));
-	} else {
-		nss_trace("Src IP: %pI6\n"
-			"Dest IP: %pI6\n",
-			&(uncfg->src_ip.ip.ipv6),
-			&(uncfg->dest_ip.ip.ipv6));
-	}
-
-	nss_trace("Src Port: %u\n Dest Port: %u\n\n",
-		uncfg->src_port, uncfg->dest_port);
-	nss_trace("%px: Destination interface number: %u", uncfg, uncfg->dest);
-}
-
-/*
- * nss_trustsec_rx_log_verbose()
- *	Log message contents.
- */
-static void nss_trustsec_rx_log_verbose(struct nss_trustsec_rx_msg *ntm)
-{
-	switch (ntm->cm.type) {
-	case NSS_TRUSTSEC_RX_MSG_CONFIGURE:
-		nss_trustsec_rx_log_configure_msg(ntm);
-		break;
-
-	case NSS_TRUSTSEC_RX_MSG_UNCONFIGURE:
-		nss_trustsec_rx_log_unconfigure_msg(ntm);
-		break;
-
-	case NSS_TRUSTSEC_RX_MSG_STATS_SYNC:
-		/*
-		 * No log for valid stats message.
-		 */
-		break;
-
-	case NSS_TRUSTSEC_RX_MSG_CONFIG_VP:
-		nss_trustsec_rx_log_config_vp_msg(ntm);
-		break;
-
-	case NSS_TRUSTSEC_RX_MSG_UNCONFIG_VP:
-		nss_trustsec_rx_log_unconfig_vp_msg(ntm);
-		break;
-
-	default:
-		nss_warning("%px: Invalid message type\n", ntm);
-		break;
-	}
-}
-
-/*
- * nss_trustsec_rx_log_tx_msg()
- *	Log messages transmitted to FW.
- */
-void nss_trustsec_rx_log_tx_msg(struct nss_trustsec_rx_msg *ntm)
-{
-	if (ntm->cm.type >= NSS_TRUSTSEC_RX_MSG_MAX) {
-		nss_warning("%px: Invalid message type\n", ntm);
-		return;
-	}
-
-	nss_info("%px: type[%d]:%s\n", ntm, ntm->cm.type, nss_trustsec_rx_log_message_types_str[ntm->cm.type]);
-	nss_trustsec_rx_log_verbose(ntm);
-}
-
-/*
- * nss_trustsec_rx_log_rx_msg()
- *	Log messages received from FW.
- */
-void nss_trustsec_rx_log_rx_msg(struct nss_trustsec_rx_msg *ntm)
-{
-	if (ntm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%px: Invalid response\n", ntm);
-		return;
-	}
-
-	if (ntm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (ntm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%px: type[%d]:%s, response[%d]:%s\n", ntm, ntm->cm.type,
-			nss_trustsec_rx_log_message_types_str[ntm->cm.type],
-			ntm->cm.response, nss_cmn_response_str[ntm->cm.response]);
-		goto verbose;
-	}
-
-	if (ntm->cm.error >= NSS_TRUSTSEC_RX_ERR_UNKNOWN) {
-		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
-			ntm, ntm->cm.type, nss_trustsec_rx_log_message_types_str[ntm->cm.type],
-			ntm->cm.response, nss_cmn_response_str[ntm->cm.response],
-			ntm->cm.error);
-		goto verbose;
-	}
-
-	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
-		ntm, ntm->cm.type, nss_trustsec_rx_log_message_types_str[ntm->cm.type],
-		ntm->cm.response, nss_cmn_response_str[ntm->cm.response],
-		ntm->cm.error, nss_trustsec_rx_log_error_response_types_str[ntm->cm.error]);
-
-verbose:
-	nss_trustsec_rx_log_verbose(ntm);
-}
--- a/nss_trustsec_rx_log.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-
-#ifndef __NSS_TRUSTSEC_RX_LOG_H__
-#define __NSS_TRUSTSEC_RX_LOG_H__
-
-/*
- * nss_trustsec_rx_log.h
- *	NSS TRUSTSEC_RX Log Header File
- */
-
-/*
- * nss_trustsec_rx_log_tx_msg
- *	Logs a trustsec_rx message that is sent to the NSS firmware.
- */
-void nss_trustsec_rx_log_tx_msg(struct nss_trustsec_rx_msg *msg);
-
-/*
- * nss_trustsec_rx_log_rx_msg
- *	Logs a trustsec_rx message that is received from the NSS firmware.
- */
-void nss_trustsec_rx_log_rx_msg(struct nss_trustsec_rx_msg *msg);
-
-#endif /* __NSS_TRUSTSEC_RX_LOG_H__ */
--- a/nss_trustsec_rx_stats.c
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-#include "nss_tx_rx_common.h"
-#include "nss_trustsec_rx_stats.h"
-
-/*
- * nss_trustsec_rx_stats_str
- *	Trustsec TX statistics strings.
- */
-
-struct nss_stats_info nss_trustsec_rx_stats_str[NSS_TRUSTSEC_RX_STATS_MAX] = {
-	{"Unknown ethernet type", NSS_STATS_TYPE_ERROR},
-	{"Unknown packet"	, NSS_STATS_TYPE_ERROR},
-	{"Unknown destination"	, NSS_STATS_TYPE_ERROR},
-	{"IP parse failed"	, NSS_STATS_TYPE_ERROR},
-	{"Wrong L4 type"	, NSS_STATS_TYPE_ERROR},
-};
-
-/*
- * trustsec_rx_stats
- *	Trustsec RX statistics.
- */
-uint64_t trustsec_rx_stats[NSS_TRUSTSEC_RX_STATS_MAX];
-
-/*
- * Trustsec RX statistics APIs
- */
-
-/*
- * nss_trustsec_rx_stats_sync()
- *	Update trustsec_rx node statistics.
- */
-void nss_trustsec_rx_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_trustsec_rx_stats_sync_msg *ntsm)
-{
-	struct nss_top_instance *nss_top = nss_ctx->nss_top;
-	int j;
-
-	spin_lock_bh(&nss_top->stats_lock);
-
-	/*
-	 * Update common node stats
-	 */
-	nss_top->stats_node[NSS_TRUSTSEC_RX_INTERFACE][NSS_STATS_NODE_RX_PKTS] += ntsm->node_stats.rx_packets;
-	nss_top->stats_node[NSS_TRUSTSEC_RX_INTERFACE][NSS_STATS_NODE_RX_BYTES] += ntsm->node_stats.rx_bytes;
-	nss_top->stats_node[NSS_TRUSTSEC_RX_INTERFACE][NSS_STATS_NODE_TX_PKTS] += ntsm->node_stats.tx_packets;
-	nss_top->stats_node[NSS_TRUSTSEC_RX_INTERFACE][NSS_STATS_NODE_TX_BYTES] += ntsm->node_stats.tx_bytes;
-
-	for (j = 0; j < NSS_MAX_NUM_PRI; j++) {
-		nss_top->stats_node[NSS_TRUSTSEC_RX_INTERFACE][NSS_STATS_NODE_RX_QUEUE_0_DROPPED + j] += ntsm->node_stats.rx_dropped[j];
-	}
-
-	/*
-	 * Update trustsec node stats
-	 */
-	trustsec_rx_stats[NSS_TRUSTSEC_RX_STATS_UNKNOWN_ETH_TYPE] += ntsm->unknown_eth_type;
-	trustsec_rx_stats[NSS_TRUSTSEC_RX_STATS_UNKNOWN_PKT] += ntsm->unknown_pkt;
-	trustsec_rx_stats[NSS_TRUSTSEC_RX_STATS_UNKNOWN_DEST] += ntsm->unknown_dest;
-	trustsec_rx_stats[NSS_TRUSTSEC_RX_STATS_IP_PARSE_FAILED] += ntsm->ip_parse_failed;
-	trustsec_rx_stats[NSS_TRUSTSEC_RX_STATS_WRONG_L4_TYPE] += ntsm->wrong_l4_type;
-
-	spin_unlock_bh(&nss_top->stats_lock);
-}
-
-/*
- * nss_trustsec_rx_stats_read()
- *	Read trustsec_rx statiistics.
- */
-static ssize_t nss_trustsec_rx_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	int32_t i;
-
-	/*
-	 * Max output lines = #stats + few blank lines for banner printing +
-	 * Number of Extra outputlines for future reference to add new stats.
-	 */
-	uint32_t max_output_lines = NSS_STATS_NODE_MAX + NSS_TRUSTSEC_RX_STATS_MAX + NSS_STATS_EXTRA_OUTPUT_LINES;
-	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
-	size_t size_wr = 0;
-	ssize_t bytes_read = 0;
-	uint64_t *stats_shadow;
-
-	char *lbuf = kzalloc(size_al, GFP_KERNEL);
-	if (unlikely(lbuf == NULL)) {
-		nss_warning("Could not allocate memory for local statistics buffer");
-		return 0;
-	}
-
-	stats_shadow = kzalloc(NSS_STATS_NODE_MAX * 8, GFP_KERNEL);
-	if (unlikely(stats_shadow == NULL)) {
-		nss_warning("Could not allocate memory for local shadow buffer");
-		kfree(lbuf);
-		return 0;
-	}
-
-	size_wr += nss_stats_banner(lbuf, size_wr, size_al, "trustsec_rx", NSS_STATS_SINGLE_CORE);
-
-	/*
-	 * Common node stats
-	 */
-	size_wr += nss_stats_fill_common_stats(NSS_TRUSTSEC_RX_INTERFACE, NSS_STATS_SINGLE_INSTANCE, lbuf, size_wr, size_al, "trustsec_rx");
-
-	/*
-	 * TrustSec TX node stats
-	 */
-	spin_lock_bh(&nss_top_main.stats_lock);
-	for (i = 0; (i < NSS_TRUSTSEC_RX_STATS_MAX); i++) {
-		stats_shadow[i] = trustsec_rx_stats[i];
-	}
-
-	spin_unlock_bh(&nss_top_main.stats_lock);
-	size_wr += nss_stats_print("trustsec_rx", NULL, NSS_STATS_SINGLE_INSTANCE
-					, nss_trustsec_rx_stats_str
-					, stats_shadow
-					, NSS_TRUSTSEC_RX_STATS_MAX
-					, lbuf, size_wr, size_al);
-	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
-	kfree(lbuf);
-	kfree(stats_shadow);
-
-	return bytes_read;
-}
-
-/*
- * nss_trustsec_rx_stats_ops
- */
-NSS_STATS_DECLARE_FILE_OPERATIONS(trustsec_rx)
-
-/*
- * nss_trustsec_rx_stats_dentry_create()
- *	Create trustsec_rx statistics debug entry.
- */
-void nss_trustsec_rx_stats_dentry_create(void)
-{
-	nss_stats_create_dentry("trustsec_rx", &nss_trustsec_rx_stats_ops);
-}
--- a/nss_trustsec_rx_stats.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (c) 2022, Qualcomm Innovation Center, Inc. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- */
-/*
- * nss_trustsec_rx_stats.h
- *      NSS TRUSTSEC RX statistics header file.
- */
-
-#ifndef __NSS_TRUSTSEC_RX_STATS_H
-#define __NSS_TRUSTSEC_RX_STATS_H
-
-/*
- * Trustsec TX statistics
- */
-enum nss_trustsec_rx_stats {
-	NSS_TRUSTSEC_RX_STATS_UNKNOWN_ETH_TYPE,
-					/* Number of packets with unknown ethernet type */
-	NSS_TRUSTSEC_RX_STATS_UNKNOWN_PKT,
-					/* Number of packets with unknown IP packet*/
-	NSS_TRUSTSEC_RX_STATS_UNKNOWN_DEST,
-					/* Number of packets with unknown destination */
-	NSS_TRUSTSEC_RX_STATS_IP_PARSE_FAILED,
-					/* Number of packets with IP parse failed */
-	NSS_TRUSTSEC_RX_STATS_WRONG_L4_TYPE,
-					/* Number of packets with wrong L4 type */
-	NSS_TRUSTSEC_RX_STATS_MAX
-};
-
-/*
- * Trustsec TX statistics APIs
- */
-extern void nss_trustsec_rx_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_trustsec_rx_stats_sync_msg *ntsm);
-extern void nss_trustsec_rx_stats_dentry_create(void);
-
-#endif /* __NSS_TRUSTSEC_RX_STATS_H */
--- a/nss_tunipip6.c
+++ b/nss_tunipip6.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2014-2018, 2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014-2018, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -16,20 +16,6 @@
 
 #include "nss_tx_rx_common.h"
 #include "nss_tunipip6_log.h"
-#include "nss_tunipip6_stats.h"
-
-#define NSS_TUNIPIP6_TX_TIMEOUT 3000
-
-/*
- * Data structure used to handle sync message.
- */
-static struct nss_tunipip6_pvt {
-	struct semaphore sem;           /* Semaphore structure. */
-	struct completion complete;     /* Completion structure. */
-	int response;                   /* Response from FW. */
-	void *cb;                       /* Original cb for msgs. */
-	void *app_data;                 /* Original app_data for msgs. */
-} tunipip6_pvt;
 
 /*
  * nss_tunipip6_verify_if_num
@@ -71,24 +57,15 @@ static void nss_tunipip6_handler(struct
 	 * Is this a valid request/response packet?
 	 */
 	if (ncm->type >= NSS_TUNIPIP6_MAX) {
-		nss_warning("%px: received invalid message %d for DS-Lite interface", nss_ctx, ncm->type);
+		nss_warning("%p: received invalid message %d for DS-Lite interface", nss_ctx, ncm->type);
 		return;
 	}
 
 	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_tunipip6_msg)) {
-		nss_warning("%px: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		nss_warning("%p: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
 
-	switch (ntm->cm.type) {
-	case NSS_TUNIPIP6_STATS_SYNC:
-		/*
-		 * Sync common node stats.
-		 */
-		nss_tunipip6_stats_sync(nss_ctx, ntm);
-		break;
-	}
-
 	/*
 	 * Update the callback and app_data for NOTIFY messages, tunipip6 sends all notify messages
 	 * to the same callback/app_data.
@@ -119,7 +96,7 @@ static void nss_tunipip6_handler(struct
 	 * call ipip6 tunnel callback
 	 */
 	if (!ctx) {
-		 nss_warning("%px: Event received for DS-Lite tunnel interface %d before registration", nss_ctx, ncm->interface);
+		 nss_warning("%p: Event received for DS-Lite tunnel interface %d before registration", nss_ctx, ncm->interface);
 		return;
 	}
 
@@ -143,12 +120,12 @@ nss_tx_status_t nss_tunipip6_tx(struct n
 	 * Sanity check the message
 	 */
 	if (!nss_tunipip6_verify_if_num(ncm->interface)) {
-		nss_warning("%px: tx request for another interface: %d", nss_ctx, ncm->interface);
+		nss_warning("%p: tx request for another interface: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
 
 	if (ncm->type > NSS_TUNIPIP6_MAX) {
-		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
+		nss_warning("%p: message type out of range: %d", nss_ctx, ncm->type);
 		return NSS_TX_FAILURE;
 	}
 
@@ -157,60 +134,6 @@ nss_tx_status_t nss_tunipip6_tx(struct n
 EXPORT_SYMBOL(nss_tunipip6_tx);
 
 /*
- * nss_tunipip6_callback()
- *	Callback to handle the completion of NSS->HLOS messages.
- */
-static void nss_tunipip6_callback(void *app_data, struct nss_tunipip6_msg *nclm)
-{
-	tunipip6_pvt.response = NSS_TX_SUCCESS;
-	tunipip6_pvt.cb = NULL;
-	tunipip6_pvt.app_data = NULL;
-
-	if (nclm->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_warning("%px: tunipip6 Error response %d Error: %d\n", app_data, nclm->cm.response, nclm->cm.error);
-		tunipip6_pvt.response = nclm->cm.response;
-	}
-
-	/*
-	 * Write memory barrier.
-	 */
-	smp_wmb();
-	complete(&tunipip6_pvt.complete);
-}
-
-/*
- * nss_tunipip6_tx_sync()
- * 	Transmit a tunipip6 message to NSSFW synchronously.
- */
-nss_tx_status_t nss_tunipip6_tx_sync(struct nss_ctx_instance *nss_ctx, struct nss_tunipip6_msg *msg)
-{
-	nss_tx_status_t status;
-	int ret;
-
-	down(&tunipip6_pvt.sem);
-	msg->cm.cb = (nss_ptr_t)nss_tunipip6_callback;
-	msg->cm.app_data = (nss_ptr_t)NULL;
-
-	status = nss_tunipip6_tx(nss_ctx, msg);
-	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%px: tunipip6_tx_msg failed\n", nss_ctx);
-		up(&tunipip6_pvt.sem);
-		return status;
-	}
-
-	ret = wait_for_completion_timeout(&tunipip6_pvt.complete, msecs_to_jiffies(NSS_TUNIPIP6_TX_TIMEOUT));
-	if (!ret) {
-		nss_warning("%px: tunipip6 tx sync failed due to timeout\n", nss_ctx);
-		tunipip6_pvt.response = NSS_TX_FAILURE;
-	}
-
-	status = tunipip6_pvt.response;
-	up(&tunipip6_pvt.sem);
-	return status;
-}
-EXPORT_SYMBOL(nss_tunipip6_tx_sync);
-
-/*
  * **********************************
  *  Register/Unregister/Miscellaneous APIs
  * **********************************
@@ -250,7 +173,6 @@ void nss_unregister_tunipip6_if(uint32_t
 	nss_assert(nss_ctx);
 	nss_assert(nss_tunipip6_verify_if_num(if_num));
 
-	nss_stats_reset_common_stats(if_num);
 	nss_core_unregister_handler(nss_ctx, if_num);
 	nss_core_unregister_subsys_dp(nss_ctx, if_num);
 
@@ -275,9 +197,6 @@ void nss_tunipip6_register_handler()
 	struct nss_ctx_instance *nss_ctx = nss_tunipip6_get_context();
 
 	nss_core_register_handler(nss_ctx, NSS_TUNIPIP6_INTERFACE, nss_tunipip6_handler, NULL);
-	nss_tunipip6_stats_dentry_create();
-	sema_init(&tunipip6_pvt.sem, 1);
-	init_completion(&tunipip6_pvt.complete);
 }
 
 /*
--- a/nss_tunipip6_log.c
+++ b/nss_tunipip6_log.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2018, 2020, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2018, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -26,83 +26,47 @@
  *	NSS TUNIPIP6 message strings
  */
 static int8_t *nss_tunipip6_log_message_types_str[NSS_TUNIPIP6_MAX] __maybe_unused = {
-	"TUNIPIP6 Encap Interface Create",
-	"TUNIPIP6 Decap Interface Create",
+	"TUNIPIP6 Interface Create",
 	"TUNIPIP6 Stats",
-	"TUNIPIP6 FMR add",
-	"TUNIPIP6 FMR delete",
-	"TUNIPIP6 FMR flush",
-	"TUNIPIP6 BMR add",
-	"TUNIPIP6 BMR delete",
 };
 
 /*
- * nss_tunipip6_log_error_types_str
- *	Strings for error types for TUNIPIP6 messages
- */
-static char *nss_tunipip6_log_error_types_str[NSS_TUNIPIP6_ERROR_MAX] __maybe_unused = {
-	"TUNIPIP6 maximum tunnel reached",
-	"TUNIPIP6 tunnel already exists",
-	"TUNIPIP6 configuration parameters are incorrect",
-	"TUNIPIP6 FMR already exists ",
-	"TUNIPIP6 no FMR configured",
-	"TUNIPIP6 FMR table is full",
-	"TUNIPIP6 invalid FMR",
-	"TUNIPIP6 BMR already exists",
-	"TUNIPIP6 no BMR configured",
-	"TUNIPIP6 memory allocation for FMR failed",
-	"TUNIPIP6 unknown error",
-};
-
-/*
- * nss_tunipip6_log_map_rule()
- *	Log NSS TUNIPIP6 map rule.
- */
-static void nss_tunipip6_log_map_rule(struct nss_tunipip6_msg *ntm)
-{
-	struct nss_tunipip6_map_rule *nmr __maybe_unused = &ntm->msg.map_rule;
-	nss_trace("%px: NSS TUNIPIP6 Interface Create message \n"
-		"TUNIPIP6 Map Rule IPv6 prefix: %pI6\n"
-		"TUNIPIP6 Map Rule IPv6 prefix length: %d\n"
-		"TUNIPIP6 Map Rule IPv4 prefix: %pI4\n"
-		"TUNIPIP6 Map Rule IPv4 prefix length: %d\n"
-		"TUNIPIP6 Map Rule IPv6 suffix: %pI6\n"
-		"TUNIPIP6 Map Rule IPv6 suffix length: %d\n"
-		"TUNIPIP6 Map Rule EA length: %d\n"
-		"TUNIPIP6 Map Rule PSID offset: %d\n",
-		nmr, nmr->ip6_prefix,
-		nmr->ip6_prefix_len,&nmr->ip4_prefix,
-		nmr->ip4_prefix_len, nmr->ip6_suffix,
-		nmr->ip6_suffix_len, nmr->ea_len,
-		nmr->psid_offset);
-}
-
-/*
  * nss_tunipip6_log_if_create_msg()
  *	Log NSS TUNIPIP6 Interface Create
  */
 static void nss_tunipip6_log_if_create_msg(struct nss_tunipip6_msg *ntm)
 {
 	struct nss_tunipip6_create_msg *ntcm __maybe_unused = &ntm->msg.tunipip6_create;
-	nss_trace("%px: NSS TUNIPIP6 Interface Create message \n"
+	int32_t i;
+	nss_trace("%p: NSS TUNIPIP6 Interface Create message \n"
 		"TUNIPIP6 Source Address: %pI6\n"
 		"TUNIPIP6 Destination Address: %pI6\n"
 		"TUNIPIP6 Flow Label: %d\n"
 		"TUNIPIP6 Flags: %d\n"
 		"TUNIPIP6 Hop Limit: %d\n"
 		"TUNIPIP6 Draft03 Specification: %d\n"
-		"TUNIPIP6 TTL inherit: %u\n"
-		"TUNIPIP6 TOS inherit: %u\n"
-		"TUNIPIP6 Frag ID Update: %u\n"
-		"TUNIPIP6 Max FMR: %u\n",
+		"TUNIPIP6 FMR Number: %d\n",
 		ntcm, ntcm->saddr,
 		ntcm->daddr, ntcm->flowlabel,
 		ntcm->flags, ntcm->hop_limit,
-		ntcm->draft03,
-		ntcm->ttl_inherit,
-		ntcm->tos_inherit,
-		ntcm->frag_id_update,
-		ntcm->fmr_max);
+		ntcm->draft03, ntcm->fmr_number);
+	/*
+	 * Continuation of the log.
+	 */
+	for (i = 0; i < NSS_TUNIPIP6_MAX_FMR_NUMBER; i++) {
+		nss_trace("TUNIPIP6 FMR[%d] IPv6 Prefix: %pI6\n"
+			"TUNIPIP6 FMR[%d] IPv4 Prefix: %pI4\n"
+			"TUNIPIP6 FMR[%d] IPv6 Prefix Length: %d\n"
+			"TUNIPIP6 FMR[%d] IPv4 Prefix Length: %d\n"
+			"TUNIPIP6 FMR[%d] Embedded Address Length: %d\n"
+			"TUNIPIP6 FMR[%d] offset: %d",
+			i, ntcm->fmr[i].ip6_prefix,
+			i, &ntcm->fmr[i].ip4_prefix,
+			i, ntcm->fmr[i].ip6_prefix_len,
+			i, ntcm->fmr[i].ip4_prefix_len,
+			i, ntcm->fmr[i].ea_len,
+			i, ntcm->fmr[i].offset);
+	}
 }
 
 /*
@@ -117,23 +81,14 @@ static void nss_tunipip6_log_verbose(str
 		nss_tunipip6_log_if_create_msg(ntm);
 		break;
 
-	case NSS_TUNIPIP6_STATS_SYNC:
+	case NSS_TUNIPIP6_RX_STATS_SYNC:
 		/*
 		 * No log for valid stats message.
 		 */
 		break;
 
-	case NSS_TUNIPIP6_BMR_RULE_ADD:
-	case NSS_TUNIPIP6_BMR_RULE_DEL:
-	case NSS_TUNIPIP6_FMR_RULE_ADD:
-	case NSS_TUNIPIP6_FMR_RULE_DEL:
-		nss_tunipip6_log_map_rule(ntm);
-		break;
-	case NSS_TUNIPIP6_FMR_RULE_FLUSH:
-		nss_trace("%px: FMR rule flush.\n", ntm);
-		break;
 	default:
-		nss_trace("%px: Invalid message type\n", ntm);
+		nss_trace("%p: Invalid message type\n", ntm);
 		break;
 	}
 }
@@ -145,11 +100,11 @@ static void nss_tunipip6_log_verbose(str
 void nss_tunipip6_log_tx_msg(struct nss_tunipip6_msg *ntm)
 {
 	if (ntm->cm.type >= NSS_TUNIPIP6_MAX) {
-		nss_warning("%px: Invalid message type\n", ntm);
+		nss_warning("%p: Invalid message type\n", ntm);
 		return;
 	}
 
-	nss_info("%px: type[%d]:%s\n", ntm, ntm->cm.type, nss_tunipip6_log_message_types_str[ntm->cm.type]);
+	nss_info("%p: type[%d]:%s\n", ntm, ntm->cm.type, nss_tunipip6_log_message_types_str[ntm->cm.type]);
 	nss_tunipip6_log_verbose(ntm);
 }
 
@@ -160,29 +115,20 @@ void nss_tunipip6_log_tx_msg(struct nss_
 void nss_tunipip6_log_rx_msg(struct nss_tunipip6_msg *ntm)
 {
 	if (ntm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%px: Invalid response\n", ntm);
+		nss_warning("%p: Invalid response\n", ntm);
 		return;
 	}
 
 	if (ntm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (ntm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%px: type[%d]:%s, response[%d]:%s\n", ntm, ntm->cm.type,
+		nss_info("%p: type[%d]:%s, response[%d]:%s\n", ntm, ntm->cm.type,
 			nss_tunipip6_log_message_types_str[ntm->cm.type],
 			ntm->cm.response, nss_cmn_response_str[ntm->cm.response]);
 		goto verbose;
 	}
 
-	if (ntm->cm.error >= NSS_TUNIPIP6_ERROR_MAX) {
-		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
-			ntm, ntm->cm.type, nss_tunipip6_log_message_types_str[ntm->cm.type],
-			ntm->cm.response, nss_cmn_response_str[ntm->cm.response],
-			ntm->cm.error);
-		goto verbose;
-	}
-
-	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
+	nss_info("%p: msg nack - type[%d]:%s, response[%d]:%s\n",
 		ntm, ntm->cm.type, nss_tunipip6_log_message_types_str[ntm->cm.type],
-		ntm->cm.response, nss_cmn_response_str[ntm->cm.response],
-		ntm->cm.error, nss_tunipip6_log_error_types_str[ntm->cm.error]);
+		ntm->cm.response, nss_cmn_response_str[ntm->cm.response]);
 
 verbose:
 	nss_tunipip6_log_verbose(ntm);
--- a/nss_tunipip6_stats.c
+++ /dev/null
@@ -1,124 +0,0 @@
-/*
- **************************************************************************
- * Copyright (c) 2020, The Linux Foundation. All rights reserved.
-
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
-
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- **************************************************************************
- */
-
-#include "nss_core.h"
-#include "nss_tunipip6.h"
-#include "nss_stats.h"
-#include "nss_tunipip6_stats.h"
-
-#define NSS_TUNIPIP6_STATS_MAX_LINES (NSS_STATS_NODE_MAX + 32)
-					/**< Maximum number of lines for tunipip6 statistics dump. */
-#define NSS_TUNIPIP6_STATS_SIZE_PER_IF (NSS_STATS_MAX_STR_LENGTH * NSS_TUNIPIP6_STATS_MAX_LINES)
-					/**< Total number of statistics per tunipip6 interface. */
-
-/*
- * nss_tunipip6_stats_read()
- *	Read tunipip6 common node statistics
- */
-static ssize_t nss_tunipip6_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	struct nss_ctx_instance *nss_ctx = nss_tunipip6_get_context();
-	enum nss_dynamic_interface_type type;
-	ssize_t bytes_read = 0;
-	size_t len = 0, size;
-	uint32_t if_num;
-	char *buf;
-
-	/*
-	 * Allocate memory for NSS_TUNIPIP6_TUNNEL_MAX tunnels and one
-	 * static interface.
-	 */
-	size = NSS_TUNIPIP6_STATS_SIZE_PER_IF * (NSS_TUNIPIP6_TUNNEL_MAX << 1) + 1;
-	buf = vzalloc(size);
-	if (!buf) {
-		nss_warning("tunipip6: Could not allocate memory for local statistics buffer\n");
-		return 0;
-	}
-
-	len += nss_stats_banner(buf, len, size, "tunipip6", NSS_STATS_SINGLE_CORE);
-
-	len += scnprintf(buf + len, size - len, "\nBase node if_num:%03u", NSS_TUNIPIP6_INTERFACE);
-	len += scnprintf(buf + len, size - len, "\n-------------------\n");
-	len += nss_stats_fill_common_stats(NSS_TUNIPIP6_INTERFACE, NSS_STATS_SINGLE_INSTANCE, buf, len, size - len, "tunipip6");
-
-	/*
-	 * Common node stats for each tunipip6 dynamic interface.
-	 */
-	for (if_num = NSS_DYNAMIC_IF_START; if_num < NSS_DYNAMIC_IF_START + NSS_MAX_DYNAMIC_INTERFACES; if_num++) {
-		type = nss_dynamic_interface_get_type(nss_ctx, if_num);
-		switch (type) {
-		case NSS_DYNAMIC_INTERFACE_TYPE_TUNIPIP6_INNER:
-			len += scnprintf(buf + len, size - len, "\nInner if_num:%03u", if_num);
-			break;
-
-		case NSS_DYNAMIC_INTERFACE_TYPE_TUNIPIP6_OUTER:
-			len += scnprintf(buf + len, size - len, "\nOuter if_num:%03u", if_num);
-			break;
-
-		default:
-			continue;
-		}
-
-		len += scnprintf(buf + len, size - len, "\n-------------------\n");
-		len += nss_stats_fill_common_stats(if_num, NSS_STATS_SINGLE_INSTANCE, buf, len, size - len, "tunipip6");
-	}
-
-        bytes_read = simple_read_from_buffer(ubuf, sz, ppos, buf, len);
-        vfree(buf);
-        return bytes_read;
-}
-
-/*
- * nss_tunipip6_stats_sync()
- * 	Update tunipip6 common node statistics.
- */
-void nss_tunipip6_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_tunipip6_msg *ntm)
-{
-	struct nss_top_instance *nss_top = nss_ctx->nss_top;
-	struct nss_tunipip6_stats_sync_msg *msg_stats = &ntm->msg.stats;
-	uint64_t i, *dest;
-	uint32_t *src;
-
-	spin_lock_bh(&nss_top->stats_lock);
-
-	/*
-	 * Update common node stats
-	 */
-	dest = nss_top->stats_node[ntm->cm.interface];
-	src = &msg_stats->node_stats.rx_packets;
-	for (i = NSS_STATS_NODE_RX_PKTS; i <= NSS_STATS_NODE_RX_QUEUE_3_DROPPED; i++) {
-		*dest++ = *src++;
-	}
-
-	spin_unlock_bh(&nss_top->stats_lock);
-
-}
-
-/*
- * nss_tunipip6_stats_ops
- */
-NSS_STATS_DECLARE_FILE_OPERATIONS(tunipip6)
-
-/*
- * nss_tunipip6_stats_dentry_create()
- *	Create tunipip6 statistics debug entry.
- */
-void nss_tunipip6_stats_dentry_create(void)
-{
-	nss_stats_create_dentry("tunipip6", &nss_tunipip6_stats_ops);
-}
--- a/nss_tunipip6_stats.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- ******************************************************************************
- * Copyright (c) 2020, The Linux Foundation. All rights reserved.
-
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
-
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- * ****************************************************************************
- */
-
-#ifndef __NSS_TUNIPIP6_STATS_H
-#define __NSS_TUNIPIP6_STATS_H
-
-/*
- * nss_tunipip6_stats_dentry_create()
- * 	Creates tunipip6 interface statistics debug entry.
- */
-void nss_tunipip6_stats_dentry_create(void);
-
-/*
- * nss_tunipip6_stats_sync()
- * 	Update tunipip6 common node statistics.
- */
-void nss_tunipip6_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_tunipip6_msg *ntm);
-
-#endif /* __NSS_TUNIPIP6_STATS_H */
--- a/nss_tx_rx_common.h
+++ b/nss_tx_rx_common.h
@@ -92,15 +92,13 @@ extern void nss_dtls_cmn_register_handle
 extern void nss_tls_register_handler(void);
 extern void nss_gre_tunnel_register_handler(void);
 extern void nss_trustsec_tx_register_handler(void);
-extern void nss_trustsec_rx_register_handler(void);
 extern void nss_wifili_register_handler(void);
 extern void nss_ppe_register_handler(void);
 extern void nss_gre_redir_mark_register_handler(void);
 extern void nss_ppe_vp_register_handler(void);
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,0))
 extern void nss_wifi_mac_db_register_handler(void);
-extern void nss_wifi_ext_vdev_register_handler(void);
-extern void nss_wifili_thread_scheme_db_init(uint8_t core_id);
-extern void nss_wifi_mesh_init(void);
+#endif
 
 /*
  * nss_if_msg_handler()
--- a/nss_udp_st.c
+++ /dev/null
@@ -1,238 +0,0 @@
-/*
- **************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- **************************************************************************
- */
-
-/*
- * nss_udp_st.c
- *	NSS UDP_ST APIs
- */
-
-#include "nss_core.h"
-#include "nss_udp_st_stats.h"
-#include "nss_udp_st_strings.h"
-#include "nss_udp_st_log.h"
-
-#define NSS_UDP_ST_TX_MSG_TIMEOUT 1000	/* 1 sec timeout for udp_st messages */
-
-/*
- * Private data structure for udp_st configuration
- */
-struct nss_udp_st_pvt {
-	struct semaphore sem;		/* Semaphore structure */
-	struct completion complete;	/* completion structure */
-	int response;			/* Response from FW */
-	void *cb;			/* Original cb for sync msgs */
-	void *app_data;			/* Original app_data for sync msgs */
-} nss_udp_st_pvt;
-
-/*
- * nss_udp_st_msg_handler()
- *	Handle NSS -> HLOS messages for UDP_ST node
- */
-static void nss_udp_st_msg_handler(struct nss_ctx_instance *nss_ctx, struct nss_cmn_msg *ncm, __attribute__((unused))void *app_data)
-{
-	struct nss_udp_st_msg *num = (struct nss_udp_st_msg *)ncm;
-	nss_udp_st_msg_callback_t cb;
-
-	/*
-	 * Is this a valid message type?
-	 */
-	if (num->cm.type >= NSS_UDP_ST_MAX_MSG_TYPES) {
-		nss_warning("%px: received invalid message %d for udp_st interface", nss_ctx, num->cm.type);
-		return;
-	}
-
-	/*
-	 * Log messages.
-	 */
-	nss_udp_st_log_rx_msg(num);
-
-	switch (num->cm.type) {
-	case NSS_UDP_ST_STATS_SYNC_MSG:
-		/*
-		 * Update driver statistics and send stats notifications to the registered modules.
-		 */
-		nss_udp_st_stats_sync(nss_ctx, &num->msg.stats);
-		break;
-
-	case NSS_UDP_ST_RESET_STATS_MSG:
-		/*
-		 * This is a response to the statistics reset message.
-		 */
-		nss_udp_st_stats_reset(NSS_UDP_ST_INTERFACE);
-		break;
-	default:
-		if (ncm->response != NSS_CMN_RESPONSE_ACK) {
-			/*
-			 * Check response.
-			 */
-			nss_info("%px: Received response %d for type %d, interface %d",
-						nss_ctx, ncm->response, ncm->type, ncm->interface);
-		}
-	}
-
-	/*
-	 * Return for NOTIFY messages because there is no notifier functions.
-	 */
-	if (num->cm.response == NSS_CMN_RESPONSE_NOTIFY) {
-		return;
-	}
-
-	/*
-	 * Do we have a callback?
-	 */
-	if (!ncm->cb) {
-		return;
-	}
-
-	/*
-	 * Callback
-	 */
-	cb = (nss_udp_st_msg_callback_t)ncm->cb;
-	cb((void *)ncm->app_data, num);
-}
-
-/*
- * nss_udp_st_tx_sync_callback()
- *	Callback to handle the completion of synchronous tx messages.
- */
-static void nss_udp_st_tx_sync_callback(void *app_data, struct nss_udp_st_msg *num)
-{
-	nss_udp_st_msg_callback_t callback = (nss_udp_st_msg_callback_t)nss_udp_st_pvt.cb;
-	void *data = nss_udp_st_pvt.app_data;
-
-	nss_udp_st_pvt.cb = NULL;
-	nss_udp_st_pvt.app_data = NULL;
-
-	if (num->cm.response != NSS_CMN_RESPONSE_ACK) {
-		nss_warning("udp_st error response %d\n", num->cm.response);
-		nss_udp_st_pvt.response = NSS_TX_FAILURE;
-	} else {
-		nss_udp_st_pvt.response = NSS_TX_SUCCESS;
-	}
-
-	if (callback) {
-		callback(data, num);
-	}
-
-	complete(&nss_udp_st_pvt.complete);
-}
-
-/*
- * nss_udp_st_tx()
- *	Transmit a udp_st message to the FW.
- *
- * This API should not be called from interrupt or softirq context.
- */
-nss_tx_status_t nss_udp_st_tx(struct nss_ctx_instance *nss_ctx, struct nss_udp_st_msg *num)
-{
-	struct nss_cmn_msg *ncm = &num->cm;
-
-	/*
-	 * Sanity check the message
-	 */
-	if (ncm->interface != NSS_UDP_ST_INTERFACE) {
-		nss_warning("%px: tx request for another interface: %d", nss_ctx, ncm->interface);
-		return NSS_TX_FAILURE;
-	}
-
-	if (ncm->type >= NSS_UDP_ST_MAX_MSG_TYPES) {
-		nss_warning("%px: message type out of range: %d", nss_ctx, ncm->type);
-		return NSS_TX_FAILURE;
-	}
-
-	/*
-	 * Trace messages.
-	 */
-	nss_udp_st_log_tx_msg(num);
-
-	return nss_core_send_cmd(nss_ctx, num, sizeof(*num), NSS_NBUF_PAYLOAD_SIZE);
-}
-EXPORT_SYMBOL(nss_udp_st_tx);
-
-/*
- * nss_udp_st_tx_sync()
- *	Transmit a synchronous udp_st message to the FW.
- *
- * This API should not be called from interrupt or softirq context.
- */
-nss_tx_status_t nss_udp_st_tx_sync(struct nss_ctx_instance *nss_ctx, struct nss_udp_st_msg *num)
-{
-	nss_tx_status_t status;
-	int ret = 0;
-
-	down(&nss_udp_st_pvt.sem);
-	nss_udp_st_pvt.cb = (void *)num->cm.cb;
-	nss_udp_st_pvt.app_data = (void *)num->cm.app_data;
-
-	num->cm.cb = (nss_ptr_t)nss_udp_st_tx_sync_callback;
-	num->cm.app_data = (nss_ptr_t)NULL;
-
-	status = nss_udp_st_tx(nss_ctx, num);
-	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%px: nss udp_st msg tx failed\n", nss_ctx);
-		up(&nss_udp_st_pvt.sem);
-		return status;
-	}
-
-	ret = wait_for_completion_timeout(&nss_udp_st_pvt.complete, msecs_to_jiffies(NSS_UDP_ST_TX_MSG_TIMEOUT));
-	if (!ret) {
-		nss_warning("%px: udp_st tx sync failed due to timeout\n", nss_ctx);
-		nss_udp_st_pvt.response = NSS_TX_FAILURE;
-	}
-
-	status = nss_udp_st_pvt.response;
-	up(&nss_udp_st_pvt.sem);
-	return status;
-}
-EXPORT_SYMBOL(nss_udp_st_tx_sync);
-
-/*
- * nss_udp_st_msg_init()
- *	Initialize udp_st message.
- */
-void nss_udp_st_msg_init(struct nss_udp_st_msg *num, uint16_t if_num, uint32_t type, uint32_t len,
-			nss_udp_st_msg_callback_t cb, void *app_data)
-{
-	nss_cmn_msg_init(&num->cm, if_num, type, len, (void *)cb, app_data);
-}
-EXPORT_SYMBOL(nss_udp_st_msg_init);
-
-/*
- * nss_udp_st_register_handler()
- */
-void nss_udp_st_register_handler(struct nss_ctx_instance *nss_ctx)
-{
-	nss_core_register_handler(nss_ctx, NSS_UDP_ST_INTERFACE, nss_udp_st_msg_handler, NULL);
-
-	nss_udp_st_stats_dentry_create();
-	nss_udp_st_strings_dentry_create();
-
-	sema_init(&nss_udp_st_pvt.sem, 1);
-	init_completion(&nss_udp_st_pvt.complete);
-}
-
-/*
- * nss_udp_st_get_mgr()
- *
- */
-struct nss_ctx_instance *nss_udp_st_get_mgr(void)
-{
-	return (void *)&nss_top_main.nss[nss_top_main.udp_st_handler_id];
-}
-EXPORT_SYMBOL(nss_udp_st_get_mgr);
--- a/nss_udp_st_log.c
+++ /dev/null
@@ -1,297 +0,0 @@
-/*
- **************************************************************************
- * Copyright (c) 2020, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- **************************************************************************
- */
-
-/*
- * nss_udp_st_log.c
- *	NSS UDP Speedtest logger file.
- */
-
-#include "nss_core.h"
-
-/*
- * nss_udp_st_log_message_types_str
- *	udp_st message strings
- */
-static int8_t *nss_udp_st_log_message_types_str[NSS_UDP_ST_MAX_MSG_TYPES] __maybe_unused = {
-	"UDP_ST Start Msg",
-	"UDP_ST Stop Msg",
-	"UDP_ST Configure Rule Msg",
-	"UDP_ST Unconfigure Rule Msg",
-	"UDP_ST Stats Sync Msg",
-	"UDP_ST TX Create Msg",
-	"UDP_ST TX Destroy Msg",
-	"UDP_ST TX Update Rate Msg",
-	"UDP_ST RX Mode Set Msg",
-	"UDP_ST Time Sync Msg",
-	"UDP_ST Reset Stats Msg",
-};
-
-/*
- * nss_udp_st_log_error_response_types_str
- *	Strings for error types for udp_st messages
- */
-static int8_t *nss_udp_st_log_error_response_types_str[NSS_UDP_ST_ERROR_MAX] __maybe_unused = {
-	"UDP_ST No Error",
-	"UDP_ST Incorrect Rate",
-	"UDP_ST Incorrect Buffer Size",
-	"UDP_ST Memory Failure",
-	"UDP_ST Incorrect State",
-	"UDP_ST Incorrect Flags",
-	"UDP_ST Entry Exist",
-	"UDP_ST Entry Add Failed",
-	"UDP_ST Entry Not Exist",
-	"UDP_ST Wrong Start Msg Type",
-	"UDP_ST Wrong Stop Msg Type",
-	"UDP_ST Too Many Users",
-	"UDP_ST Unknown Msg Type",
-	"UDP_ST Pbuf Alloc Failure",
-	"UDP_ST Pbuf Size Failure",
-	"UDP_ST Drop Queue",
-	"UDP_ST Timer call missed",
-	"UDP_ST Encap Entry Lookup Failed",
-};
-
-/*
- * nss_udp_st_log_tx_create_destroy_msg()
- *	Log NSS udp_st Tx create/destroy message.
- */
-static void nss_udp_st_log_tx_create_destroy_msg(struct nss_udp_st_msg *num, uint8_t *msg_type)
-{
-	struct nss_udp_st_tx_create *create __maybe_unused = &num->msg.create;
-	nss_trace("%px: NSS udp_st message: %s\n"
-		"Rate: %u\n"
-		"Buffer Size: %u\n"
-		"DSCP: %u\n"
-		"Mode: %d\n"
-		"Timestamp: %llu",
-		create,
-		msg_type,
-		create->rate,
-		create->buffer_size,
-		create->dscp,
-		create->mode,
-		create->timestamp);
-}
-
-/*
- * nss_udp_st_log_uncfg_rule_msg()
- *	Log NSS udp_st unconfig rule message.
- */
-static void nss_udp_st_log_uncfg_rule_msg(struct nss_udp_st_msg *num)
-{
-	struct nss_udp_st_cfg *uncfg __maybe_unused = &num->msg.uncfg;
-	nss_trace("%px: NSS udp_st message: Unconfig\n"
-		"IP version: %u\n",
-		uncfg,
-		uncfg->ip_version);
-
-	if (uncfg->ip_version == NSS_UDP_ST_FLAG_IPV4) {
-		nss_trace("Src IP: %pI4\n"
-			"Dest IP: %pI4\n",
-			&(uncfg->src_ip.ip.ipv4),
-			&(uncfg->dest_ip.ip.ipv4));
-	} else {
-		nss_trace("Src IP: %pI6\n"
-			"Dest IP: %pI6\n",
-			&(uncfg->src_ip.ip.ipv6),
-			&(uncfg->dest_ip.ip.ipv6));
-	}
-
-	nss_trace("Src Port: %u\n Dest Port: %u\n Type: %u\n",
-		uncfg->src_port, uncfg->dest_port, uncfg->type);
-}
-
-/*
- * nss_udp_st_log_tx_update_rate_msg()
- *	Log NSS udp_st udpate Tx rate message.
- */
-static void nss_udp_st_log_tx_update_rate_msg(struct nss_udp_st_msg *num)
-{
-	struct nss_udp_st_tx_update_rate *update_rate __maybe_unused = &num->msg.update_rate;
-	nss_trace("%px: NSS udp_st message: Update Tx Rate\n"
-		"Rate : %u\n",
-		update_rate,
-		update_rate->rate);
-}
-
-/*
- * nss_udp_st_log_rx_mode_set_msg()
- *	Log NSS udp_st Rx mode set message.
- */
-static void nss_udp_st_log_rx_mode_set_msg(struct nss_udp_st_msg *num)
-{
-	struct nss_udp_st_rx_mode *mode __maybe_unused = &num->msg.mode;
-	nss_trace("%px: NSS udp_st message: Rx mode set\n"
-		"Mode : %u\n"
-		"Timestamp : %llu\n",
-		mode,
-		mode->mode,
-		mode->timestamp);
-}
-
-/*
- * nss_udp_st_log_cfg_rule_msg()
- *	Log NSS udp_st config rule message.
- */
-static void nss_udp_st_log_cfg_rule_msg(struct nss_udp_st_msg *num)
-{
-	struct nss_udp_st_cfg *cfg __maybe_unused = &num->msg.cfg;
-	nss_trace("%px: NSS udp_st message: Config\n"
-		"IP version: %u\n",
-		cfg,
-		cfg->ip_version);
-
-	if (cfg->ip_version == NSS_UDP_ST_FLAG_IPV4) {
-		nss_trace("Src IP: %pI4\n"
-			"Dest IP: %pI4\n",
-			&(cfg->src_ip.ip.ipv4),
-			&(cfg->dest_ip.ip.ipv4));
-	} else {
-		nss_trace("Src IP: %pI6\n"
-			"Dest IP: %pI6\n",
-			&(cfg->src_ip.ip.ipv6),
-			&(cfg->dest_ip.ip.ipv6));
-	}
-
-	nss_trace("Src Port: %u\n Dest Port: %u\n Type: %u\n",
-		cfg->src_port, cfg->dest_port, cfg->type);
-}
-
-/*
- * nss_udp_st_log_stop_msg()
- *	Log NSS udp_st stop message.
- */
-static void nss_udp_st_log_stop_msg(struct nss_udp_st_msg *num)
-{
-	struct nss_udp_st_stop *stop __maybe_unused = &num->msg.stop;
-	nss_trace("%px: NSS udp_st message: Stop\n"
-		"Type: %u\n",
-		stop,
-		stop->type);
-}
-
-/*
- * nss_udp_st_log_start_msg()
- *	Log NSS udp_st start message.
- */
-static void nss_udp_st_log_start_msg(struct nss_udp_st_msg *num)
-{
-	struct nss_udp_st_start *start __maybe_unused = &num->msg.start;
-	nss_trace("%px: NSS udp_st message: Start\n"
-		"Type: %u\n",
-		start,
-		start->type);
-}
-
-/*
- * nss_udp_st_log_verbose()
- *	Log message contents.
- */
-static void nss_udp_st_log_verbose(struct nss_udp_st_msg *num)
-{
-	switch (num->cm.type) {
-	case NSS_UDP_ST_START_MSG:
-		nss_udp_st_log_start_msg(num);
-		break;
-
-	case NSS_UDP_ST_STOP_MSG:
-		nss_udp_st_log_stop_msg(num);
-		break;
-
-	case NSS_UDP_ST_CFG_RULE_MSG:
-		nss_udp_st_log_cfg_rule_msg(num);
-		break;
-
-	case NSS_UDP_ST_UNCFG_RULE_MSG:
-		nss_udp_st_log_uncfg_rule_msg(num);
-		break;
-
-	case NSS_UDP_ST_TX_CREATE_MSG:
-		nss_udp_st_log_tx_create_destroy_msg(num, "Create");
-		break;
-
-	case NSS_UDP_ST_TX_DESTROY_MSG:
-		nss_udp_st_log_tx_create_destroy_msg(num, "Destroy");
-		break;
-	case NSS_UDP_ST_TX_UPDATE_RATE_MSG:
-		nss_udp_st_log_tx_update_rate_msg(num);
-		break;
-	case NSS_UDP_ST_RX_MODE_SET_MSG:
-		nss_udp_st_log_rx_mode_set_msg(num);
-		break;
-	case NSS_UDP_ST_RESET_STATS_MSG:
-	case NSS_UDP_ST_STATS_SYNC_MSG:
-	case NSS_UDP_ST_TIME_SYNC_MSG:
-		break;
-
-	default:
-		nss_trace("%px: Invalid message type\n", num);
-		break;
-	}
-}
-
-/*
- * nss_udp_st_log_tx_msg()
- *	Log messages transmitted to FW.
- */
-void nss_udp_st_log_tx_msg(struct nss_udp_st_msg *num)
-{
-	if (num->cm.type >= NSS_UDP_ST_MAX_MSG_TYPES) {
-		nss_warning("%px: Invalid message type\n", num);
-		return;
-	}
-
-	nss_info("%px: type[%d]:%s\n", num, num->cm.type, nss_udp_st_log_message_types_str[num->cm.type]);
-	nss_udp_st_log_verbose(num);
-}
-
-/*
- * nss_udp_st_log_rx_msg()
- *	Log messages received from FW.
- */
-void nss_udp_st_log_rx_msg(struct nss_udp_st_msg *num)
-{
-	if (num->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%px: Invalid response\n", num);
-		return;
-	}
-
-	if (num->cm.response == NSS_CMN_RESPONSE_NOTIFY || (num->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%px: type[%d]:%s, response[%d]:%s\n", num, num->cm.type,
-			nss_udp_st_log_message_types_str[num->cm.type],
-			num->cm.response, nss_cmn_response_str[num->cm.response]);
-		goto verbose;
-	}
-
-	if (num->cm.error >= NSS_UDP_ST_ERROR_MAX) {
-		nss_warning("%px: msg failure - type[%d]:%s, response[%d]:%s, error[%d]:Invalid error\n",
-			num, num->cm.type, nss_udp_st_log_message_types_str[num->cm.type],
-			num->cm.response, nss_cmn_response_str[num->cm.response],
-			num->cm.error);
-		goto verbose;
-	}
-
-	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s, error[%d]:%s\n",
-		num, num->cm.type, nss_udp_st_log_message_types_str[num->cm.type],
-		num->cm.response, nss_cmn_response_str[num->cm.response],
-		num->cm.error, nss_udp_st_log_error_response_types_str[num->cm.error]);
-
-verbose:
-	nss_udp_st_log_verbose(num);
-}
--- a/nss_udp_st_log.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- ******************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- * ****************************************************************************
- */
-
-#ifndef __NSS_UDP_ST_LOG_H__
-#define __NSS_UDP_ST_LOG_H__
-
-/*
- * nss_udp_st_log.h
- *	NSS UDP Speedtest Log Header File.
- */
-
-/*
- * nss_udp_st_log_tx_msg
- *	Logs a udp_st message that is sent to the NSS firmware.
- */
-void nss_udp_st_log_tx_msg(struct nss_udp_st_msg *num);
-
-/*
- * nss_udp_st_log_rx_msg
- *	Logs a udp_st message that is received from the NSS firmware.
- */
-void nss_udp_st_log_rx_msg(struct nss_udp_st_msg *num);
-
-#endif /* __NSS_UDP_ST_LOG_H__*/
--- a/nss_udp_st_stats.c
+++ /dev/null
@@ -1,216 +0,0 @@
-/*
- **************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- **************************************************************************
- */
-
-#include "nss_core.h"
-#include "nss_udp_st_stats.h"
-#include "nss_udp_st_strings.h"
-
-uint32_t nss_udp_st_errors[NSS_UDP_ST_ERROR_MAX];
-uint32_t nss_udp_st_stats_time[NSS_UDP_ST_TEST_MAX][NSS_UDP_ST_STATS_TIME_MAX];
-uint64_t nss_udp_st_stats_timestamp[NSS_UDP_ST_STATS_TIMESTAMP_MAX];
-
-/*
- * nss_udp_st_stats_read()
- *	Read UDP_ST stats.
- */
-static ssize_t nss_udp_st_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	/*
-	 * Max output lines = #stats * NSS_MAX_CORES  +
-	 * few blank lines for banner printing + Number of Extra outputlines for future reference to add new stats
-	 */
-	uint32_t max_output_lines = NSS_STATS_NODE_MAX + NSS_UDP_ST_ERROR_MAX + NSS_UDP_ST_STATS_TIMESTAMP_MAX +  NSS_STATS_EXTRA_OUTPUT_LINES;
-	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
-	size_t size_wr = 0;
-	ssize_t bytes_read = 0;
-	uint64_t *stats_shadow;
-	uint32_t i;
-
-	char *lbuf = kzalloc(size_al, GFP_KERNEL);
-	if (unlikely(lbuf == NULL)) {
-		nss_warning("Could not allocate memory for local statistics buffer");
-		return 0;
-	}
-
-	/*
-	 * Note: The assumption here is that we do not have more than 64 stats.
-	 */
-	stats_shadow = kzalloc(64 * 8, GFP_KERNEL);
-	if (unlikely(stats_shadow == NULL)) {
-		nss_warning("Could not allocate memory for local shadow buffer");
-		kfree(lbuf);
-		return 0;
-	}
-
-	size_wr += nss_stats_banner(lbuf, size_wr, size_al, "udp_st", NSS_STATS_SINGLE_CORE);
-
-	size_wr += nss_stats_fill_common_stats(NSS_UDP_ST_INTERFACE, NSS_STATS_SINGLE_INSTANCE, lbuf, size_wr, size_al, "udp_st");
-
-	/*
-	 * Error stats
-	 */
-	spin_lock_bh(&nss_top_main.stats_lock);
-	for (i = 0; (i < NSS_UDP_ST_ERROR_MAX); i++) {
-		stats_shadow[i] = nss_udp_st_errors[i];
-	}
-	spin_unlock_bh(&nss_top_main.stats_lock);
-	size_wr += nss_stats_print("udp_st", "udp_st error stats"
-					, NSS_STATS_SINGLE_INSTANCE
-					, nss_udp_st_strings_error_stats
-					, stats_shadow
-					, NSS_UDP_ST_ERROR_MAX
-					, lbuf, size_wr, size_al);
-
-	/*
-	 * Rx time stats
-	 */
-	spin_lock_bh(&nss_top_main.stats_lock);
-	for (i = 0; (i < NSS_UDP_ST_STATS_TIME_MAX); i++) {
-		stats_shadow[i] = nss_udp_st_stats_time[NSS_UDP_ST_TEST_RX][i];
-	}
-	spin_unlock_bh(&nss_top_main.stats_lock);
-	size_wr += nss_stats_print("udp_st", "udp_st Rx time stats (ms)"
-					, NSS_STATS_SINGLE_INSTANCE
-					, nss_udp_st_strings_rx_time_stats
-					, stats_shadow
-					, NSS_UDP_ST_STATS_TIME_MAX
-					, lbuf, size_wr, size_al);
-
-	/*
-	 * Tx time stats
-	 */
-	spin_lock_bh(&nss_top_main.stats_lock);
-	for (i = 0; (i < NSS_UDP_ST_STATS_TIME_MAX); i++) {
-		stats_shadow[i] = nss_udp_st_stats_time[NSS_UDP_ST_TEST_TX][i];
-	}
-	spin_unlock_bh(&nss_top_main.stats_lock);
-	size_wr += nss_stats_print("udp_st", "udp_st Tx time stats (ms)"
-					, NSS_STATS_SINGLE_INSTANCE
-					, nss_udp_st_strings_tx_time_stats
-					, stats_shadow
-					, NSS_UDP_ST_STATS_TIME_MAX
-					, lbuf, size_wr, size_al);
-
-	/*
-	 * Timestamp mode stats.
-	 */
-	spin_lock_bh(&nss_top_main.stats_lock);
-	for (i = 0; (i < NSS_UDP_ST_STATS_TIMESTAMP_MAX); i++) {
-		stats_shadow[i] = nss_udp_st_stats_timestamp[i];
-	}
-	spin_unlock_bh(&nss_top_main.stats_lock);
-	size_wr += nss_stats_print("udp_st", "udp_st timestamp mode stats"
-					, NSS_STATS_SINGLE_INSTANCE
-					, nss_udp_st_strings_timestamp_stats
-					, stats_shadow
-					, NSS_UDP_ST_STATS_TIMESTAMP_MAX
-					, lbuf, size_wr, size_al);
-
-	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, strlen(lbuf));
-	kfree(lbuf);
-	kfree(stats_shadow);
-
-
-	return bytes_read;
-}
-
-/*
- * nss_udp_st_stats_ops.
- */
-NSS_STATS_DECLARE_FILE_OPERATIONS(udp_st);
-
-/*
- * nss_udp_st_stats_dentry_create()
- *	Create udp_st statistics debug entry.
- */
-void nss_udp_st_stats_dentry_create(void)
-{
-	nss_stats_create_dentry("udp_st", &nss_udp_st_stats_ops);
-}
-
-/*
- * nss_udp_st_stats_reset()
- *	Reset the udp_st statistics.
- */
-void nss_udp_st_stats_reset(uint32_t if_num)
-{
-	uint32_t i;
-
-	/*
-	 * Reset common node stats.
-	 */
-	nss_stats_reset_common_stats(if_num);
-
-	/*
-	 * Reset error stats.
-	 */
-	spin_lock_bh(&nss_top_main.stats_lock);
-	for (i = 0; i < NSS_UDP_ST_ERROR_MAX; i++) {
-		nss_udp_st_errors[i] = 0;
-	}
-
-	/*
-	 * Reset timestamp mode stats.
-	 */
-	for(i = 0; i < NSS_UDP_ST_STATS_TIMESTAMP_MAX; i++){
-		nss_udp_st_stats_timestamp[i] = 0;
-	}
-	spin_unlock_bh(&nss_top_main.stats_lock);
-}
-
-/*
- * nss_udp_st_stats_sync()
- *	Handle the syncing of UDP_ST node statistics.
- */
-void nss_udp_st_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_udp_st_stats *nus)
-{
-	struct nss_top_instance *nss_top = nss_ctx->nss_top;
-	uint32_t i, j;
-
-	spin_lock_bh(&nss_top->stats_lock);
-
-	nss_top->stats_node[NSS_UDP_ST_INTERFACE][NSS_STATS_NODE_RX_PKTS] += nus->nstats.node_stats.rx_packets;
-	nss_top->stats_node[NSS_UDP_ST_INTERFACE][NSS_STATS_NODE_RX_BYTES] += nus->nstats.node_stats.rx_bytes;
-	nss_top->stats_node[NSS_UDP_ST_INTERFACE][NSS_STATS_NODE_TX_PKTS] += nus->nstats.node_stats.tx_packets;
-	nss_top->stats_node[NSS_UDP_ST_INTERFACE][NSS_STATS_NODE_TX_BYTES] += nus->nstats.node_stats.tx_bytes;
-
-	for (i = 0; i < NSS_UDP_ST_ERROR_MAX; i++) {
-		nss_udp_st_errors[i] += nus->nstats.errors[i];
-	}
-
-	for (i = 0; i < NSS_UDP_ST_TEST_MAX; i++) {
-		for (j = 0; j < NSS_UDP_ST_STATS_TIME_MAX; j++) {
-			nss_udp_st_stats_time[i][j] = nus->time_stats[i][j];
-		}
-	}
-
-	nss_udp_st_stats_timestamp[NSS_UDP_ST_STATS_TIMESTAMP_PACKET_LOSS] += nus->tstats[NSS_UDP_ST_STATS_TIMESTAMP_PACKET_LOSS];
-	nss_udp_st_stats_timestamp[NSS_UDP_ST_STATS_TIMESTAMP_OOO_PACKETS] += nus->tstats[NSS_UDP_ST_STATS_TIMESTAMP_OOO_PACKETS];
-	nss_udp_st_stats_timestamp[NSS_UDP_ST_STATS_TIMESTAMP_DELAY_SUM] += nus->tstats[NSS_UDP_ST_STATS_TIMESTAMP_DELAY_SUM];
-	nss_udp_st_stats_timestamp[NSS_UDP_ST_STATS_TIMESTAMP_DELAY_NUM] += nus->tstats[NSS_UDP_ST_STATS_TIMESTAMP_DELAY_NUM];
-
-	/*
-	 * Maximum and Minimum delay is maintained in fw and we just copy it here as it is.
-	 */
-	nss_udp_st_stats_timestamp[NSS_UDP_ST_STATS_TIMESTAMP_DELAY_MAX] = nus->tstats[NSS_UDP_ST_STATS_TIMESTAMP_DELAY_MAX];
-	nss_udp_st_stats_timestamp[NSS_UDP_ST_STATS_TIMESTAMP_DELAY_MIN] = nus->tstats[NSS_UDP_ST_STATS_TIMESTAMP_DELAY_MIN];
-
-	nss_udp_st_stats_timestamp[NSS_UDP_ST_STATS_TIMESTAMP_PACKET_LOSS] -= nus->tstats[NSS_UDP_ST_STATS_TIMESTAMP_OOO_PACKETS];
-	spin_unlock_bh(&nss_top->stats_lock);
-}
--- a/nss_udp_st_stats.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- **************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- **************************************************************************
- */
-
-#ifndef __NSS_UDP_ST_STATS_H
-#define __NSS_UDP_ST_STATS_H
-
-#include <nss_cmn.h>
-
-/*
- * nss_udp_st_stats.h
- *	NSS driver UDP_ST statistics header file.
- */
-
-/*
- * udp_st statistics APIs
- */
-extern void nss_udp_st_stats_reset(uint32_t if_num);
-extern void nss_udp_st_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_udp_st_stats *nus);
-extern void nss_udp_st_stats_dentry_create(void);
-
-#endif /* __NSS_UDP_ST_STATS_H */
--- a/nss_udp_st_strings.c
+++ /dev/null
@@ -1,185 +0,0 @@
-/*
- **************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- **************************************************************************
- */
-
-#include "nss_stats.h"
-#include "nss_core.h"
-#include <nss_udp_st.h>
-#include "nss_strings.h"
-
-/*
- * nss_udp_st_strings_error_stats
- *	Statistics strings for udp_st errors.
- */
-struct nss_stats_info nss_udp_st_strings_error_stats[NSS_UDP_ST_ERROR_MAX] = {
-	{"error_none"				, NSS_STATS_TYPE_SPECIAL},
-	{"incorrect_rate"			, NSS_STATS_TYPE_DROP},
-	{"incorrect_buffer_size"		, NSS_STATS_TYPE_DROP},
-	{"memory_failure"			, NSS_STATS_TYPE_DROP},
-	{"incorrect_state"			, NSS_STATS_TYPE_DROP},
-	{"incorrect_flags"			, NSS_STATS_TYPE_DROP},
-	{"entry_exist"				, NSS_STATS_TYPE_DROP},
-	{"entry_add_failed"			, NSS_STATS_TYPE_DROP},
-	{"entry_not_exist"			, NSS_STATS_TYPE_DROP},
-	{"wrong_start_msg_type"			, NSS_STATS_TYPE_DROP},
-	{"wrong_stop_msg_type"			, NSS_STATS_TYPE_DROP},
-	{"too_many_users"			, NSS_STATS_TYPE_DROP},
-	{"unknown_msg_type"			, NSS_STATS_TYPE_DROP},
-	{"pb_alloc_failure"			, NSS_STATS_TYPE_DROP},
-	{"pb_size_failure"			, NSS_STATS_TYPE_DROP},
-	{"drop_queue_failure"			, NSS_STATS_TYPE_DROP},
-	{"timer_call_is_missed"			, NSS_STATS_TYPE_SPECIAL},
-	{"encap_entry_lookup_failed"		,NSS_STATS_TYPE_DROP},
-};
-
-/*
- * nss_udp_st_strings_rx_time_stats
- *	Statistics strings for Rx udp_st time.
- */
-struct nss_stats_info nss_udp_st_strings_rx_time_stats[NSS_UDP_ST_STATS_TIME_MAX] = {
-	{"rx_start_time"		, NSS_STATS_TYPE_SPECIAL},
-	{"rx_current_time"		, NSS_STATS_TYPE_SPECIAL},
-	{"rx_elapsed_time"		, NSS_STATS_TYPE_SPECIAL}
-};
-
-/*
- * nss_udp_st_strings_tx_time_stats
- *	Statistics strings for Tx udp_st time.
- */
-struct nss_stats_info nss_udp_st_strings_tx_time_stats[NSS_UDP_ST_STATS_TIME_MAX] = {
-	{"tx_start_time"		, NSS_STATS_TYPE_SPECIAL},
-	{"tx_current_time"		, NSS_STATS_TYPE_SPECIAL},
-	{"tx_elapsed_time"			, NSS_STATS_TYPE_SPECIAL}
-};
-
-/*
- * nss_udp_st_strings_timestamp_stats
- *	Statistics strings for timestamp mode stats.
- */
-struct nss_stats_info nss_udp_st_strings_timestamp_stats[NSS_UDP_ST_STATS_TIMESTAMP_MAX] = {
-	{"Packet_Lost"		, NSS_STATS_TYPE_SPECIAL},
-	{"Out_of_order_packets"		, NSS_STATS_TYPE_SPECIAL},
-	{"Delay_sum"			, NSS_STATS_TYPE_SPECIAL},
-	{"Delay_num"			, NSS_STATS_TYPE_SPECIAL},
-	{"Delay_max"			, NSS_STATS_TYPE_SPECIAL},
-	{"Delay_min"			, NSS_STATS_TYPE_SPECIAL},
-};
-
-/*
- * nss_udp_st_error_stats_strings_read()
- *	Read udp_st error statistics names.
- */
-static ssize_t nss_udp_st_error_stats_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_udp_st_strings_error_stats, NSS_UDP_ST_ERROR_MAX);
-}
-
-/*
- * nss_udp_st_rx_time_stats_strings_read()
- *	Read Rx udp_st time statistics names.
- */
-static ssize_t nss_udp_st_rx_time_stats_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_udp_st_strings_rx_time_stats, NSS_UDP_ST_STATS_TIME_MAX);
-}
-
-/*
- * nss_udp_st_tx_time_stats_strings_read()
- *	Read Tx udp_st time statistics names.
- */
-static ssize_t nss_udp_st_tx_time_stats_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_udp_st_strings_tx_time_stats, NSS_UDP_ST_STATS_TIME_MAX);
-}
-
-/*
- * nss_udp_st_timestamp_stats_strings_read()
- *	Read udp_st timestamp mode statistics names.
- */
-static ssize_t nss_udp_st_timestamp_stats_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_udp_st_strings_timestamp_stats, NSS_UDP_ST_STATS_TIMESTAMP_MAX);
-}
-
-/*
- * nss_udp_st_error_stats_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(udp_st_error_stats);
-
-/*
- * nss_udp_st_rx_time_stats_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(udp_st_rx_time_stats);
-
-/*
- * nss_udp_st_tx_time_stats_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(udp_st_tx_time_stats);
-
-/*
- * nss_udp_st_timestamp_stats_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(udp_st_timestamp_stats);
-
-/*
- * nss_udp_st_strings_dentry_create()
- *      Create udp_st statistics strings debug entry.
- */
-void nss_udp_st_strings_dentry_create(void)
-{
-	struct dentry *dir_d;
-	struct dentry *file_d;
-
-	if (!nss_top_main.strings_dentry) {
-		nss_warning("qca-nss-drv/strings is not present");
-		return;
-	}
-
-	dir_d = debugfs_create_dir("udp_st", nss_top_main.strings_dentry);
-	if (!dir_d) {
-		nss_warning("Failed to create qca-nss-drv/strings/udp_st directory");
-		return;
-	}
-
-	file_d = debugfs_create_file("error_stats_str", 0400, dir_d, &nss_top_main, &nss_udp_st_error_stats_strings_ops);
-	if (!file_d) {
-		nss_warning("Failed to create qca-nss-drv/stats/udp_st/error_stats_str file");
-		goto fail;
-	}
-
-	file_d = debugfs_create_file("rx_time_stats_str", 0400, dir_d, &nss_top_main, &nss_udp_st_rx_time_stats_strings_ops);
-	if (!file_d) {
-		nss_warning("Failed to create qca-nss-drv/stats/udp_st/rx_time_stats_str file");
-		goto fail;
-	}
-
-	file_d = debugfs_create_file("tx_time_stats_str", 0400, dir_d, &nss_top_main, &nss_udp_st_tx_time_stats_strings_ops);
-	if (!file_d) {
-		nss_warning("Failed to create qca-nss-drv/stats/udp_st/tx_time_stats_str file");
-		goto fail;
-	}
-
-	file_d = debugfs_create_file("timestamp_stats_str", 0400, dir_d, &nss_top_main, &nss_udp_st_timestamp_stats_strings_ops);
-	if (!file_d) {
-		nss_warning("Failed to create qca-nss-drv/stats/udp_st/timestamp_stats_str file");
-		goto fail;
-	}
-	return;
-fail:
-	debugfs_remove_recursive(dir_d);
-}
--- a/nss_udp_st_strings.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- **************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- * Copyright (c) 2022 Qualcomm Innovation Center, Inc. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- **************************************************************************
- */
-
-#ifndef __NSS_UDP_ST_STRINGS_H
-#define __NSS_UDP_ST_STRINGS_H
-
-extern struct nss_stats_info nss_udp_st_strings_error_stats[NSS_UDP_ST_ERROR_MAX];
-extern struct nss_stats_info nss_udp_st_strings_rx_time_stats[NSS_UDP_ST_STATS_TIME_MAX];
-extern struct nss_stats_info nss_udp_st_strings_tx_time_stats[NSS_UDP_ST_STATS_TIME_MAX];
-extern struct nss_stats_info nss_udp_st_strings_timestamp_stats[NSS_UDP_ST_STATS_TIMESTAMP_MAX];
-extern void nss_udp_st_strings_dentry_create(void);
-
-#endif /* __NSS_UDP_ST_STRINGS_H */
--- a/nss_vxlan.c
+++ b/nss_vxlan.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -226,7 +226,6 @@ bool nss_vxlan_unregister_if(uint32_t if
 	}
 
 	nss_core_unregister_handler(nss_ctx, if_num);
-	nss_core_unregister_msg_handler(nss_ctx, if_num);
 	nss_core_unregister_subsys_dp(nss_ctx, if_num);
 	return true;
 }
--- a/nss_wifi_ext_vdev.c
+++ /dev/null
@@ -1,338 +0,0 @@
-/*
- **************************************************************************
- * Copyright (c) 2020, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- **************************************************************************
- */
-
-#include "nss_tx_rx_common.h"
-#include "nss_wifi_ext_vdev_stats.h"
-#include "nss_wifi_ext_vdev_log.h"
-
-#define NSS_WIFI_EXT_VDEV_TX_TIMEOUT 3000 /* 3 seconds */
-
-/*
- * Private data structure
- */
-static struct nss_wifi_ext_vdev_pvt {
-	struct semaphore sem;
-	struct completion complete;
-	int response;
-	void *cb;
-	void *app_data;
-} wifi_ext_vdev_pvt;
-
-/*
- * nss_wifi_ext_vdev_verify_if_num()
- *	Verify if_num passed to us.
- */
-static bool nss_wifi_ext_vdev_verify_if_num(uint32_t if_num)
-{
-	uint32_t type = nss_dynamic_interface_get_type(nss_wifi_ext_vdev_get_ctx(), if_num);
-
-	switch (type) {
-	case NSS_DYNAMIC_INTERFACE_TYPE_WIFI_EXT_VDEV_WDS:
-	case NSS_DYNAMIC_INTERFACE_TYPE_WIFI_EXT_VDEV_VLAN:
-		return true;
-	default:
-		return false;
-	}
-}
-
-/*
- * nss_wifi_ext_vdev_handler()
- *	Handle NSS -> HLOS messages for wifi_ext_vdev
- */
-static void nss_wifi_ext_vdev_handler(struct nss_ctx_instance *nss_ctx, struct nss_cmn_msg *ncm, void *app_data)
-{
-	struct nss_wifi_ext_vdev_msg *nwevm = (struct nss_wifi_ext_vdev_msg *)ncm;
-	void *ctx;
-
-	nss_wifi_ext_vdev_msg_callback_t cb;
-
-	NSS_VERIFY_CTX_MAGIC(nss_ctx);
-	BUG_ON(!nss_wifi_ext_vdev_verify_if_num(ncm->interface));
-
-	/*
-	 * Trace Messages
-	 */
-	nss_wifi_ext_vdev_log_rx_msg(nwevm);
-
-	/*
-	 * Is this a valid request/response packet?
-	 */
-	if (ncm->type >= NSS_WIFI_EXT_VDEV_MSG_MAX) {
-		nss_warning("%px: received invalid message %d for WiFi extended VAP interface %d", nss_ctx, ncm->type, ncm->interface);
-		return;
-	}
-
-	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_wifi_ext_vdev_msg)) {
-		nss_warning("%px: wifi_ext_vdev message length is invalid: %d", nss_ctx, ncm->len);
-		return;
-	}
-
-	/*
-	 * Check messages
-	 */
-	switch (nwevm->cm.type) {
-	case NSS_WIFI_EXT_VDEV_MSG_STATS_SYNC:
-		nss_wifi_ext_vdev_stats_sync(nss_ctx, &nwevm->msg.stats, ncm->interface);
-		break;
-	}
-
-	/*
-	 * Update the callback and app_data for NOTIFY messages
-	 */
-	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
-		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
-		ncm->app_data = (nss_ptr_t)nss_ctx->subsys_dp_register[ncm->interface].app_data;
-	}
-
-	nss_core_log_msg_failures(nss_ctx, ncm);
-
-	/*
-	 * callback
-	 */
-	cb = (nss_wifi_ext_vdev_msg_callback_t)ncm->cb;
-	ctx = (void *)ncm->app_data;
-
-	/*
-	 * call the callback
-	 */
-	if (!cb) {
-		return;
-	}
-
-	cb(ctx, ncm);
-}
-
-/*
- * nss_wifi_ext_vdev_msg_init()
- *	Initialize wifi message.
- */
-void nss_wifi_ext_vdev_msg_init(struct nss_wifi_ext_vdev_msg *nim, uint32_t if_num,
-			uint32_t type, uint32_t len,
-			nss_wifi_ext_vdev_msg_callback_t cb, void *app_data)
-{
-	nss_cmn_msg_init(&nim->cm, if_num, type, len, cb, app_data);
-}
-EXPORT_SYMBOL(nss_wifi_ext_vdev_msg_init);
-
-/*
- * nss_wifi_ext_vdev_tx_msg()
- *	Transmit a wifi vdev message to NSSFW
- */
-nss_tx_status_t nss_wifi_ext_vdev_tx_msg(struct nss_ctx_instance *nss_ctx, struct nss_wifi_ext_vdev_msg *msg)
-{
-	struct nss_cmn_msg *ncm = &msg->cm;
-
-	/*
-	 * Trace Messages
-	 */
-	nss_wifi_ext_vdev_log_tx_msg(msg);
-
-	if (ncm->type >= NSS_WIFI_EXT_VDEV_MSG_MAX) {
-		nss_warning("%px: wifi vdev message type out of range: %d", nss_ctx, ncm->type);
-		return NSS_TX_FAILURE;
-	}
-
-	BUG_ON(!nss_wifi_ext_vdev_verify_if_num(ncm->interface));
-
-	return nss_core_send_cmd(nss_ctx, msg, sizeof(*msg), NSS_NBUF_PAYLOAD_SIZE);
-}
-EXPORT_SYMBOL(nss_wifi_ext_vdev_tx_msg);
-
-/*
- * nss_wifi_ext_vdev_callback()
- *	Callback to handle the completion of NSS->HLOS messages.
- */
-static void nss_wifi_ext_vdev_callback(void *app_data, struct nss_cmn_msg *ncm)
-{
-	nss_wifi_ext_vdev_msg_callback_t callback = (nss_wifi_ext_vdev_msg_callback_t)wifi_ext_vdev_pvt.cb;
-	void *data = wifi_ext_vdev_pvt.app_data;
-
-	wifi_ext_vdev_pvt.response = NSS_TX_SUCCESS;
-	wifi_ext_vdev_pvt.cb = NULL;
-	wifi_ext_vdev_pvt.app_data = NULL;
-
-	if (ncm->response != NSS_CMN_RESPONSE_ACK) {
-		nss_warning("WiFi extension vap Error response %d\n", ncm->response);
-		wifi_ext_vdev_pvt.response = NSS_TX_FAILURE;
-	}
-
-	if (callback) {
-		callback(data, ncm);
-	}
-	complete(&wifi_ext_vdev_pvt.complete);
-}
-
-/*
- * nss_wifi_ext_vdev_tx_msg()
- *	Transmit a WiFi extended virtual interface to NSS firmware synchronously.
- */
-nss_tx_status_t nss_wifi_ext_vdev_tx_msg_sync(struct nss_ctx_instance *nss_ctx, struct nss_wifi_ext_vdev_msg *nwevm)
-{
-	nss_tx_status_t status;
-	int ret = 0;
-
-	down(&wifi_ext_vdev_pvt.sem);
-	wifi_ext_vdev_pvt.cb = (void *)nwevm->cm.cb;
-	wifi_ext_vdev_pvt.app_data = (void *)nwevm->cm.app_data;
-
-	nwevm->cm.cb = (nss_ptr_t)nss_wifi_ext_vdev_callback;
-	nwevm->cm.app_data = (nss_ptr_t)NULL;
-
-	status = nss_wifi_ext_vdev_tx_msg(nss_ctx, nwevm);
-	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%px: wifi_ext_vdev_tx_msg failed\n", nss_ctx);
-		up(&wifi_ext_vdev_pvt.sem);
-		return status;
-	}
-
-	/*
-	 * Wait for the acknowledgement
-	 */
-	ret = wait_for_completion_timeout(&wifi_ext_vdev_pvt.complete, msecs_to_jiffies(NSS_WIFI_EXT_VDEV_TX_TIMEOUT));
-	if (!ret) {
-		nss_warning("%px: WiFi extended vap msg tx failed due to timeout\n", nss_ctx);
-		wifi_ext_vdev_pvt.response = NSS_TX_FAILURE;
-	}
-
-	status = wifi_ext_vdev_pvt.response;
-	up(&wifi_ext_vdev_pvt.sem);
-	return status;
-}
-EXPORT_SYMBOL(nss_wifi_ext_vdev_tx_msg_sync);
-
-/*
- * nss_wifi_ext_vdev_tx_buf
- * 	Send data packet for vap processing
- */
-nss_tx_status_t nss_wifi_ext_vdev_tx_buf(struct nss_ctx_instance *nss_ctx, struct sk_buff *skb, uint32_t if_num)
-{
-	BUG_ON(!nss_wifi_ext_vdev_verify_if_num(if_num));
-
-	return nss_core_send_packet(nss_ctx, skb, if_num, H2N_BIT_FLAG_BUFFER_REUSABLE);
-}
-EXPORT_SYMBOL(nss_wifi_ext_vdev_tx_buf);
-
-/*
- * nss_wifi_ext_vdev_set_next_hop()
- *	Set the WiFI extended vap next hop.
- */
-nss_tx_status_t nss_wifi_ext_vdev_set_next_hop(struct nss_ctx_instance *ctx, int if_num, int next_hop)
-{
-	struct nss_wifi_ext_vdev_msg *nwevm = kzalloc(sizeof(struct nss_wifi_ext_vdev_msg), GFP_KERNEL);
-	struct nss_wifi_ext_vdev_set_next_hop_msg *nhm = NULL;
-	nss_tx_status_t status;
-
-	if (!nwevm) {
-		nss_warning("%px: Unable to allocate next hop message", ctx);
-		return NSS_TX_FAILURE;
-	}
-
-	nhm = &nwevm->msg.wnhm;
-
-	nhm->if_num = next_hop;
-	nss_wifi_ext_vdev_msg_init(nwevm, if_num, NSS_WIFI_EXT_VDEV_SET_NEXT_HOP,
-			sizeof(struct nss_wifi_ext_vdev_set_next_hop_msg), NULL, NULL);
-
-	status = nss_wifi_ext_vdev_tx_msg(ctx, nwevm);
-	if (status != NSS_TX_SUCCESS) {
-		nss_warning("%px: Unable to send next hop message", ctx);
-	}
-
-	kfree(nwevm);
-	return status;
-}
-EXPORT_SYMBOL(nss_wifi_ext_vdev_set_next_hop);
-
-/*
- * nss_get_wifi_ext_vdev_ext_context()
- *	Return the core ctx which the feature is on
- */
-struct nss_ctx_instance *nss_wifi_ext_vdev_get_ctx(void)
-{
-	return (struct nss_ctx_instance *)&nss_top_main.nss[nss_top_main.wifi_handler_id];
-}
-EXPORT_SYMBOL(nss_wifi_ext_vdev_get_ctx);
-
-/*
- * nss_wifi_ext_vdev_register_if()
- */
-struct nss_ctx_instance *nss_wifi_ext_vdev_register_if(uint32_t if_num,
-				nss_wifi_ext_vdev_data_callback_t data_callback,
-				nss_wifi_ext_vdev_ext_data_callback_t ext_callback,
-				nss_wifi_ext_vdev_msg_callback_t event_callback,
-				struct net_device *netdev,
-				uint32_t features, void *app_data)
-{
-	struct nss_ctx_instance *nss_ctx = nss_wifi_ext_vdev_get_ctx();
-
-	BUG_ON(!nss_wifi_ext_vdev_verify_if_num(if_num));
-
-	nss_core_register_subsys_dp(nss_ctx, if_num, data_callback, ext_callback, app_data, netdev, features);
-
-	nss_core_register_msg_handler(nss_ctx, if_num, event_callback);
-
-	nss_core_register_handler(nss_ctx, if_num, nss_wifi_ext_vdev_handler, app_data);
-
-	nss_wifi_ext_vdev_stats_register(if_num, netdev);
-
-	return nss_ctx;
-}
-EXPORT_SYMBOL(nss_wifi_ext_vdev_register_if);
-
-/*
- * nss_wifi_ext_vdev_unregister_if()
- */
-bool nss_wifi_ext_vdev_unregister_if(uint32_t if_num)
-{
-	struct nss_ctx_instance *nss_ctx = nss_wifi_ext_vdev_get_ctx();
-	struct net_device *netdev;
-
-	BUG_ON(!nss_wifi_ext_vdev_verify_if_num(if_num));
-
-	nss_assert(nss_ctx);
-
-	netdev = nss_cmn_get_interface_dev(nss_ctx, if_num);
-	if (!netdev) {
-		nss_warning("%px: Unable to find net device for the interface %d\n", nss_ctx, if_num);
-		return false;
-	}
-	nss_core_unregister_subsys_dp(nss_ctx, if_num);
-
-	nss_core_unregister_msg_handler(nss_ctx, if_num);
-
-	nss_core_unregister_handler(nss_ctx, if_num);
-
-	nss_wifi_ext_vdev_stats_unregister(if_num, netdev);
-	return true;
-}
-EXPORT_SYMBOL(nss_wifi_ext_vdev_unregister_if);
-
-/*
- * nss_wifi_ext_vdev_register_handler()
- *	Register debugfs handler received on base interface
- */
-void nss_wifi_ext_vdev_register_handler(void)
-{
-	struct nss_ctx_instance *nss_ctx = nss_wifi_ext_vdev_get_ctx();
-
-	nss_info("nss_wifi_ext_vdev_handler");
-	sema_init(&wifi_ext_vdev_pvt.sem, 1);
-	init_completion(&wifi_ext_vdev_pvt.complete);
-	nss_core_register_handler(nss_ctx, NSS_WIFI_EXT_VDEV_INTERFACE, nss_wifi_ext_vdev_handler, NULL);
-	nss_wifi_ext_vdev_stats_dentry_create();
-}
--- a/nss_wifi_ext_vdev_log.c
+++ /dev/null
@@ -1,220 +0,0 @@
-/*
- **************************************************************************
- * Copyright (c) 2020, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- **************************************************************************
- */
-
-/*
- * nss_wifi_ext_vdev_log.c
- *	NSS WiFi extended VAP logger file.
- */
-
-#include "nss_core.h"
-
-#define NSS_WIFI_EXT_VDEV_LOG_MESSAGE_TYPE_INDEX(type) ((type) - NSS_IF_MAX_MSG_TYPES)
-
-/*
- * nss_wifi_ext_vdev_log_message_types_str
- *	NSS WiFi extended VAP message strings
- */
-static int8_t *nss_wifi_ext_vdev_log_message_types_str[NSS_WIFI_EXT_VDEV_MSG_MAX] __maybe_unused = {
-	"WiFi Common I/F Message",
-	"WiFi Extendev VAP configure",
-	"WiFi Extendev VAP configure wds",
-	"WiFi Extendev VAP configure next hop",
-	"WiFi Extendev VAP stats",
-	"WiFi Extended VAP configure VLAN"
-};
-
-/*
- * nss_wifi_ext_vdev_log_configure_msg()
- *	Log NSS WiFi extended vap configure message.
- */
-static void nss_wifi_ext_vdev_log_configure_if_msg(struct nss_wifi_ext_vdev_msg *nwevm)
-{
-	struct nss_wifi_ext_vdev_configure_if_msg *cmsg __maybe_unused = &nwevm->msg.cmsg;
-	nss_trace("%px: WiFi extended VAP configure message \n"
-		"Mac address: %pM\n"
-		"Radio interface num: %d\n"
-		"Parent VAP interface num: %d\n",
-		cmsg, cmsg->mac_addr, cmsg->radio_ifnum,
-		cmsg->pvap_ifnum);
-
-}
-
-/*
- * nss_wifi_ext_vdev_log_wds_msg()
- *	Log NSS WiFi extended vap wds message.
- */
-static void nss_wifi_ext_vdev_log_wds_msg(struct nss_wifi_ext_vdev_msg *nwevm)
-{
-	struct nss_wifi_ext_vdev_wds_msg *wmsg __maybe_unused = &nwevm->msg.wmsg;
-	nss_trace("%px: NSS WiFi extended VAP wds message: \n"
-		"WDS sta ID: %d\n"
-		"WDS sta macaddr: %pM\n",
-		wmsg, wmsg->wds_peer_id,
-		wmsg->mac_addr);
-}
-
-/*
- * nss_wifi_ext_vdev_set_nxt_hop_msg()
- *	Set the next hop message.
- */
-static void nss_wifi_ext_vdev_set_nxt_hop_msg(struct nss_wifi_ext_vdev_msg *nwevm)
-{
-	struct nss_wifi_ext_vdev_set_next_hop_msg *wnhm __maybe_unused = &nwevm->msg.wnhm;
-	nss_trace("%px: NSS WiFi extended vap set next hop message: \n"
-		"Next hop if num: %d\n",
-		wnhm, wnhm->if_num);
-
-}
-
-/*
- * nss_wifi_ext_vdev_linkup_msg()
- *	Log NSS linkup message.
- */
-static void nss_wifi_ext_vdev_linkup_msg(struct nss_wifi_ext_vdev_msg *nwevm)
-{
-	union nss_if_msgs *if_msg __maybe_unused = &nwevm->msg.if_msg;
-	nss_trace("%px: NSS WiFi ext linkup message\n", if_msg);
-}
-
-/*
- * nss_wifi_ext_vdev_linkdown_msg()
- *	Log NSS linkdown message.
- */
-static void nss_wifi_ext_vdev_linkdown_msg(struct nss_wifi_ext_vdev_msg *nwevm)
-{
-	union nss_if_msgs *if_msg __maybe_unused = &nwevm->msg.if_msg;
-	nss_trace("%px: NSS WiFi ext linkdown message\n", if_msg);
-}
-
-/*
- * nss_wifi_ext_vdev_macaddr_set_msg()
- *	Set/Change the mac address
- */
-static void nss_wifi_ext_vdev_macaddr_set_msg(struct nss_wifi_ext_vdev_msg *nwevm)
-{
-	union nss_if_msgs *if_msg = &nwevm->msg.if_msg;
-	struct nss_if_mac_address_set *nimas __maybe_unused = &if_msg->mac_address_set;
-	nss_trace("%px: NSS WiFi ext change mac addr: \n"
-		"mac addr %pM\n",
-		nimas, nimas->mac_addr);
-}
-
-/*
- * nss_wifi_ext_vdev_log_vlan_msg()
- *	Configure vlan message.
- */
-static void nss_wifi_ext_vdev_log_vlan_msg(struct nss_wifi_ext_vdev_msg *nwevm)
-{
-	struct nss_wifi_ext_vdev_vlan_msg *vmsg __maybe_unused = &nwevm->msg.vmsg;
-	nss_trace("%px: NSS WiFi extended VAP vlan message: \n"
-		"vlan ID %hu\n",
-		vmsg, vmsg->vlan_id);
-}
-
-/*
- * nss_wifi_ext_vdev_log_verbose()
- *	Log message contents.
- */
-static void nss_wifi_ext_vdev_log_verbose(struct nss_wifi_ext_vdev_msg *nwevm)
-{
-	switch (nwevm->cm.type) {
-	case NSS_WIFI_EXT_VDEV_MSG_CONFIGURE_IF:
-		nss_wifi_ext_vdev_log_configure_if_msg(nwevm);
-		break;
-
-	case NSS_WIFI_EXT_VDEV_MSG_CONFIGURE_WDS :
-		nss_wifi_ext_vdev_log_wds_msg(nwevm);
-		break;
-
-	case NSS_WIFI_EXT_VDEV_SET_NEXT_HOP:
-		nss_wifi_ext_vdev_set_nxt_hop_msg(nwevm);
-		break;
-
-	case NSS_WIFI_EXT_VDEV_MSG_STATS_SYNC:
-		break;
-
-	case NSS_IF_OPEN:
-		nss_wifi_ext_vdev_linkup_msg(nwevm);
-		break;
-
-	case NSS_IF_CLOSE:
-		nss_wifi_ext_vdev_linkdown_msg(nwevm);
-		break;
-
-	case NSS_IF_MAC_ADDR_SET:
-		nss_wifi_ext_vdev_macaddr_set_msg(nwevm);
-		break;
-
-	case NSS_WIFI_EXT_VDEV_MSG_CONFIGURE_VLAN:
-		nss_wifi_ext_vdev_log_vlan_msg(nwevm);
-		break;
-
-	default:
-		nss_trace("%px: Invalid message type\n", nwevm);
-		break;
-	}
-}
-
-/*
- * nss_wifi_ext_vdev_log_tx_msg()
- *	Log messages transmitted to FW.
- */
-void nss_wifi_ext_vdev_log_tx_msg(struct nss_wifi_ext_vdev_msg *nwevm)
-{
-	uint32_t type_idx = 0;
-	if (nwevm->cm.type >= NSS_WIFI_EXT_VDEV_MSG_MAX) {
-		nss_warning("%px: Invalid message type\n", nwevm);
-		return;
-	}
-
-	type_idx = (nwevm->cm.type > NSS_IF_MAX_MSG_TYPES) ?
-			(NSS_WIFI_EXT_VDEV_LOG_MESSAGE_TYPE_INDEX(nwevm->cm.type)) : 0;
-
-	nss_info("%px: type[%d]:%s\n", nwevm, nwevm->cm.type, nss_wifi_ext_vdev_log_message_types_str[type_idx]);
-	nss_wifi_ext_vdev_log_verbose(nwevm);
-}
-
-/*
- * nss_wifi_ext_vdev_log_rx_msg()
- *	Log messages received from FW.
- */
-void nss_wifi_ext_vdev_log_rx_msg(struct nss_wifi_ext_vdev_msg *nwevm)
-{
-	uint32_t type_idx = 0;
-	if (nwevm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%px: Invalid response\n", nwevm);
-		return;
-	}
-
-	type_idx = (nwevm->cm.type > NSS_IF_MAX_MSG_TYPES) ?
-			(NSS_WIFI_EXT_VDEV_LOG_MESSAGE_TYPE_INDEX(nwevm->cm.type)) : 0;
-
-	if (nwevm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (nwevm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%px: type[%d]:%s, response[%d]:%s\n", nwevm, nwevm->cm.type,
-			nss_wifi_ext_vdev_log_message_types_str[type_idx],
-			nwevm->cm.response, nss_cmn_response_str[nwevm->cm.response]);
-		goto verbose;
-	}
-
-	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s\n",
-		nwevm, nwevm->cm.type, nss_wifi_ext_vdev_log_message_types_str[type_idx],
-		nwevm->cm.response, nss_cmn_response_str[nwevm->cm.response]);
-
-verbose:
-	nss_wifi_ext_vdev_log_verbose(nwevm);
-}
--- a/nss_wifi_ext_vdev_log.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- **************************************************************************
- * Copyright (c) 2020, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- **************************************************************************
- */
-
-#ifndef __NSS_WIFI_EXT_VDEV_LOG_H
-#define __NSS_WIFI_EXT_VDEV_LOG_H
-
-/*
- * nss_wifi_ext_vdev_log_tx_msg
- *	Logs a wifi_ext_vdev message that is sent to the NSS firmware.
- */
-void nss_wifi_ext_vdev_log_tx_msg(struct nss_wifi_ext_vdev_msg *nwevm);
-
-/*
- * nss_wifi_ext_vdev_log_rx_msg
- *	Logs a wifi_ext_vdev message that is received from the NSS firmware.
- */
-void nss_wifi_ext_vdev_log_rx_msg(struct nss_wifi_ext_vdev_msg *nwevm);
-
-#endif /* __NSS_WIFI_EXT_VDEV_LOG_H */
--- a/nss_wifi_ext_vdev_stats.c
+++ /dev/null
@@ -1,234 +0,0 @@
-/*
- **************************************************************************
- * Copyright (c) 2020, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- **************************************************************************
- */
-
-#include "nss_tx_rx_common.h"
-#include "nss_wifi_ext_vdev_stats.h"
-
-DEFINE_SPINLOCK(nss_wifi_ext_vdev_debug_lock);
-struct nss_wifi_ext_vdev_debug nss_wifi_ext_vdev_debug_stats[NSS_WIFI_EXT_VDEV_MAX];
-
-/*
- * nss_wifi_ext_vdev_debug_str
- *	WiFi extended VAP statistics strings.
- */
-struct nss_stats_info nss_wifi_ext_vdev_debug_str[NSS_WIFI_EXT_VDEV_STATS_MAX] = {
-	{"node_rx_pkts"					, NSS_STATS_TYPE_COMMON},
-	{"node_rx_bytes"				, NSS_STATS_TYPE_COMMON},
-	{"node_tx_pkts"					, NSS_STATS_TYPE_COMMON},
-	{"node_tx_bytes"				, NSS_STATS_TYPE_COMMON},
-	{"node_rx_dropped"				, NSS_STATS_TYPE_DROP},
-	{"mc_count"					, NSS_STATS_TYPE_SPECIAL},
-	{"uc_count"					, NSS_STATS_TYPE_SPECIAL},
-	{"nxt_hop_drop"					, NSS_STATS_TYPE_DROP},
-};
-
-/*
- * WiFi extended vdev statistics APIs
- */
-
-/*
- * nss_wifi_ext_vdev_stats_register()
- *	Register debug statistic for WiFi extended VAP.
- */
-void nss_wifi_ext_vdev_stats_register(uint32_t if_num, struct net_device *netdev)
-{
-	int i;
-
-	spin_lock_bh(&nss_wifi_ext_vdev_debug_lock);
-	for (i = 0; i < NSS_WIFI_EXT_VDEV_MAX; i++) {
-		if (!nss_wifi_ext_vdev_debug_stats[i].valid) {
-			nss_wifi_ext_vdev_debug_stats[i].valid = true;
-			nss_wifi_ext_vdev_debug_stats[i].if_num = if_num;
-			nss_wifi_ext_vdev_debug_stats[i].if_index = netdev->ifindex;
-			break;
-		}
-	}
-
-	spin_unlock_bh(&nss_wifi_ext_vdev_debug_lock);
-}
-
-/*
- * nss_wifi_ext_vdev_stats_unregister()
- *	Register debug statistic for WiFi extended vap.
- */
-void nss_wifi_ext_vdev_stats_unregister(uint32_t if_num, struct net_device *netdev)
-{
-	int i;
-
-	spin_lock_bh(&nss_wifi_ext_vdev_debug_lock);
-	for (i = 0; i < NSS_WIFI_EXT_VDEV_MAX; i++) {
-		if (nss_wifi_ext_vdev_debug_stats[i].if_num == if_num) {
-			memset(&nss_wifi_ext_vdev_debug_stats[i], 0,
-			       sizeof(struct nss_wifi_ext_vdev_debug));
-			break;
-		}
-	}
-	spin_unlock_bh(&nss_wifi_ext_vdev_debug_lock);
-}
-
-/*
- * nss_wifi_ext_vdev_stats_sync()
- *	Sync function for WiFi extendev vap statistics.
- */
-void nss_wifi_ext_vdev_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_wifi_ext_vdev_stats *stats_msg,
-					uint16_t if_num)
-{
-	int i;
-	struct nss_wifi_ext_vdev_debug *s = NULL;
-
-	NSS_VERIFY_CTX_MAGIC(nss_ctx);
-
-	spin_lock_bh(&nss_wifi_ext_vdev_debug_lock);
-	for (i = 0; i < NSS_WIFI_EXT_VDEV_MAX; i++) {
-		if (nss_wifi_ext_vdev_debug_stats[i].if_num == if_num) {
-			s = &nss_wifi_ext_vdev_debug_stats[i];
-			break;
-		}
-	}
-
-	if (!s) {
-		spin_unlock_bh(&nss_wifi_ext_vdev_debug_lock);
-		nss_warning("%px: Interface:%u not found", nss_ctx, if_num);
-		return;
-	}
-
-	s->stats[NSS_WIFI_EXT_VDEV_STATS_NODE_RX_PKTS ] += stats_msg->node_stats.rx_packets;
-	s->stats[NSS_WIFI_EXT_VDEV_STATS_NODE_RX_BYTES] += stats_msg->node_stats.rx_bytes;
-	s->stats[NSS_WIFI_EXT_VDEV_STATS_NODE_TX_PKTS] += stats_msg->node_stats.tx_packets;
-	s->stats[NSS_WIFI_EXT_VDEV_STATS_NODE_TX_BYTES] += stats_msg->node_stats.tx_bytes;
-	for (i = 0; i < NSS_MAX_NUM_PRI; i++) {
-		s->stats[NSS_WIFI_EXT_VDEV_STATS_NODE_TOTAL_DROPPED] += stats_msg->node_stats.rx_dropped[i];
-	}
-	s->stats[NSS_WIFI_EXT_VDEV_STATS_MULTICAST_COUNT] += stats_msg->mc_count;
-	s->stats[NSS_WIFI_EXT_VDEV_STATS_UNICAST_COUNT] += stats_msg->node_stats.rx_packets - stats_msg->mc_count;
-	s->stats[NSS_WIFI_EXT_VDEV_STATS_NEXT_HOP_DROP_COUNT] += stats_msg->nxt_hop_drp;
-	spin_unlock_bh(&nss_wifi_ext_vdev_debug_lock);
-}
-
-/*
- * nss_wifi_ext_vdev_debug_get()
- *	Get WiFi extendev vap debug statitics.
- */
-static void nss_wifi_ext_vdev_debug_get(struct nss_wifi_ext_vdev_debug *stats)
-{
-	int i;
-
-	if (!stats) {
-		nss_warning("No memory to copy WiFi extended VAP stats");
-		return;
-	}
-
-	spin_lock_bh(&nss_wifi_ext_vdev_debug_lock);
-	for (i = 0; i < NSS_WIFI_EXT_VDEV_MAX; i++) {
-		if (nss_wifi_ext_vdev_debug_stats[i].valid) {
-			memcpy(stats, &nss_wifi_ext_vdev_debug_stats[i],
-				sizeof(struct nss_wifi_ext_vdev_debug));
-			stats++;
-		}
-	}
-	spin_unlock_bh(&nss_wifi_ext_vdev_debug_lock);
-}
-
-/*
- * nss_wifi_ext_vdev_read()
- *	Read WiFi extended VAP statistics
- */
-static ssize_t nss_wifi_ext_vdev_stats_read(struct file *fp, char __user *ubuf,
-					size_t sz, loff_t *ppos)
-{
-	uint32_t max_output_lines = 2 /* header and footer of the interface stats*/
-		+ (NSS_WIFI_EXT_VDEV_STATS_MAX * (NSS_WIFI_EXT_VDEV_MAX + 2)) /* Interface stats */
-		+ 2;
-
-	size_t size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines;
-	size_t size_wr = 0;
-	size_t bytes_read = 0;
-	struct net_device *dev;
-	int id;
-	struct nss_wifi_ext_vdev_debug *wifi_ext_vdev_stats = NULL;
-
-	char *lbuf = kzalloc(size_al, GFP_KERNEL);
-	if (unlikely(lbuf == NULL)) {
-		nss_warning("Could not allocate memory for local statistics buffer");
-		return 0;
-	}
-
-	wifi_ext_vdev_stats = kzalloc((sizeof(struct nss_wifi_ext_vdev_debug) * NSS_WIFI_EXT_VDEV_MAX), GFP_KERNEL);
-	if (unlikely(wifi_ext_vdev_stats == NULL)) {
-		nss_warning("Could not allocate memory for populating stats");
-		kfree(lbuf);
-		return 0;
-	}
-
-	/*
-	 * Get all stats
-	 */
-	nss_wifi_ext_vdev_debug_get(wifi_ext_vdev_stats);
-
-	/*
-	 * WiFi extended vap stats.
-	 */
-	size_wr += nss_stats_banner(lbuf, size_wr, size_al, "WiFi extended VAP stats", NSS_STATS_SINGLE_CORE);
-
-	for (id = 0; id < NSS_WIFI_EXT_VDEV_MAX; id++) {
-		if (!wifi_ext_vdev_stats[id].valid) {
-			continue;
-		}
-
-		dev = dev_get_by_index(&init_net, wifi_ext_vdev_stats[id].if_index);
-		if (likely(dev)) {
-			size_wr += scnprintf(lbuf + size_wr, size_al - size_wr,
-						"%d. nss interface id=%d, netdevice=%s\n",
-						id, wifi_ext_vdev_stats[id].if_num,
-						dev->name);
-			dev_put(dev);
-		} else {
-			size_wr += scnprintf(lbuf + size_wr, size_al - size_wr,
-						"%d. nss interface id=%d\n", id,
-						wifi_ext_vdev_stats[id].if_num);
-		}
-
-		size_wr += nss_stats_print("vdev", "debug", id
-						, nss_wifi_ext_vdev_debug_str
-						, wifi_ext_vdev_stats[id].stats
-						, NSS_WIFI_EXT_VDEV_STATS_MAX
-						, lbuf, size_wr, size_al);
-
-		size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\n");
-	}
-
-	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, size_wr);
-
-	kfree(wifi_ext_vdev_stats);
-	kfree(lbuf);
-	return bytes_read;
-}
-
-/*
- * nss_wifi_ext_vdev_ops
- */
-NSS_STATS_DECLARE_FILE_OPERATIONS(wifi_ext_vdev);
-
-/*
- * nss_wifi_ext_vdev_dentry_create()
- *	Create wifi extension vap statistics debug entry.
- */
-void nss_wifi_ext_vdev_stats_dentry_create(void)
-{
-	nss_stats_create_dentry("wifi_ext_vdev", &nss_wifi_ext_vdev_stats_ops);
-}
--- a/nss_wifi_ext_vdev_stats.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- ******************************************************************************
- * Copyright (c) 2020, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- * ****************************************************************************
- */
-
-#ifndef __NSS_WIFI_EXT_VDEV_STATS_H
-#define __NSS_WIFI_EXT_VDEV_STATS_H
-
-/*
- * WiFi extendev vap debug statistic counters.
- */
-enum nss_wifi_ext_vdev_stats_types {
-	NSS_WIFI_EXT_VDEV_STATS_NODE_RX_PKTS,
-	NSS_WIFI_EXT_VDEV_STATS_NODE_RX_BYTES,
-	NSS_WIFI_EXT_VDEV_STATS_NODE_TX_PKTS,
-	NSS_WIFI_EXT_VDEV_STATS_NODE_TX_BYTES,
-	NSS_WIFI_EXT_VDEV_STATS_NODE_TOTAL_DROPPED,
-	NSS_WIFI_EXT_VDEV_STATS_MULTICAST_COUNT,
-	NSS_WIFI_EXT_VDEV_STATS_UNICAST_COUNT,
-	NSS_WIFI_EXT_VDEV_STATS_NEXT_HOP_DROP_COUNT,
-	NSS_WIFI_EXT_VDEV_STATS_MAX,
-};
-
-/*
- * WiFi extendev vap debug statistics.
- */
-struct nss_wifi_ext_vdev_debug {
-	uint64_t stats[NSS_WIFI_EXT_VDEV_STATS_MAX];
-	int32_t if_index;					/**< Netdevice's ifindex. */
-	uint32_t if_num;					/**< NSS interface number. */
-	bool valid;						/**< Is node valid ? */
-};
-
-/*
- * Data structures to store WiFi extended VAP debug stats.
- */
-extern struct nss_wifi_ext_vdev_debug nss_wifi_ext_vdev_debug_stats[NSS_WIFI_EXT_VDEV_MAX];
-
-/*
- * WiFi extendev vap statistics APIs
- */
-extern void nss_wifi_ext_vdev_stats_register(uint32_t if_num, struct net_device *netdev);
-extern void nss_wifi_ext_vdev_stats_unregister(uint32_t if_num, struct net_device *netdev);
-extern void nss_wifi_ext_vdev_stats_sync(struct nss_ctx_instance *nss_ctx, struct nss_wifi_ext_vdev_stats *stats_msg, uint16_t if_num);
-extern void nss_wifi_ext_vdev_stats_dentry_create(void);
-
-#endif /* __NSS_WIFI_EXT_VDEV_STATS_H */
--- /dev/null
+++ b/nss_wifi_if.c
@@ -0,0 +1,516 @@
+/*
+ **************************************************************************
+ * Copyright (c) 2015-2020, The Linux Foundation. All rights reserved.
+ * Permission to use, copy, modify, and/or distribute this software for
+ * any purpose with or without fee is hereby granted, provided that the
+ * above copyright notice and this permission notice appear in all copies.
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ **************************************************************************
+ */
+
+/*
+ * nss_wifi_if.c
+ *	NSS wifi/redirect handler APIs
+ */
+
+#include "nss_tx_rx_common.h"
+#include "nss_wifi_if_stats.h"
+#include <net/arp.h>
+
+#define NSS_WIFI_IF_TX_TIMEOUT			3000 /* 3 Seconds */
+#define NSS_WIFI_IF_GET_INDEX(if_num)	(if_num-NSS_DYNAMIC_IF_START)
+
+extern int nss_ctl_redirect;
+
+/*
+ * Data structure that holds the wifi interface context.
+ */
+struct nss_wifi_if_handle *wifi_handle[NSS_MAX_DYNAMIC_INTERFACES];
+
+/*
+ * Spinlock to protect the global data structure wifi_handle.
+ */
+DEFINE_SPINLOCK(wifi_if_lock);
+
+/*
+ * nss_wifi_if_msg_handler()
+ *	Handle NSS -> HLOS messages for wifi interface
+ */
+static void nss_wifi_if_msg_handler(struct nss_ctx_instance *nss_ctx,
+					struct nss_cmn_msg *ncm,
+					__attribute__((unused))void *app_data)
+{
+	struct nss_wifi_if_msg *nwim = (struct nss_wifi_if_msg *)ncm;
+	int32_t if_num;
+
+	nss_wifi_if_msg_callback_t cb;
+	struct nss_wifi_if_handle *handle = NULL;
+
+	/*
+	 * Sanity check the message type
+	 */
+	if (ncm->type >= NSS_WIFI_IF_MAX_MSG_TYPES) {
+		nss_warning("%px: message type out of range: %d",
+						nss_ctx, ncm->type);
+		return;
+	}
+
+	if (nss_cmn_get_msg_len(ncm) > sizeof(struct nss_wifi_if_msg)) {
+		nss_warning("%px: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
+		return;
+	}
+
+	if (!NSS_IS_IF_TYPE(DYNAMIC, ncm->interface)) {
+		nss_warning("%px: response for another interface: %d", nss_ctx, ncm->interface);
+		return;
+	}
+
+	/*
+	 * Log failures
+	 */
+	nss_core_log_msg_failures(nss_ctx, ncm);
+
+	if_num = NSS_WIFI_IF_GET_INDEX(ncm->interface);
+
+	spin_lock_bh(&wifi_if_lock);
+	if (!wifi_handle[if_num]) {
+		spin_unlock_bh(&wifi_if_lock);
+		nss_warning("%px: wifi_if handle is NULL\n", nss_ctx);
+		return;
+	}
+
+	handle = wifi_handle[if_num];
+	spin_unlock_bh(&wifi_if_lock);
+
+	switch (nwim->cm.type) {
+	case NSS_WIFI_IF_STATS_SYNC_MSG:
+		nss_wifi_if_stats_sync(handle, &nwim->msg.stats);
+		break;
+	}
+
+	/*
+	 * Update the callback and app_data for NOTIFY messages.
+	 */
+	if (nwim->cm.response == NSS_CMN_RESPONSE_NOTIFY) {
+		ncm->cb = (nss_ptr_t)handle->cb;
+		ncm->app_data = (nss_ptr_t)handle->app_data;
+	}
+
+	/*
+	 * Do we have a callback?
+	 */
+	if (!ncm->cb) {
+		nss_warning("cb is NULL\n");
+		return;
+	}
+
+	/*
+	 * Callback
+	 */
+	cb = (nss_wifi_if_msg_callback_t)ncm->cb;
+	cb((void *)ncm->app_data, ncm);
+}
+
+/*
+ * nss_wifi_if_register_handler()
+ *	Register the message handler & initialize semaphore & completion for the * interface if_num
+ */
+static uint32_t nss_wifi_if_register_handler(struct nss_wifi_if_handle *handle)
+{
+	struct nss_ctx_instance *nss_ctx = &nss_top_main.nss[nss_top_main.wlan_handler_id];
+	uint32_t ret;
+	struct nss_wifi_if_pvt *nwip = NULL;
+	int32_t if_num = handle->if_num;
+
+	ret = nss_core_register_handler(nss_ctx, if_num, nss_wifi_if_msg_handler, NULL);
+
+	if (ret != NSS_CORE_STATUS_SUCCESS) {
+		nss_warning("%d: Message handler failed to be registered for interface ret %d\n", if_num, ret);
+		return NSS_WIFI_IF_CORE_FAILURE;
+	}
+
+	nwip = handle->pvt;
+	if (!nwip->sem_init_done) {
+		sema_init(&nwip->sem, 1);
+		init_completion(&nwip->complete);
+		nwip->sem_init_done = 1;
+	}
+
+	nss_wifi_if_stats_dentry_create();
+	return NSS_WIFI_IF_SUCCESS;
+}
+
+/*
+ * nss_wifi_if_callback
+ *	Callback to handle the completion of NSS->HLOS messages.
+ */
+static void nss_wifi_if_callback(void *app_data, struct nss_cmn_msg *ncm)
+{
+	struct nss_wifi_if_handle *handle = (struct nss_wifi_if_handle *)app_data;
+	struct nss_wifi_if_pvt *nwip = handle->pvt;
+
+	if (ncm->response != NSS_CMN_RESPONSE_ACK) {
+		nss_warning("%px: wifi_if Error response %d\n",
+						handle->nss_ctx, ncm->response);
+		nwip->response = NSS_TX_FAILURE;
+		complete(&nwip->complete);
+		return;
+	}
+
+	nwip->response = NSS_TX_SUCCESS;
+	complete(&nwip->complete);
+}
+
+/*
+ * nss_wifi_if_tx_msg()
+ *	Send a message from HLOS to NSS asynchronously.
+ */
+nss_tx_status_t nss_wifi_if_tx_msg(struct nss_ctx_instance *nss_ctx, struct nss_wifi_if_msg *nwim)
+{
+	struct nss_cmn_msg *ncm = &nwim->cm;
+
+	if (ncm->type > NSS_WIFI_IF_MAX_MSG_TYPES) {
+		nss_warning("%px: message type out of range: %d\n", nss_ctx, ncm->type);
+		return NSS_TX_FAILURE;
+	}
+
+	return nss_core_send_cmd(nss_ctx, nwim, sizeof(*nwim), NSS_NBUF_PAYLOAD_SIZE);
+}
+
+/*
+ * nss_wifi_if_tx_msg_sync
+ *	Send a message from HLOS to NSS synchronously.
+ */
+static nss_tx_status_t nss_wifi_if_tx_msg_sync(struct nss_wifi_if_handle *handle,
+							struct nss_wifi_if_msg *nwim)
+{
+	nss_tx_status_t status;
+	int ret = 0;
+	struct nss_wifi_if_pvt *nwip = handle->pvt;
+	struct nss_ctx_instance *nss_ctx = handle->nss_ctx;
+
+	down(&nwip->sem);
+
+	status = nss_wifi_if_tx_msg(nss_ctx, nwim);
+	if (status != NSS_TX_SUCCESS) {
+		nss_warning("%px: nss_wifi_if_msg failed\n", nss_ctx);
+		up(&nwip->sem);
+		return status;
+	}
+
+	ret = wait_for_completion_timeout(&nwip->complete,
+						msecs_to_jiffies(NSS_WIFI_IF_TX_TIMEOUT));
+	if (!ret) {
+		nss_warning("%px: wifi_if tx failed due to timeout\n", nss_ctx);
+		nwip->response = NSS_TX_FAILURE;
+	}
+
+	status = nwip->response;
+	up(&nwip->sem);
+
+	return status;
+}
+
+/*
+ * nss_wifi_if_handle_destroy()
+ *	Destroy the wifi handle either due to request from WLAN or due to error.
+ */
+static int nss_wifi_if_handle_destroy(struct nss_wifi_if_handle *handle)
+{
+	int32_t if_num;
+	int32_t index;
+	struct nss_ctx_instance *nss_ctx;
+	nss_tx_status_t status;
+
+	if (!handle) {
+		nss_warning("Destroy failed as wifi_if handle is NULL\n");
+		return NSS_TX_FAILURE_BAD_PARAM;
+	}
+
+	if_num = handle->if_num;
+	index = NSS_WIFI_IF_GET_INDEX(if_num);
+	nss_ctx = handle->nss_ctx;
+
+	spin_lock_bh(&wifi_if_lock);
+	wifi_handle[index] = NULL;
+	spin_unlock_bh(&wifi_if_lock);
+
+	status = nss_dynamic_interface_dealloc_node(if_num, NSS_DYNAMIC_INTERFACE_TYPE_WIFI);
+	if (status != NSS_TX_SUCCESS) {
+		nss_warning("%px: Dynamic interface destroy failed status %d\n", nss_ctx, status);
+		return status;
+	}
+
+	kfree(handle->pvt);
+	kfree(handle);
+
+	return status;
+}
+
+/*
+ * nss_wifi_if_handle_init()
+ *	Initialize wifi handle which holds the if_num and stats per interface.
+ */
+static struct nss_wifi_if_handle *nss_wifi_if_handle_create(struct nss_ctx_instance *nss_ctx,
+										int32_t *cmd_rsp)
+{
+	int32_t index;
+	int32_t if_num = 0;
+	struct nss_wifi_if_handle *handle;
+
+	if_num = nss_dynamic_interface_alloc_node(NSS_DYNAMIC_INTERFACE_TYPE_WIFI);
+	if (if_num < 0) {
+		nss_warning("%px:failure allocating wifi if\n", nss_ctx);
+		*cmd_rsp = NSS_WIFI_IF_DYNAMIC_IF_FAILURE;
+		return NULL;
+	}
+
+	index = NSS_WIFI_IF_GET_INDEX(if_num);
+
+	handle = (struct nss_wifi_if_handle *)kzalloc(sizeof(struct nss_wifi_if_handle),
+									GFP_KERNEL);
+	if (!handle) {
+		nss_warning("%px: handle memory alloc failed\n", nss_ctx);
+		*cmd_rsp = NSS_WIFI_IF_ALLOC_FAILURE;
+		goto error1;
+	}
+
+	handle->nss_ctx = nss_ctx;
+	handle->if_num = if_num;
+	handle->pvt = (struct nss_wifi_if_pvt *)kzalloc(sizeof(struct nss_wifi_if_pvt),
+								GFP_KERNEL);
+	if (!handle->pvt) {
+		nss_warning("%px: failure allocating memory for nss_wifi_if_pvt\n", nss_ctx);
+		*cmd_rsp = NSS_WIFI_IF_ALLOC_FAILURE;
+		goto error2;
+	}
+
+	handle->cb = NULL;
+	handle->app_data = NULL;
+
+	spin_lock_bh(&wifi_if_lock);
+	wifi_handle[index] = handle;
+	spin_unlock_bh(&wifi_if_lock);
+
+	*cmd_rsp = NSS_WIFI_IF_SUCCESS;
+
+	return handle;
+
+error2:
+	kfree(handle);
+error1:
+	nss_dynamic_interface_dealloc_node(if_num, NSS_DYNAMIC_INTERFACE_TYPE_WIFI);
+	return NULL;
+}
+
+/* nss_wifi_if_msg_init()
+ *	Initialize wifi specific message structure.
+ */
+static void nss_wifi_if_msg_init(struct nss_wifi_if_msg *nwim,
+					uint16_t if_num,
+					uint32_t type,
+					uint32_t len,
+					nss_wifi_if_msg_callback_t cb,
+					struct nss_wifi_if_handle *app_data)
+{
+	nss_cmn_msg_init(&nwim->cm, if_num, type, len, (void *)cb, (void *)app_data);
+}
+
+/*
+ * nss_wifi_if_create_sync()
+ *	Create a wifi interface and associate it with the netdev
+ */
+struct nss_wifi_if_handle *nss_wifi_if_create_sync(struct net_device *netdev)
+{
+	struct nss_ctx_instance *nss_ctx = &nss_top_main.nss[nss_top_main.wlan_handler_id];
+	struct nss_wifi_if_msg nwim;
+	struct nss_wifi_if_create_msg *nwcm;
+	uint32_t ret;
+	struct nss_wifi_if_handle *handle = NULL;
+
+	if (unlikely(nss_ctx->state != NSS_CORE_STATE_INITIALIZED)) {
+		nss_warning("%px: Interface could not be created as core not ready\n", nss_ctx);
+		return NULL;
+	}
+
+	handle = nss_wifi_if_handle_create(nss_ctx, &ret);
+	if (!handle) {
+		nss_warning("%px:wifi_if handle creation failed ret %d\n", nss_ctx, ret);
+		return NULL;
+	}
+
+	/* Initializes the semaphore and also sets the msg handler for if_num */
+	ret = nss_wifi_if_register_handler(handle);
+	if (ret != NSS_WIFI_IF_SUCCESS) {
+		nss_warning("%px: Registration handler failed reason: %d\n", nss_ctx, ret);
+		goto error;
+	}
+
+	nss_wifi_if_msg_init(&nwim, handle->if_num, NSS_WIFI_IF_TX_CREATE_MSG,
+				sizeof(struct nss_wifi_if_create_msg), nss_wifi_if_callback, handle);
+
+	nwcm = &nwim.msg.create;
+	nwcm->flags = 0;
+	memcpy(nwcm->mac_addr, netdev->dev_addr, ETH_ALEN);
+
+	ret = nss_wifi_if_tx_msg_sync(handle, &nwim);
+	if (ret != NSS_TX_SUCCESS) {
+		nss_warning("%px: nss_wifi_if_tx_msg_sync failed %u\n", nss_ctx, ret);
+		goto error;
+	}
+
+	nss_core_register_subsys_dp(nss_ctx, handle->if_num, NULL, NULL, NULL, netdev, 0);
+
+	/*
+	 * Hold a reference to the net_device
+	 */
+	dev_hold(netdev);
+
+	/*
+	 * The context returned is the interface # which is, essentially, the index into the if_ctx
+	 * array that is holding the net_device pointer
+	 */
+
+	return handle;
+
+error:
+	nss_wifi_if_handle_destroy(handle);
+	return NULL;
+}
+EXPORT_SYMBOL(nss_wifi_if_create_sync);
+
+/*
+ * nss_wifi_if_destroy_sync()
+ *	Destroy the wifi interface associated with the interface number.
+ */
+nss_tx_status_t nss_wifi_if_destroy_sync(struct nss_wifi_if_handle *handle)
+{
+	nss_tx_status_t status;
+	struct net_device *dev;
+	int32_t if_num = handle->if_num;
+	struct nss_ctx_instance *nss_ctx = handle->nss_ctx;
+
+	if (unlikely(nss_ctx->state != NSS_CORE_STATE_INITIALIZED)) {
+		nss_warning("%px: Interface could not be destroyed as core not ready\n", nss_ctx);
+		return NSS_TX_FAILURE_NOT_READY;
+	}
+
+	spin_lock_bh(&nss_top_main.lock);
+	if (!nss_ctx->subsys_dp_register[if_num].ndev) {
+		spin_unlock_bh(&nss_top_main.lock);
+		nss_warning("%px: Unregister wifi interface %d: no context\n", nss_ctx, if_num);
+		return NSS_TX_FAILURE_BAD_PARAM;
+	}
+
+	dev = nss_ctx->subsys_dp_register[if_num].ndev;
+	nss_core_unregister_subsys_dp(nss_ctx, if_num);
+	spin_unlock_bh(&nss_top_main.lock);
+	dev_put(dev);
+
+	status = nss_wifi_if_handle_destroy(handle);
+	return status;
+}
+EXPORT_SYMBOL(nss_wifi_if_destroy_sync);
+
+/*
+ * nss_wifi_if_register()
+ *	Register cb, netdev associated with the if_num to the nss data plane
+ * to receive data packets.
+ */
+void nss_wifi_if_register(struct nss_wifi_if_handle *handle,
+				nss_wifi_if_data_callback_t rx_callback,
+				struct net_device *netdev)
+{
+	struct nss_ctx_instance *nss_ctx;
+	int32_t if_num;
+
+	if (!handle) {
+		nss_warning("nss_wifi_if_register handle is NULL\n");
+		return;
+	}
+
+	nss_ctx = handle->nss_ctx;
+	if_num = handle->if_num;
+	nss_assert(NSS_IS_IF_TYPE(DYNAMIC, if_num));
+
+	nss_core_register_subsys_dp(nss_ctx, if_num, rx_callback, NULL, NULL, netdev, netdev->features);
+}
+EXPORT_SYMBOL(nss_wifi_if_register);
+
+/*
+ * nss_wifi_if_unregister()
+ *	Unregister the cb, netdev associated with the if_num.
+ */
+void nss_wifi_if_unregister(struct nss_wifi_if_handle *handle)
+{
+	struct nss_ctx_instance *nss_ctx;
+	int32_t if_num;
+
+	if (!handle) {
+		nss_warning("nss_wifi_if_unregister handle is NULL\n");
+		return;
+	}
+
+	nss_ctx = handle->nss_ctx;
+	if_num = handle->if_num;
+
+	nss_core_unregister_subsys_dp(nss_ctx, if_num);
+}
+EXPORT_SYMBOL(nss_wifi_if_unregister);
+
+/*
+ * nss_wifi_if_tx_buf()
+ *	HLOS interface has received a packet which we redirect to the NSS.
+ */
+nss_tx_status_t nss_wifi_if_tx_buf(struct nss_wifi_if_handle *handle,
+						struct sk_buff *skb)
+{
+	struct nss_ctx_instance *nss_ctx;
+	int32_t if_num;
+	int cpu = 0;
+
+	if (!handle) {
+		nss_warning("nss_wifi_if_tx_buf handle is NULL\n");
+		return NSS_TX_FAILURE;
+	}
+
+	nss_ctx = handle->nss_ctx;
+	if_num = handle->if_num;
+
+	/*
+	 * redirect should be turned on in /proc/
+	 */
+	if (unlikely(nss_ctl_redirect == 0)) {
+		return NSS_TX_FAILURE_NOT_ENABLED;
+	}
+
+	if (unlikely(skb->vlan_tci)) {
+		return NSS_TX_FAILURE_NOT_SUPPORTED;
+	}
+
+	nss_assert(NSS_IS_IF_TYPE(DYNAMIC, if_num));
+
+	/*
+	 * Sanity check the SKB to ensure that it's suitable for us
+	 */
+	if (unlikely(skb->len <= ETH_HLEN)) {
+		nss_warning("%px: Rx packet: %px too short", nss_ctx, skb);
+		return NSS_TX_FAILURE_TOO_SHORT;
+	}
+
+	/*
+	 * set skb queue mapping
+	 */
+	cpu = get_cpu();
+	put_cpu();
+	skb_set_queue_mapping(skb, cpu);
+
+	return nss_core_send_packet(nss_ctx, skb, if_num, H2N_BIT_FLAG_VIRTUAL_BUFFER);
+}
+EXPORT_SYMBOL(nss_wifi_if_tx_buf);
--- /dev/null
+++ b/nss_wifi_if_stats.c
@@ -0,0 +1,210 @@
+/*
+ **************************************************************************
+ * Copyright (c) 2016-2017, 2019 The Linux Foundation. All rights reserved.
+ * Permission to use, copy, modify, and/or distribute this software for
+ * any purpose with or without fee is hereby granted, provided that the
+ * above copyright notice and this permission notice appear in all copies.
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ **************************************************************************
+ */
+
+#include "nss_core.h"
+#include "nss_wifi_if.h"
+
+/*
+ * Data structure that holds the wifi interface context.
+ */
+extern struct nss_wifi_if_handle *wifi_handle[];
+
+/*
+ * Spinlock to protect the global data structure wifi_handle.
+ */
+extern spinlock_t wifi_if_lock;
+
+/*
+ * nss_wifi_if_stats_get()
+ *	Get the stats from wifi handle to buffer(line) for if_num.
+ */
+static int32_t nss_wifi_if_stats_get(int32_t if_num, int i, char *line)
+{
+	int32_t bytes = 0;
+	struct nss_wifi_if_stats *stats;
+	int32_t ifnum;
+	uint32_t len = 80;
+	struct nss_wifi_if_handle *handle = NULL;
+
+	ifnum = if_num - NSS_DYNAMIC_IF_START;
+
+	spin_lock_bh(&wifi_if_lock);
+	if (!wifi_handle[ifnum]) {
+		spin_unlock_bh(&wifi_if_lock);
+		goto end;
+	}
+
+	handle = wifi_handle[ifnum];
+	spin_unlock_bh(&wifi_if_lock);
+	stats = &handle->stats;
+
+	switch (i) {
+	case 0:
+		bytes = scnprintf(line, len, "rx_packets=%d\n",
+					stats->node_stats.rx_packets);
+		break;
+
+	case 1:
+		bytes = scnprintf(line, len, "rx_bytes=%d\n",
+					stats->node_stats.rx_bytes);
+		break;
+
+	case 2:
+		bytes = scnprintf(line, len, "rx_dropped=%d\n",
+					nss_cmn_rx_dropped_sum(&stats->node_stats));
+		break;
+
+	case 3:
+		bytes = scnprintf(line, len, "tx_packets=%d\n",
+					stats->node_stats.tx_packets);
+		break;
+
+	case 4:
+		bytes = scnprintf(line, len, "tx_bytes=%d\n",
+					stats->node_stats.tx_bytes);
+		break;
+
+	case 5:
+		bytes = scnprintf(line, len, "tx_enqueue_failed=%d\n",
+					stats->tx_enqueue_failed);
+		break;
+
+	case 6:
+		bytes = scnprintf(line, len, "shaper_enqueue_failed=%d\n",
+					stats->shaper_enqueue_failed);
+		break;
+	}
+
+end:
+	return bytes;
+}
+
+/*
+ * nss_wifi_if_stats_read()
+ *	Read wifi_if statistics
+ */
+static ssize_t nss_wifi_if_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
+{
+	struct nss_stats_data *data = fp->private_data;
+	struct nss_ctx_instance *nss_ctx = (struct nss_ctx_instance *)&nss_top_main.nss[nss_top_main.wifi_handler_id];
+	int32_t if_num = NSS_DYNAMIC_IF_START;
+	int32_t max_if_num = if_num + NSS_MAX_DYNAMIC_INTERFACES;
+	size_t bytes = 0;
+	ssize_t bytes_read = 0;
+	char line[80];
+	int start, end;
+
+	if (data) {
+		if_num = data->if_num;
+	}
+
+	if (if_num > max_if_num) {
+		return 0;
+	}
+
+	for (; if_num < max_if_num; if_num++) {
+		if (nss_dynamic_interface_get_type(nss_ctx, if_num) != NSS_DYNAMIC_INTERFACE_TYPE_WIFI)
+			continue;
+
+		bytes = scnprintf(line, sizeof(line), "if_num %d stats start:\n\n", if_num);
+		if ((bytes_read + bytes) > sz)
+			break;
+
+		if (copy_to_user(ubuf + bytes_read, line, bytes) != 0) {
+			bytes_read = -EFAULT;
+			goto end;
+		}
+
+		bytes_read += bytes;
+
+		start = 0;
+		end = 7;
+		while (bytes_read < sz && start < end) {
+			bytes = nss_wifi_if_stats_get(if_num, start, line);
+			if (!bytes)
+				break;
+
+			if ((bytes_read + bytes) > sz)
+				break;
+
+			if (copy_to_user(ubuf + bytes_read, line, bytes) != 0) {
+				bytes_read = -EFAULT;
+				goto end;
+			}
+
+			bytes_read += bytes;
+			start++;
+		}
+
+		bytes = scnprintf(line, sizeof(line), "if_num %d stats end:\n\n", if_num);
+		if (bytes_read > (sz - bytes))
+			break;
+
+		if (copy_to_user(ubuf + bytes_read, line, bytes) != 0) {
+			bytes_read = -EFAULT;
+			goto end;
+		}
+
+		bytes_read += bytes;
+	}
+
+	if (bytes_read > 0) {
+		*ppos = bytes_read;
+	}
+
+	if (data) {
+		data->if_num = if_num;
+	}
+
+end:
+	return bytes_read;
+}
+
+/*
+ * nss_wifi_if_stats_ops
+ */
+NSS_STATS_DECLARE_FILE_OPERATIONS(wifi_if)
+
+/*
+ * nss_wifi_if_stats_dentry_create()
+ *	Create wifi_if statistics debug entry.
+ */
+void nss_wifi_if_stats_dentry_create(void)
+{
+	nss_stats_create_dentry("wifi_if", &nss_wifi_if_stats_ops);
+}
+
+/*
+ * nss_wifi_if_stats_sync()
+ *	Sync stats from the NSS FW
+ */
+void nss_wifi_if_stats_sync(struct nss_wifi_if_handle *handle,
+					struct nss_wifi_if_stats *nwis)
+{
+	struct nss_wifi_if_stats *stats = &handle->stats;
+	int i;
+
+	stats->node_stats.rx_packets += nwis->node_stats.rx_packets;
+	stats->node_stats.rx_bytes += nwis->node_stats.rx_bytes;
+
+	for (i = 0; i < NSS_MAX_NUM_PRI; i++) {
+		stats->node_stats.rx_dropped[i] += nwis->node_stats.rx_dropped[i];
+	}
+	stats->node_stats.tx_packets += nwis->node_stats.tx_packets;
+	stats->node_stats.tx_bytes += nwis->node_stats.tx_bytes;
+	stats->tx_enqueue_failed += nwis->tx_enqueue_failed;
+	stats->shaper_enqueue_failed += nwis->shaper_enqueue_failed;
+}
--- a/nss_tls_strings.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- ******************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- ******************************************************************************
- */
-
-#ifndef __NSS_TLS_STRINGS_H
-#define __NSS_TLS_STRINGS_H
-
-#include "nss_tls_stats.h"
-
-extern struct nss_stats_info nss_tls_strings_stats[NSS_TLS_STATS_MAX];
-extern void nss_tls_strings_dentry_create(void);
-
-#endif /* __NSS_TLS_STRINGS_H */
--- /dev/null
+++ b/nss_wifi_if_stats.h
@@ -0,0 +1,26 @@
+/*
+ ******************************************************************************
+ * Copyright (c) 2017, The Linux Foundation. All rights reserved.
+ * Permission to use, copy, modify, and/or distribute this software for
+ * any purpose with or without fee is hereby granted, provided that the
+ * above copyright notice and this permission notice appear in all copies.
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+ * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * ****************************************************************************
+ */
+
+#ifndef __NSS_WIFI_IF_STATS_H
+#define __NSS_WIFI_IF_STATS_H
+
+/*
+ * wifi interface statistics APIs
+ */
+extern void nss_wifi_if_stats_sync(struct nss_wifi_if_handle *handle, struct nss_wifi_if_stats *nwis);
+extern void nss_wifi_if_stats_dentry_create(void);
+
+#endif /* __NSS_WIFI_IF_STATS_H */
--- a/nss_wifi_mac_db.c
+++ b/nss_wifi_mac_db.c
@@ -19,21 +19,9 @@
 #include "nss_core.h"
 #include "nss_wifi_mac_db_if.h"
 
-/*
- * Compile time assertion.
- */
-#define NSS_WIFI_MAC_DB_COMPILE_TIME_ASSERT(assertion_name, predicate) \
-    typedef char assertion_name[(predicate) ? 1 : -1]
-
 #define NSS_WIFI_MAC_DB_TX_TIMEOUT 1000 /* Millisecond to jiffies*/
 
 /*
- * Validate the Wi-Fi MAC database message size not exceeding buffer size.
- */
-NSS_WIFI_MAC_DB_COMPILE_TIME_ASSERT(NSS_WIFI_MAC_DB_MAX_BUF_MSG,
-		(sizeof(struct nss_wifi_mac_db_msg) < NSS_NBUF_PAYLOAD_SIZE));
-
-/*
  * nss_wifi_mac_db_get_context()
  */
 struct nss_ctx_instance *nss_wifi_mac_db_get_context(void)
--- a/nss_wifi_mesh.c
+++ /dev/null
@@ -1,242 +0,0 @@
-/*
- **************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- **************************************************************************
- */
-
-#include "nss_tx_rx_common.h"
-#include "nss_core.h"
-#include "nss_cmn.h"
-#include "nss_wifi_mesh.h"
-#include "nss_wifi_mesh_log.h"
-#include "nss_wifi_mesh_strings.h"
-
-/*
- * nss_wifi_mesh_verify_if_num()
- *	Verify interface number.
- */
-bool nss_wifi_mesh_verify_if_num(nss_if_num_t if_num)
-{
-	enum nss_dynamic_interface_type if_type = nss_dynamic_interface_get_type(nss_wifi_mesh_get_context(), if_num);
-
-	return ((if_type == NSS_DYNAMIC_INTERFACE_TYPE_WIFI_MESH_INNER) ||
-				(if_type == NSS_DYNAMIC_INTERFACE_TYPE_WIFI_MESH_OUTER));
-}
-EXPORT_SYMBOL(nss_wifi_mesh_verify_if_num);
-
-/* nss_wifi_mesh_handler()
- *	Handles Wi-Fi mesh messages from NSS to HLOS.
- */
-static void nss_wifi_mesh_handler(struct nss_ctx_instance *nss_ctx, struct nss_cmn_msg *ncm, void *app_data)
-{
-	nss_wifi_mesh_msg_callback_t cb;
-	struct nss_wifi_mesh_msg *nwmm = (struct nss_wifi_mesh_msg *)ncm;
-
-	NSS_VERIFY_CTX_MAGIC(nss_ctx);
-	nss_assert(nss_is_dynamic_interface(ncm->interface));
-	nss_assert(nss_wifi_mesh_verify_if_num(ncm->interface));
-
-	/*
-	 * Is this a valid request/response packet?
-	 */
-	if (ncm->type >= NSS_WIFI_MESH_MSG_MAX) {
-		nss_warning("%px: Received invalid message %d for wifi_mesh interface\n", nss_ctx, ncm->type);
-		return;
-	}
-
-
-	/*
-	 * For variable array the size of the common length will be greater the nss_wifi_mesh_msg
-	 * length. Add conditional checking for messages where length check will fail.
-	 */
-	if ((nss_cmn_get_msg_len(ncm) > sizeof(struct nss_wifi_mesh_msg)) &&
-		(ncm->type != NSS_WIFI_MESH_MSG_PATH_TABLE_DUMP) &&
-		(ncm->type != NSS_WIFI_MESH_MSG_PROXY_PATH_TABLE_DUMP)) {
-			nss_warning("%px: Length of message is greater than expected, type: %d, len: %d",
-			    		nss_ctx, ncm->type, ncm->len);
-		return;
-	}
-
-	/*
-	 * Log failures
-	 */
-	nss_core_log_msg_failures(nss_ctx, ncm);
-
-	/*
-	 * Trace Messages
-	 */
-	nss_wifi_mesh_log_rx_msg(nwmm);
-
-	/*
-	 * Update the stats and send statistics notifications to the registered modules.
-	 */
-	if (nwmm->cm.type == NSS_WIFI_MESH_MSG_STATS_SYNC) {
-		nss_wifi_mesh_update_stats(ncm->interface, &nwmm->msg.stats_sync_msg);
-		nss_wifi_mesh_stats_notify(ncm->interface, nss_ctx->id);
-	}
-
-	if (ncm->response == NSS_CMN_RESPONSE_NOTIFY) {
-		ncm->cb = (nss_ptr_t)nss_core_get_msg_handler(nss_ctx, ncm->interface);
-		ncm->app_data = (nss_ptr_t)app_data;
-	}
-
-	if (!ncm->cb) {
-		return;
-	}
-
-	cb = (nss_wifi_mesh_msg_callback_t)ncm->cb;
-	cb((void *)ncm->app_data, ncm);
-}
-
-/*
- * nss_wifi_mesh_msg_init()
- * 	Initiliaze a Wi-Fi mesh message.
- */
-void nss_wifi_mesh_msg_init(struct nss_wifi_mesh_msg *nwm, nss_if_num_t if_num, uint32_t type, uint32_t len,
-			nss_wifi_mesh_msg_callback_t cb, void *app_data)
-{
-	nss_assert(nss_wifi_mesh_verify_if_num(if_num));
-	nss_cmn_msg_init(&nwm->cm, if_num, type, len, cb, app_data);
-}
-EXPORT_SYMBOL(nss_wifi_mesh_msg_init);
-
-/*
- * nss_wifi_mesh_tx_buf
- * 	Send data packet for vap processing asynchronously.
- */
-nss_tx_status_t nss_wifi_mesh_tx_buf(struct nss_ctx_instance *nss_ctx, struct sk_buff *os_buf, nss_if_num_t if_num)
-{
-	nss_assert(nss_is_dynamic_interface(if_num));
-	return nss_core_send_packet(nss_ctx, os_buf, if_num, H2N_BIT_FLAG_BUFFER_REUSABLE);
-}
-EXPORT_SYMBOL(nss_wifi_mesh_tx_buf);
-
-/*
- * nss_wifi_mesh_tx_msg
- *	Transmit a Wi-Fi mesh message to the NSS firmware asynchronously.
- *
- * NOTE: The caller is expected to handle synchronous waiting for message
- * response if needed.
- */
-nss_tx_status_t nss_wifi_mesh_tx_msg(struct nss_ctx_instance *nss_ctx, struct nss_wifi_mesh_msg *msg)
-{
-	struct nss_cmn_msg *ncm = &msg->cm;
-
-	NSS_VERIFY_CTX_MAGIC(nss_ctx);
-
-	if (ncm->type >= NSS_WIFI_MESH_MSG_MAX) {
-		nss_warning("%px: wifi_mesh message type out of range: %d\n", nss_ctx, ncm->type);
-		return NSS_TX_FAILURE;
-	}
-
-	/*
-	 * Log messages.
-	 */
-	nss_wifi_mesh_log_tx_msg(msg);
-
-	/*
-	 * The interface number shall be one of the Wi-Fi mesh socket interfaces.
-	 */
-	nss_assert(nss_is_dynamic_interface(ncm->interface));
-
-	return nss_core_send_cmd(nss_ctx, msg, sizeof(*msg), NSS_NBUF_PAYLOAD_SIZE);
-}
-EXPORT_SYMBOL(nss_wifi_mesh_tx_msg);
-
-/*
- ****************************************
- * Register/Unregister/Miscellaneous APIs
- ****************************************
- */
-
-/*
- * nss_wifi_mesh_get_context()
- *	Return the core ctx which the feature is on.
- */
-struct nss_ctx_instance *nss_wifi_mesh_get_context(void)
-{
-	return (struct nss_ctx_instance *)&nss_top_main.nss[nss_top_main.wifi_handler_id];
-}
-EXPORT_SYMBOL(nss_wifi_mesh_get_context);
-
-/*
- * nss_unregister_wifi_mesh_if()
- *	Unregister Wi-Fi mesh from the NSS driver.
- */
-void nss_unregister_wifi_mesh_if(nss_if_num_t if_num)
-{
-	struct nss_ctx_instance *nss_ctx = nss_wifi_mesh_get_context();
-
-	NSS_VERIFY_CTX_MAGIC(nss_ctx);
-
-	nss_core_unregister_subsys_dp(nss_ctx, if_num);
-	nss_core_unregister_msg_handler(nss_ctx, if_num);
-	nss_core_unregister_handler(nss_ctx, if_num);
-	nss_wifi_mesh_stats_handle_free(if_num);
-}
-EXPORT_SYMBOL(nss_unregister_wifi_mesh_if);
-
-/*
- * nss_register_wifi_mesh_if()
- *	Register wifi_mesh with nss driver.
- */
-uint32_t nss_register_wifi_mesh_if(nss_if_num_t if_num,
-				   nss_wifi_mesh_data_callback_t  mesh_data_callback,
-				   nss_wifi_mesh_ext_data_callback_t mesh_ext_data_callback,
-				   nss_wifi_mesh_msg_callback_t mesh_event_callback,
-				   uint32_t dp_type, struct net_device *netdev, uint32_t features)
-{
-	struct nss_ctx_instance *nss_ctx = nss_wifi_mesh_get_context();
-	uint32_t status;
-
-	NSS_VERIFY_CTX_MAGIC(nss_ctx);
-	nss_assert(netdev);
-	nss_assert(nss_wifi_mesh_verify_if_num(if_num));
-
-	if (!nss_wifi_mesh_stats_handle_alloc(if_num, netdev->ifindex)) {
-		nss_warning("%px: couldn't allocate stats handle for device name: %s, if_num: 0x%x\n", nss_ctx, netdev->name, if_num);
-		return NSS_CORE_STATUS_FAILURE;
-	}
-
-	nss_core_register_handler(nss_ctx, if_num, nss_wifi_mesh_handler, netdev);
-
-	status = nss_core_register_msg_handler(nss_ctx, if_num, mesh_event_callback);
-	if (status != NSS_CORE_STATUS_SUCCESS) {
-		nss_warning("%px: unable to register event handler for interface(%u)\n", nss_ctx, if_num);
-		nss_core_unregister_handler(nss_ctx, if_num);
-		nss_wifi_mesh_stats_handle_free(if_num);
-		return status;
-	}
-
-	nss_core_register_subsys_dp(nss_ctx, if_num, mesh_data_callback, mesh_ext_data_callback, NULL, netdev, features);
-	nss_core_set_subsys_dp_type(nss_ctx, netdev, if_num, dp_type);
-	return NSS_CORE_STATUS_SUCCESS;
-}
-EXPORT_SYMBOL(nss_register_wifi_mesh_if);
-
-/*
- * nss_wifi_mesh_init()
- *	Initialize the mesh stats dentries.
- */
-void nss_wifi_mesh_init(void)
-{
-	if (!nss_wifi_mesh_strings_dentry_create()) {
-		nss_warning("Unable to create dentry for Wi-Fi mesh strings\n");
-	}
-
-	if (!nss_wifi_mesh_stats_dentry_create()) {
-		nss_warning("Unable to create dentry for Wi-Fi mesh stats\n");
-	}
-}
--- a/nss_wifi_mesh_log.c
+++ /dev/null
@@ -1,387 +0,0 @@
-/*
- **************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- **************************************************************************
- */
-
-/*
- * nss_wifi_mesh_log.c
- *	NSS WiFi Mesh logger file.
- */
-
-#include "nss_core.h"
-#include "nss_wifi_mesh.h"
-
-#define NSS_WIFI_MESH_LOG_MESSAGE_TYPE_INDEX(type) ((type) - NSS_IF_MAX_MSG_TYPES)
-
-/*
- * nss_wifi_mesh_log_message_types_str
- *	NSS Wi-Fi mesh message strings.
- */
-static uint8_t *nss_wifi_mesh_log_message_types_str[NSS_WIFI_MESH_LOG_MESSAGE_TYPE_INDEX(NSS_WIFI_MESH_MSG_MAX)] __maybe_unused = {
-	"WiFi Mesh configure",
-	"WiFi Mesh configure Mpath Add",
-	"WiFi Mesh configure Mpath Delete",
-	"WiFi Mesh configure Mpath Update",
-	"WiFi Mesh configure Proxy Learn",
-	"WiFi Mesh configure Proxy Add",
-	"WiFi Mesh configure Proxy Update",
-	"WiFi Mesh configure Proxy Delete",
-	"WiFi Mesh configure Mpath Not Found",
-	"WiFi Mesh configure Refresh"
-	"WiFi Mesh configure Mpath Table Dump",
-	"WiFi Mesh configure Proxy Path Table Dump",
-	"WiFi Mesh configure Assoc Link Vap",
-	"WiFi Mesh configure Exception Message",
-	"WiFi Mesh configure Rate limit message",
-	"WiFi Mesh configure Stats Sync"
-};
-
-/*
- * nss_wifi_mesh_log_configure_msg()
- *	Log a NSS Wi-Fi mesh interface configure message.
- */
-static void nss_wifi_mesh_log_configure_if_msg(struct nss_wifi_mesh_msg *nwmm)
-{
-	struct nss_wifi_mesh_config_msg *cmsg __maybe_unused = &nwmm->msg.mesh_config;
-	nss_trace("%px: WiFi Mesh configure message\n"
-		"Local Mac address: %pM\n"
-		"TTL: %d\n"
-		"Mesh Path Refresh Time: %d\n"
-		"Mpp Learning Mode: %d\n"
-		"Block Mesh Forwarding: %d\n"
-		"Configs Flags: 0x%x\n",
-		cmsg, cmsg->local_mac_addr, cmsg->ttl,
-		cmsg->mesh_path_refresh_time,
-		cmsg->mpp_learning_mode,
-		cmsg->block_mesh_forwarding,
-		cmsg->config_flags);
-}
-
-/*
- * nss_wifi_mesh_log_mpath_add_msg()
- *	Log a NSS Wi-Fi mesh mpath add message.
- */
-static void nss_wifi_mesh_log_mpath_add_msg(struct nss_wifi_mesh_msg *nwmm)
-{
-	struct nss_wifi_mesh_mpath_add_msg *mamsg __maybe_unused = &nwmm->msg.mpath_add;
-	nss_trace("%px: NSS WiFi Mesh Mpath add message:\n"
-		"Dest Mac address: %pM\n"
-		"Next Hop Mac address: %pM\n"
-		"Metric: %d\n"
-		"Expiry Time: %d\n"
-		"Hop Count: %d\n"
-		"Flags: 0x%x\n"
-		"Link Vap id: %d\n"
-		"Is Mesh Gate: %d\n",
-		mamsg, mamsg->dest_mac_addr, mamsg->next_hop_mac_addr,
-		mamsg->metric, mamsg->expiry_time, mamsg->hop_count,
-		mamsg->path_flags, mamsg->link_vap_id, mamsg->is_mesh_gate);
-}
-
-/*
- * nss_wifi_mesh_log_mpath_delete_msg()
- *	Log a NSS Wi-Fi mesh mpath delete message.
- */
-static void nss_wifi_mesh_log_mpath_delete_msg(struct nss_wifi_mesh_msg *nwmm)
-{
-	struct nss_wifi_mesh_mpath_del_msg *mdmsg __maybe_unused = &nwmm->msg.mpath_del;
-	nss_trace("%px: NSS WiFi Mesh Mpath delete message:\n"
-		"Dest Mac Address: %pM\n"
-		"Link Vap id: %d\n"
-		"Next Hop Mac address: %pM\n",
-		mdmsg, mdmsg->mesh_dest_mac_addr, mdmsg->link_vap_id, mdmsg->next_hop_mac_addr);
-}
-
-/*
- * nss_wifi_mesh_log_mpath_update_msg()
- *	Log a NSS Wi-Fi mesh mpath update message.
- */
-static void nss_wifi_mesh_log_mpath_update_msg(struct nss_wifi_mesh_msg *nwmm)
-{
-	struct nss_wifi_mesh_mpath_update_msg *mumsg __maybe_unused = &nwmm->msg.mpath_update;
-	nss_trace("%px: NSS WiFi Mesh Mpath update message:\n"
-		"Dest Mac address: %pM\n"
-		"Next Hop Mac address: %pM\n"
-		"Metric: %d\n"
-		"Expiry Time: %d\n"
-		"Hop Count: %d\n"
-		"Flags: 0x%x\n"
-		"Link Vap id: %d\n"
-		"Is Mesh Gate: %d\n"
-		"Update Flags: %d\n",
-		mumsg, mumsg->dest_mac_addr, mumsg->next_hop_mac_addr,
-		mumsg->metric, mumsg->expiry_time, mumsg->hop_count,
-		mumsg->path_flags, mumsg->link_vap_id, mumsg->is_mesh_gate,
-		mumsg->update_flags);
-}
-
-/*
- * nss_wifi_mesh_log_proxy_path_learn_msg()
- *	Log a NSS Wi-Fi mesh proxy path learn message.
- */
-static void nss_wifi_mesh_log_proxy_path_learn_msg(struct nss_wifi_mesh_msg *nwmm)
-{
-	struct nss_wifi_mesh_proxy_path_learn_msg *pplm __maybe_unused = &nwmm->msg.proxy_learn_msg;
-	nss_trace("%px: NSS WiFi Mesh Proxy Path Learn message:\n"
-		"Mesh Dest Mac address: %pM\n"
-		"Destination Mac address: %pM\n"
-		"flags: 0x%x\n",
-		pplm, pplm->mesh_dest_mac, pplm->dest_mac_addr,
-		pplm->path_flags);
-}
-
-/*
- * nss_wifi_mesh_log_proxy_path_add_msg()
- *	Log a NSS Wi-Fi Mesh proxy path add message.
- */
-static void nss_wifi_mesh_log_proxy_path_add_msg(struct nss_wifi_mesh_msg *nwmm)
-{
-	struct nss_wifi_mesh_proxy_path_add_msg *ppam __maybe_unused = &nwmm->msg.proxy_add_msg;
-	nss_trace("%px: NSS WiFi Mesh Proxy Path Add message:\n"
-		"Mesh Dest Mac address: %pM\n"
-		"Destination Mac address: %pM\n"
-		"flags: 0x%x\n",
-		ppam, ppam->mesh_dest_mac, ppam->dest_mac_addr,
-		ppam->path_flags);
-}
-
-/*
- * nss_wifi_mesh_log_proxy_path_delete_msg()
- *	Log a NSS Wi-Fi proxy path delete message.
- */
-static void nss_wifi_mesh_log_proxy_path_delete_msg(struct nss_wifi_mesh_msg *nwmm)
-{
-	struct nss_wifi_mesh_proxy_path_del_msg *ppdm __maybe_unused = &nwmm->msg.proxy_del_msg;
-	nss_trace("%px: NSS WiFi Mesh Proxy Path Delete message:\n"
-		"Mesh Dest Mac address: %pM\n"
-		"Destination Mac address: %pM\n",
-		ppdm, ppdm->mesh_dest_mac_addr, ppdm->dest_mac_addr);
-}
-
-/*
- * nss_wifi_mesh_log_proxy_path_update_msg()
- *	Log a NSS Wi-Fi mesh proxy path update message.
- */
-static void nss_wifi_mesh_log_proxy_path_update_msg(struct nss_wifi_mesh_msg *nwmm)
-{
-	struct nss_wifi_mesh_proxy_path_update_msg *ppum __maybe_unused = &nwmm->msg.proxy_update_msg;
-	nss_trace("%px: NSS WiFi Mesh Proxy Path Add message:\n"
-		"Mesh Dest Mac address: %pM\n"
-		"Destination Mac address: %pM\n"
-		"flags: 0x%x\n"
-		"Bitmap: %d\n",
-		ppum, ppum->mesh_dest_mac, ppum->dest_mac_addr,
-		ppum->path_flags, ppum->bitmap);
-}
-
-/*
- * nss_wifi_mesh_log_mpath_not_found_msg()
- *	Log a NSS Wi-Fi mesh mpath not found message.
- */
-static void nss_wifi_mesh_log_mpath_not_found_msg(struct nss_wifi_mesh_msg *nwmm)
-{
-	struct nss_wifi_mesh_mpath_not_found_msg *mnfm __maybe_unused = &nwmm->msg.mpath_not_found_msg;
-	nss_trace("%px: NSS WiFi Mesh Mpath not found message:\n"
-		"Destination Mac address: %pM\n"
-		"Transmitter Mac address: %pM\n"
-		"Link Vap Id: %d\n"
-		"Is Mesh Forwarding Path: %d\n",
-		mnfm, mnfm->dest_mac_addr, mnfm->transmitter_mac_addr,
-		mnfm->link_vap_id, mnfm->is_mesh_forward_path);
-}
-
-/*
- * nss_wifi_mesh_log_mpath_refresh_msg()
- *	Log a NSS Wi-Fi mesh mpath refresh message.
- */
-static void nss_wifi_mesh_log_mpath_refresh_msg(struct nss_wifi_mesh_msg *nwmm)
-{
-	struct nss_wifi_mesh_path_refresh_msg *mprm __maybe_unused = &nwmm->msg.path_refresh_msg;
-	nss_trace("%px: NSS WiFi Mesh Mpath refresh message:\n"
-		"Destination Mac address: %pM\n"
-		"Next Hop Mac address: %pM\n"
-		"Flags: 0x%x\n"
-		"Link Vap Id: %d\n",
-		mprm, mprm->dest_mac_addr, mprm->next_hop_mac_addr,
-		mprm->path_flags, mprm->link_vap_id);
-}
-
-/*
- * nss_wifi_mesh_log_mpath_expiry_msg()
- *	Log a NSS Wi-Fi mesh mpath expiry message.
- */
-static void nss_wifi_mesh_log_mpath_expiry_msg(struct nss_wifi_mesh_msg *nwmm)
-{
-	struct nss_wifi_mesh_path_expiry_msg *mpem __maybe_unused = &nwmm->msg.path_expiry_msg;
-	nss_trace("%px: NSS WiFi Mesh Mpath expiry message:\n"
-		"Destination Mac address: %pM\n"
-		"Next Hop Mac address: %pM\n"
-		"Flags: 0x%x\n"
-		"Link Vap Id: %d\n",
-		mpem, mpem->mesh_dest_mac_addr, mpem->next_hop_mac_addr,
-		mpem->path_flags, mpem->link_vap_id);
-}
-
-/*
- * nss_wifi_mesh_log_exception_flag_msg()
- *	Log a NSS Wi-Fi mesh exception flag message.
- */
-static void nss_wifi_mesh_log_exception_flag_msg(struct nss_wifi_mesh_msg *nwmm)
-{
-	struct nss_wifi_mesh_exception_flag_msg *efm __maybe_unused = &nwmm->msg.exception_msg;
-	nss_trace("%px: NSS WiFi Mesh Exception Flag message:\n"
-		"Destination Mac address: %pM\n",
-		efm, efm->dest_mac_addr);
-}
-
-/*
- * nss_wifi_mesh_log_rate_limit_config()
- *	Log a NSS Wi-Fi mesh rate limit config message.
- */
-static void nss_wifi_mesh_log_rate_limit_config(struct nss_wifi_mesh_msg *nwmm)
-{
-	struct nss_wifi_mesh_rate_limit_config *rlcm __maybe_unused = &nwmm->msg.exc_cfg;
-	nss_trace("%px: NSS WiFi Mesh rate limit config message:\n"
-		 "exception_num : %d\n"
-		 "enable : %d\n"
-		 "rate_limit : %d\n",
-		  rlcm, rlcm->exception_num, rlcm->enable, rlcm->rate_limit);
-}
-
-/*
- * nss_wifi_mesh_log_verbose()
- *	Log message contents.
- */
-static void nss_wifi_mesh_log_verbose(struct nss_wifi_mesh_msg *nwmm)
-{
-	switch (nwmm->cm.type) {
-	case NSS_WIFI_MESH_MSG_INTERFACE_CONFIGURE:
-		nss_wifi_mesh_log_configure_if_msg(nwmm);
-		break;
-
-	case NSS_WIFI_MESH_MSG_MPATH_ADD:
-		nss_wifi_mesh_log_mpath_add_msg(nwmm);
-		break;
-
-	case NSS_WIFI_MESH_MSG_MPATH_DELETE:
-		nss_wifi_mesh_log_mpath_delete_msg(nwmm);
-		break;
-
-	case NSS_WIFI_MESH_MSG_MPATH_UPDATE:
-		nss_wifi_mesh_log_mpath_update_msg(nwmm);
-		break;
-
-	case NSS_WIFI_MESH_MSG_PROXY_PATH_LEARN:
-		nss_wifi_mesh_log_proxy_path_learn_msg(nwmm);
-		break;
-
-	case NSS_WIFI_MESH_MSG_PROXY_PATH_ADD:
-		nss_wifi_mesh_log_proxy_path_add_msg(nwmm);
-		break;
-
-	case NSS_WIFI_MESH_MSG_PROXY_PATH_DELETE:
-		nss_wifi_mesh_log_proxy_path_delete_msg(nwmm);
-		break;
-
-	case NSS_WIFI_MESH_MSG_PROXY_PATH_UPDATE:
-		nss_wifi_mesh_log_proxy_path_update_msg(nwmm);
-		break;
-
-	case NSS_WIFI_MESH_MSG_PATH_NOT_FOUND:
-		nss_wifi_mesh_log_mpath_not_found_msg(nwmm);
-		break;
-
-	case NSS_WIFI_MESH_MSG_PATH_REFRESH:
-		nss_wifi_mesh_log_mpath_refresh_msg(nwmm);
-		break;
-
-	case NSS_WIFI_MESH_MSG_PATH_EXPIRY:
-		nss_wifi_mesh_log_mpath_expiry_msg(nwmm);
-		break;
-
-	case NSS_WIFI_MESH_MSG_PATH_TABLE_DUMP:
-		break;
-
-	case NSS_WIFI_MESH_MSG_PROXY_PATH_TABLE_DUMP:
-		break;
-
-	case NSS_WIFI_MESH_MSG_STATS_SYNC:
-		break;
-
-	case NSS_WIFI_MESH_MSG_EXCEPTION_FLAG:
-		nss_wifi_mesh_log_exception_flag_msg(nwmm);
-		break;
-
-	case NSS_WIFI_MESH_CONFIG_EXCEPTION:
-		nss_wifi_mesh_log_rate_limit_config(nwmm);
-		break;
-
-	default:
-		nss_trace("%px: Invalid message, type: %d\n", nwmm, nwmm->cm.type);
-		break;
-	}
-}
-
-/*
- * nss_wifi_mesh_log_tx_msg()
- *	Log messages transmitted to firmware.
- */
-void nss_wifi_mesh_log_tx_msg(struct nss_wifi_mesh_msg *nwmm)
-{
-	uint32_t index;
-	if ((nwmm->cm.type >= NSS_WIFI_MESH_MSG_MAX) || (nwmm->cm.type <= NSS_IF_MAX_MSG_TYPES)) {
-		nss_warning("%px: Invalid message, type: %d\n", nwmm, nwmm->cm.type);
-		return;
-	}
-
-	index = NSS_WIFI_MESH_LOG_MESSAGE_TYPE_INDEX(nwmm->cm.type);
-
-	nss_info("%px: type[%d]:%s\n", nwmm, nwmm->cm.type, nss_wifi_mesh_log_message_types_str[index - 1]);
-	nss_wifi_mesh_log_verbose(nwmm);
-}
-
-/*
- * nss_wifi_mesh_log_rx_msg()
- *	Log messages received from firmware.
- */
-void nss_wifi_mesh_log_rx_msg(struct nss_wifi_mesh_msg *nwmm)
-{
-	uint32_t index;
-	if (nwmm->cm.response >= NSS_CMN_RESPONSE_LAST) {
-		nss_warning("%px: Invalid response, message type: %d\n", nwmm, nwmm->cm.type);
-		return;
-	}
-
-	if (nwmm->cm.type <= NSS_IF_MAX_MSG_TYPES) {
-		return;
-	}
-
-	index = NSS_WIFI_MESH_LOG_MESSAGE_TYPE_INDEX(nwmm->cm.type);
-
-	if (nwmm->cm.response == NSS_CMN_RESPONSE_NOTIFY || (nwmm->cm.response == NSS_CMN_RESPONSE_ACK)) {
-		nss_info("%px: type[%d]:%s, response[%d]:%s\n", nwmm, nwmm->cm.type,
-			nss_wifi_mesh_log_message_types_str[index - 1],
-			nwmm->cm.response, nss_cmn_response_str[nwmm->cm.response]);
-		goto verbose;
-	}
-
-	nss_info("%px: msg nack - type[%d]:%s, response[%d]:%s\n",
-		nwmm, nwmm->cm.type, nss_wifi_mesh_log_message_types_str[index - 1],
-		nwmm->cm.response, nss_cmn_response_str[nwmm->cm.response]);
-
-verbose:
-	nss_wifi_mesh_log_verbose(nwmm);
-}
--- a/nss_wifi_mesh_log.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- **************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- **************************************************************************
- */
-
-#ifndef __NSS_WIFI_MESH_LOG_H
-#define __NSS_WIFI_MESH_LOG_H
-
-/*
- * nss_wifi_mesh_log_tx_msg
- *	Logs a Wi-Fi mesh message that was sent to the NSS firmware.
- */
-void nss_wifi_mesh_log_tx_msg(struct nss_wifi_mesh_msg *nwmm);
-
-/*
- * nss_wifi_mesh_log_rx_msg
- *	Logs a Wi-Fi mesh message that was received from the NSS firmware.
- */
-void nss_wifi_mesh_log_rx_msg(struct nss_wifi_mesh_msg *nwmm);
-
-#endif /* __NSS_WIFI_MESH_LOG_H */
--- a/nss_wifi_mesh_stats.c
+++ /dev/null
@@ -1,662 +0,0 @@
-/*
- **************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- **************************************************************************
- */
-
-#include "nss_core.h"
-#include "nss_tx_rx_common.h"
-#include "nss_wifi_mesh.h"
-#include "nss_wifi_mesh_stats.h"
-#include "nss_wifi_mesh_strings.h"
-
-#define NSS_WIFI_MESH_OUTER_STATS 0
-#define NSS_WIFI_MESH_INNER_STATS 1
-#define NSS_WIFI_MESH_PATH_STATS 2
-#define NSS_WIFI_MESH_PROXY_PATH_STATS 3
-#define NSS_WIFI_MESH_EXCEPTION_STATS 4
-
-/*
- * Wi-Fi mesh stats dentry file size.
- */
-#define NSS_WIFI_MESH_DENTRY_FILE_SIZE 19
-
-/*
- * Spinlock for protecting tunnel operations colliding with a tunnel destroy
- */
-static DEFINE_SPINLOCK(nss_wifi_mesh_stats_lock);
-
-/*
- * Declare atomic notifier data structure for statistics.
- */
-static ATOMIC_NOTIFIER_HEAD(nss_wifi_mesh_stats_notifier);
-
-/*
- * Declare an array of Wi-Fi mesh stats handle.
- */
-struct nss_wifi_mesh_stats_handle *nss_wifi_mesh_stats_hdl[NSS_WIFI_MESH_MAX_DYNAMIC_INTERFACE];
-
-/*
- * nss_wifi_mesh_max_statistics()
- * 	Wi-Fi mesh maximum statistics.
- */
-static uint32_t nss_wifi_mesh_max_statistics(void)
-{
-	uint32_t max1;
-	uint32_t exception_stats_max = NSS_WIFI_MESH_EXCEPTION_STATS_TYPE_MAX;
-	uint32_t encap_stats_max = NSS_WIFI_MESH_ENCAP_STATS_TYPE_MAX;
-	uint32_t decap_stats_max = NSS_WIFI_MESH_DECAP_STATS_TYPE_MAX;
-	uint32_t path_stats_max = NSS_WIFI_MESH_PATH_STATS_TYPE_MAX;
-	uint32_t proxy_path_stats_max = NSS_WIFI_MESH_PROXY_PATH_STATS_TYPE_MAX;
-
-	max1 = max(max(encap_stats_max, decap_stats_max), max(path_stats_max, proxy_path_stats_max));
-
-	return (max(max1, exception_stats_max));
-}
-
-/*
- * nss_wifi_mesh_stats_handle_alloc()
- *	Allocate Wi-Fi mesh tunnel instance
- */
-bool nss_wifi_mesh_stats_handle_alloc(nss_if_num_t if_num, int32_t ifindex)
-{
-	struct nss_wifi_mesh_stats_handle *h;
-	uint32_t idx;
-
-	/*
-	 * Allocate a handle
-	 */
-	h = kzalloc(sizeof(struct nss_wifi_mesh_stats_handle), GFP_ATOMIC);
-	if (!h) {
-		nss_warning("Failed to allocate memory for Wi-Fi mesh instance for interface : 0x%x\n", if_num);
-		return false;
-	}
-
-	spin_lock(&nss_wifi_mesh_stats_lock);
-	for (idx = 0; idx < NSS_WIFI_MESH_MAX_DYNAMIC_INTERFACE; idx++) {
-		if (nss_wifi_mesh_stats_hdl[idx] && nss_wifi_mesh_stats_hdl[idx]->if_num == if_num) {
-			spin_unlock(&nss_wifi_mesh_stats_lock);
-			nss_warning("Already a handle present for this interface number: 0x%x\n", if_num);
-			kfree(h);
-			return false;
-		}
-	}
-
-	for (idx = 0; idx < NSS_WIFI_MESH_MAX_DYNAMIC_INTERFACE; idx++) {
-		if (nss_wifi_mesh_stats_hdl[idx]) {
-			continue;
-		}
-
-		h->if_num = if_num;
-		h->mesh_idx = idx;
-		h->ifindex = ifindex;
-		nss_wifi_mesh_stats_hdl[idx] = h;
-		spin_unlock(&nss_wifi_mesh_stats_lock);
-		return true;
-	}
-	spin_unlock(&nss_wifi_mesh_stats_lock);
-	nss_warning("No free index available for handle with ifnum: 0x%x\n", if_num);
-	kfree(h);
-	return false;
-}
-
-/*
- * nss_wifi_mesh_stats_handle_free()
- *	Free Wi-Fi mesh tunnel handle instance.
- */
-bool nss_wifi_mesh_stats_handle_free(nss_if_num_t if_num)
-{
-	struct nss_wifi_mesh_stats_handle *h;
-
-	spin_lock(&nss_wifi_mesh_stats_lock);
-	h = nss_wifi_mesh_get_stats_handle(if_num);
-	if (!h) {
-		spin_unlock(&nss_wifi_mesh_stats_lock);
-		nss_warning("Unable to free Wi-Fi mesh stats handle instance for interface number: 0x%x\n", if_num);
-		return false;
-	}
-
-	nss_wifi_mesh_stats_hdl[h->mesh_idx] = NULL;
-	spin_unlock(&nss_wifi_mesh_stats_lock);
-	kfree(h);
-	return true;
-}
-
-/**
- * nss_wifi_mesh_get_stats_handle()
- * 	Get Wi-Fi mesh stats handle from interface number.
- */
-struct nss_wifi_mesh_stats_handle *nss_wifi_mesh_get_stats_handle(nss_if_num_t if_num)
-{
-	uint32_t idx;
-
-	assert_spin_locked(&nss_wifi_mesh_stats_lock);
-
-	for (idx = 0; idx < NSS_WIFI_MESH_MAX_DYNAMIC_INTERFACE; idx++) {
-		if (nss_wifi_mesh_stats_hdl[idx]) {
-			if (nss_wifi_mesh_stats_hdl[idx]->if_num == if_num) {
-				struct nss_wifi_mesh_stats_handle *h = nss_wifi_mesh_stats_hdl[idx];
-				return h;
-			}
-		}
-	}
-	return NULL;
-}
-
-/*
- * nss_wifi_mesh_get_stats()
- *	API for getting stats from a Wi-Fi mesh interface stats
- */
-static bool nss_wifi_mesh_get_stats(nss_if_num_t if_num, struct nss_wifi_mesh_hdl_stats_sync_msg *stats)
-{
-	struct nss_wifi_mesh_stats_handle *h;
-
-	if (!nss_wifi_mesh_verify_if_num(if_num)) {
-		return false;
-	}
-
-	spin_lock(&nss_wifi_mesh_stats_lock);
-	h = nss_wifi_mesh_get_stats_handle(if_num);
-	if (!h) {
-		spin_unlock(&nss_wifi_mesh_stats_lock);
-		nss_warning("Invalid Wi-Fi mesh stats handle for interface number: %d\n", if_num);
-		return false;
-	}
-
-	memcpy(stats, &h->stats, sizeof(*stats));
-	spin_unlock(&nss_wifi_mesh_stats_lock);
-	return true;
-}
-
-/*
- * nss_wifi_mesh_get_valid_interface_count()
- * 	Get count of valid Wi-Fi mesh interfaces up.
- */
-static uint32_t nss_wifi_mesh_get_valid_interface_count(uint16_t type, uint32_t if_num, uint32_t max_if_num)
-{
-	uint32_t interface_count = 0;
-	enum nss_dynamic_interface_type dtype;
-
-	for (; if_num <= max_if_num; if_num++) {
-		if (!nss_is_dynamic_interface(if_num)) {
-			continue;
-		}
-
-		dtype = nss_dynamic_interface_get_type(nss_wifi_mesh_get_context(), if_num);
-
-		if ((type == NSS_WIFI_MESH_OUTER_STATS) && (dtype != NSS_DYNAMIC_INTERFACE_TYPE_WIFI_MESH_OUTER)) {
-			continue;
-		}
-
-		if ((type == NSS_WIFI_MESH_INNER_STATS) && (dtype != NSS_DYNAMIC_INTERFACE_TYPE_WIFI_MESH_INNER)) {
-			continue;
-		}
-
-		if ((type == NSS_WIFI_MESH_PATH_STATS) && (dtype != NSS_DYNAMIC_INTERFACE_TYPE_WIFI_MESH_INNER)) {
-			continue;
-		}
-
-		if ((type == NSS_WIFI_MESH_PROXY_PATH_STATS) && (dtype != NSS_DYNAMIC_INTERFACE_TYPE_WIFI_MESH_INNER)) {
-			continue;
-		}
-		interface_count++;
-	}
-	return interface_count;
-}
-
-/**
- * nss_wifi_mesh_stats_read()
- * 	Read Wi-Fi Mesh stats.
- */
-static ssize_t nss_wifi_mesh_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos, uint16_t type)
-{
-	uint32_t max_output_lines, max_stats;
-	size_t size_al, size_wr = 0;
-	ssize_t bytes_read = 0;
-	struct nss_stats_data *data = fp->private_data;
-	int ifindex;
-	uint32_t if_num = NSS_DYNAMIC_IF_START;
-	uint32_t interface_count = 0;
-	uint32_t max_if_num = NSS_DYNAMIC_IF_START + NSS_MAX_DYNAMIC_INTERFACES;
-	struct nss_wifi_mesh_hdl_stats_sync_msg *stats;
-	struct net_device *ndev;
-	struct nss_wifi_mesh_stats_handle *handle;
-	char *lbuf;
-	enum nss_dynamic_interface_type dtype;
-
-	if (data) {
-		if_num = data->if_num;
-	}
-
-	/*
-	 * If we are done accomodating all the Wi-Fi mesh interfaces.
-	 */
-	if (if_num > max_if_num) {
-		return 0;
-	}
-
-	/*
-	 * Get number of Wi-Fi mesh interfaces up.
-	 */
-	interface_count = nss_wifi_mesh_get_valid_interface_count(type, if_num, max_if_num);
-	if (!interface_count) {
-		nss_warning("%px: Invalid number of valid interface for if_num: 0x%x\n", data, if_num);
-		return 0;
-	}
-
-	/*
-	 * max output lines = #stats + Number of Extra outputlines for future reference to add new stats +
-	 * Maximum node stats + Maximum of all the stats + three blank lines.
-	 */
-	max_stats = nss_wifi_mesh_max_statistics();
-	max_output_lines = max_stats + NSS_STATS_NODE_MAX + NSS_STATS_EXTRA_OUTPUT_LINES;
-	size_al = NSS_STATS_MAX_STR_LENGTH * max_output_lines * interface_count;
-
-	lbuf = kzalloc(size_al, GFP_KERNEL);
-	if (unlikely(lbuf == NULL)) {
-		nss_warning("Could not allocate memory for local statistics buffer\n");
-		return 0;
-	}
-
-	size_wr += nss_stats_banner(lbuf, size_wr, size_al, "wifi_mesh", NSS_STATS_SINGLE_CORE);
-
-	stats = kzalloc(sizeof(struct nss_wifi_mesh_hdl_stats_sync_msg), GFP_KERNEL);
-	if (!stats) {
-		nss_warning("%px: Failed to allocate stats memory for if_num: 0x%x\n", data, if_num);
-		kfree(lbuf);
-		return 0;
-	}
-
-	for (; if_num <= max_if_num; if_num++) {
-		bool ret;
-
-		if (!nss_is_dynamic_interface(if_num)) {
-			continue;
-		}
-
-		dtype = nss_dynamic_interface_get_type(nss_wifi_mesh_get_context(), if_num);
-
-		if ((type == NSS_WIFI_MESH_OUTER_STATS) && (dtype != NSS_DYNAMIC_INTERFACE_TYPE_WIFI_MESH_OUTER)) {
-			continue;
-		}
-
-		if ((type == NSS_WIFI_MESH_INNER_STATS) && (dtype != NSS_DYNAMIC_INTERFACE_TYPE_WIFI_MESH_INNER)) {
-			continue;
-		}
-
-		if ((type == NSS_WIFI_MESH_PATH_STATS) && (dtype != NSS_DYNAMIC_INTERFACE_TYPE_WIFI_MESH_INNER)) {
-			continue;
-		}
-
-		if ((type == NSS_WIFI_MESH_PROXY_PATH_STATS) && (dtype != NSS_DYNAMIC_INTERFACE_TYPE_WIFI_MESH_INNER)) {
-			continue;
-		}
-
-		/*
-		 * If Wi-Fi mesh stats handle does not exists, then ret will be false.
-		 */
-		ret = nss_wifi_mesh_get_stats(if_num, stats);
-		if (!ret) {
-			continue;
-		}
-
-		spin_lock(&nss_wifi_mesh_stats_lock);
-		handle = nss_wifi_mesh_get_stats_handle(if_num);
-		if (!handle) {
-			spin_unlock(&nss_wifi_mesh_stats_lock);
-			nss_warning("Invalid Wi-Fi mesh stats handle, if_num: %d\n", if_num);
-			continue;
-		}
-		ifindex = handle->ifindex;
-		spin_unlock(&nss_wifi_mesh_stats_lock);
-
-		ndev = dev_get_by_index(&init_net, ifindex);
-		if (!ndev) {
-			continue;
-		}
-
-		size_wr += scnprintf(lbuf + size_wr, size_al - size_wr, "\n%s if_num:%03u\n",
-				     ndev->name, if_num);
-		dev_put(ndev);
-
-		/*
-		 * Read encap stats, path stats, proxy path stats from inner node and decap stats from outer node.
-		 */
-		switch (type) {
-		case NSS_WIFI_MESH_INNER_STATS:
-			size_wr += nss_stats_print("wifi_mesh", "encap stats", NSS_STATS_SINGLE_INSTANCE
-					, nss_wifi_mesh_strings_encap_stats
-					, stats->encap_stats
-					, NSS_WIFI_MESH_ENCAP_STATS_TYPE_MAX
-					, lbuf, size_wr, size_al);
-			break;
-
-		case NSS_WIFI_MESH_PATH_STATS:
-			size_wr += nss_stats_print("wifi_mesh", "path stats", NSS_STATS_SINGLE_INSTANCE
-					, nss_wifi_mesh_strings_path_stats
-					, stats->path_stats
-					, NSS_WIFI_MESH_PATH_STATS_TYPE_MAX
-					, lbuf, size_wr, size_al);
-			break;
-
-		case NSS_WIFI_MESH_PROXY_PATH_STATS:
-			size_wr += nss_stats_print("wifi_mesh", "proxy path stats", NSS_STATS_SINGLE_INSTANCE
-					, nss_wifi_mesh_strings_proxy_path_stats
-					, stats->proxy_path_stats
-					, NSS_WIFI_MESH_PROXY_PATH_STATS_TYPE_MAX
-					, lbuf, size_wr, size_al);
-			break;
-
-		case NSS_WIFI_MESH_OUTER_STATS:
-			size_wr += nss_stats_print("wifi_mesh", "decap stats", NSS_STATS_SINGLE_INSTANCE
-					, nss_wifi_mesh_strings_decap_stats
-					, stats->decap_stats
-					, NSS_WIFI_MESH_DECAP_STATS_TYPE_MAX
-					, lbuf, size_wr, size_al);
-			break;
-
-		case NSS_WIFI_MESH_EXCEPTION_STATS:
-			size_wr += nss_stats_print("wifi_mesh", "exception stats", NSS_STATS_SINGLE_INSTANCE
-					, nss_wifi_mesh_strings_exception_stats
-					, stats->except_stats
-					, NSS_WIFI_MESH_EXCEPTION_STATS_TYPE_MAX
-					, lbuf, size_wr, size_al);
-			break;
-
-		default:
-			nss_warning("%px: Invalid stats type: %d\n", stats, type);
-			nss_assert(0);
-			kfree(stats);
-			kfree(lbuf);
-			return 0;
-		}
-	}
-
-	bytes_read = simple_read_from_buffer(ubuf, sz, ppos, lbuf, size_wr);
-	kfree(stats);
-	kfree(lbuf);
-	return bytes_read;
-}
-
-/**
- * nss_wifi_mesh_decap_stats_read()
- *	Read Wi-Fi Mesh decap stats.
- */
-static ssize_t nss_wifi_mesh_decap_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_wifi_mesh_stats_read(fp, ubuf, sz, ppos, NSS_WIFI_MESH_OUTER_STATS);
-}
-
-/**
- * nss_wifi_mesh_encap_stats_read()
- *	Read Wi-Fi Mesh encap stats
- */
-static ssize_t nss_wifi_mesh_encap_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_wifi_mesh_stats_read(fp, ubuf, sz, ppos, NSS_WIFI_MESH_INNER_STATS);
-}
-
-/**
- * nss_wifi_mesh_path_stats_read()
- *	Read Wi-Fi Mesh path stats
- */
-static ssize_t nss_wifi_mesh_path_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_wifi_mesh_stats_read(fp, ubuf, sz, ppos, NSS_WIFI_MESH_PATH_STATS);
-}
-
-/**
- * nss_wifi_mesh_proxy_path_stats_read()
- *	Read Wi-Fi Mesh proxy path stats
- */
-static ssize_t nss_wifi_mesh_proxy_path_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_wifi_mesh_stats_read(fp, ubuf, sz, ppos, NSS_WIFI_MESH_PROXY_PATH_STATS);
-}
-
-/**
- * nss_wifi_mesh_exception_stats_read()
- *	Read Wi-Fi Mesh exception stats
- */
-static ssize_t nss_wifi_mesh_exception_stats_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_wifi_mesh_stats_read(fp, ubuf, sz, ppos, NSS_WIFI_MESH_EXCEPTION_STATS);
-}
-
-/*
- * nss_wifi_mesh_stats_ops
- */
-NSS_STATS_DECLARE_FILE_OPERATIONS(wifi_mesh_encap);
-NSS_STATS_DECLARE_FILE_OPERATIONS(wifi_mesh_decap);
-NSS_STATS_DECLARE_FILE_OPERATIONS(wifi_mesh_path);
-NSS_STATS_DECLARE_FILE_OPERATIONS(wifi_mesh_proxy_path);
-NSS_STATS_DECLARE_FILE_OPERATIONS(wifi_mesh_exception);
-
-/*
- * nss_wifi_mesh_get_interface_type()
- * 	Function to get the type of dynamic interface.
- */
-static enum nss_dynamic_interface_type nss_wifi_mesh_get_interface_type(nss_if_num_t if_num)
-{
-	struct nss_ctx_instance *nss_ctx = &nss_top_main.nss[nss_top_main.wifi_handler_id];
-	NSS_VERIFY_CTX_MAGIC(nss_ctx);
-	return nss_dynamic_interface_get_type(nss_ctx, if_num);
-}
-
-/*
- * nss_wifi_mesh_update_stats()
- *	Update stats for Wi-Fi mesh interface.
- */
-void nss_wifi_mesh_update_stats(nss_if_num_t if_num, struct nss_wifi_mesh_stats_sync_msg *mstats)
-{
-	struct nss_wifi_mesh_stats_handle *handle;
-	struct nss_wifi_mesh_hdl_stats_sync_msg *stats;
-	enum nss_dynamic_interface_type type;
-	uint64_t *dst;
-	uint32_t *src;
-	int i;
-
-	spin_lock(&nss_wifi_mesh_stats_lock);
-	handle = nss_wifi_mesh_get_stats_handle(if_num);
-	if (!handle) {
-		spin_unlock(&nss_wifi_mesh_stats_lock);
-		nss_warning("Invalid Wi-Fi mesh stats handle, if_num: %d\n", if_num);
-		return;
-	}
-
-	type = nss_wifi_mesh_get_interface_type(handle->if_num);;
-	stats = &handle->stats;
-
-	switch (type) {
-	case NSS_DYNAMIC_INTERFACE_TYPE_WIFI_MESH_INNER:
-		/*
-		 * Update pnode Rx stats.
-		 */
-		stats->encap_stats[NSS_WIFI_MESH_ENCAP_STATS_TYPE_PNODE_RX_PACKETS] += mstats->pnode_stats.rx_packets;
-		stats->encap_stats[NSS_WIFI_MESH_ENCAP_STATS_TYPE_PNODE_RX_BYTES] += mstats->pnode_stats.rx_bytes;
-		stats->encap_stats[NSS_WIFI_MESH_ENCAP_STATS_TYPE_PNODE_RX_DROPPED] += nss_cmn_rx_dropped_sum(&mstats->pnode_stats);
-
-		/*
-		 * Update pnode Tx stats.
-		 */
-		stats->encap_stats[NSS_WIFI_MESH_ENCAP_STATS_TYPE_PNODE_TX_PACKETS] += mstats->pnode_stats.tx_packets;
-		stats->encap_stats[NSS_WIFI_MESH_ENCAP_STATS_TYPE_PNODE_TX_BYTES] += mstats->pnode_stats.tx_bytes;
-
-		/*
-		 * Update encap stats.
-		 */
-		dst = &stats->encap_stats[NSS_WIFI_MESH_ENCAP_STATS_TYPE_EXPIRY_NOTIFY_SENT];
-		src = &mstats->mesh_encap_stats.expiry_notify_sent;
-		for (i = NSS_WIFI_MESH_ENCAP_STATS_TYPE_EXPIRY_NOTIFY_SENT; i < NSS_WIFI_MESH_ENCAP_STATS_TYPE_MAX; i++) {
-			*dst++ += *src++;
-		}
-
-		/*
-		 * Update mesh path stats.
-		 */
-		dst = &stats->path_stats[NSS_WIFI_MESH_PATH_STATS_TYPE_ALLOC_FAILURES];
-		src = &mstats->mesh_path_stats.alloc_failures;
-		for (i = NSS_WIFI_MESH_PATH_STATS_TYPE_ALLOC_FAILURES; i < NSS_WIFI_MESH_PATH_STATS_TYPE_MAX; i++) {
-			*dst++ += *src++;
-		}
-
-		/*
-		 * Update mesh proxy path stats.
-		 */
-		dst = &stats->proxy_path_stats[NSS_WIFI_MESH_PROXY_PATH_STATS_TYPE_ALLOC_FAILURES];
-		src = &mstats->mesh_proxy_path_stats.alloc_failures;
-		for (i = NSS_WIFI_MESH_PROXY_PATH_STATS_TYPE_ALLOC_FAILURES; i < NSS_WIFI_MESH_PROXY_PATH_STATS_TYPE_MAX; i++) {
-			*dst++ += *src++;
-		}
-
-		/*
-		 * Update exception stats.
-		 */
-		dst = &stats->except_stats[NSS_WIFI_MESH_EXCEPTION_STATS_TYPE_PACKETS_SUCCESS];
-		src = &mstats->mesh_except_stats.packets_success;
-		for (i = NSS_WIFI_MESH_EXCEPTION_STATS_TYPE_PACKETS_SUCCESS; i < NSS_WIFI_MESH_EXCEPTION_STATS_TYPE_MAX; i++) {
-			*dst++ += *src++;
-		}
-		spin_unlock(&nss_wifi_mesh_stats_lock);
-		break;
-
-	case NSS_DYNAMIC_INTERFACE_TYPE_WIFI_MESH_OUTER:
-		/*
-		 * Update pnode Rx stats.
-		 */
-		stats->decap_stats[NSS_WIFI_MESH_DECAP_STATS_TYPE_PNODE_RX_PACKETS] += mstats->pnode_stats.rx_packets;
-		stats->decap_stats[NSS_WIFI_MESH_DECAP_STATS_TYPE_PNODE_RX_BYTES] += mstats->pnode_stats.rx_bytes;
-		stats->decap_stats[NSS_WIFI_MESH_DECAP_STATS_TYPE_PNODE_RX_DROPPED] += nss_cmn_rx_dropped_sum(&mstats->pnode_stats);
-
-		/*
-		 * Update pnode Tx stats.
-		 */
-		stats->decap_stats[NSS_WIFI_MESH_DECAP_STATS_TYPE_PNODE_TX_PACKETS] += mstats->pnode_stats.tx_packets;
-		stats->decap_stats[NSS_WIFI_MESH_DECAP_STATS_TYPE_PNODE_TX_BYTES] += mstats->pnode_stats.tx_bytes;
-
-		/*
-		 * Update decap stats.
-		 */
-		dst = &stats->decap_stats[NSS_WIFI_MESH_DECAP_STATS_TYPE_PATH_REFRESH_SENT];
-		src = &mstats->mesh_decap_stats.path_refresh_sent;
-		for (i = NSS_WIFI_MESH_DECAP_STATS_TYPE_PATH_REFRESH_SENT; i < NSS_WIFI_MESH_DECAP_STATS_TYPE_MAX; i++) {
-			*dst++ += *src++;
-		}
-		spin_unlock(&nss_wifi_mesh_stats_lock);
-		break;
-
-	default:
-		spin_unlock(&nss_wifi_mesh_stats_lock);
-		nss_warning("%px: Received invalid dynamic interface type: %d\n", handle, type);
-		nss_assert(0);
-	}
-}
-
-/*
- * nss_wifi_mesh_stats_notify()
- *	Sends notifications to the registered modules.
- *
- * Leverage NSS-FW statistics timing to update Netlink.
- */
-void nss_wifi_mesh_stats_notify(nss_if_num_t if_num, uint32_t core_id)
-{
-	struct nss_wifi_mesh_stats_notification wifi_mesh_stats;
-
-	if (!nss_wifi_mesh_get_stats(if_num, &wifi_mesh_stats.stats)) {
-		nss_warning("No handle is present with ifnum: 0x%x\n", if_num);
-		return;
-	}
-
-	wifi_mesh_stats.core_id = core_id;
-	wifi_mesh_stats.if_num = if_num;
-	atomic_notifier_call_chain(&nss_wifi_mesh_stats_notifier, NSS_STATS_EVENT_NOTIFY, (void *)&wifi_mesh_stats);
-}
-
-/*
- * nss_wifi_mesh_stats_dentry_create()
- *	Create Wi-Fi Mesh statistics debug entry
- */
-struct dentry *nss_wifi_mesh_stats_dentry_create(void)
-{
-	struct dentry *stats_dentry_dir;
-	struct dentry *stats_file;
-	char dir_name[NSS_WIFI_MESH_DENTRY_FILE_SIZE] = {0};
-
-	if (!nss_top_main.stats_dentry) {
-		nss_warning("qca-nss-drv/stats is not present\n");
-		return NULL;
-	}
-
-	snprintf(dir_name, sizeof(dir_name), "wifi_mesh");
-
-	stats_dentry_dir = debugfs_create_dir(dir_name,  nss_top_main.stats_dentry);
-	if (!stats_dentry_dir) {
-		nss_warning("Failed to create qca-nss-drv/stats/wifi_mesh directory\n");
-		return NULL;
-	}
-
-	stats_file = debugfs_create_file("encap_stats", 0400, stats_dentry_dir, &nss_top_main, &nss_wifi_mesh_encap_stats_ops);
-	if (!stats_file) {
-		nss_warning("Failed to create qca-nss-drv/stats/wifi_mesh/encap_stats file\n");
-		goto fail;
-	}
-
-	stats_file = debugfs_create_file("decap_stats", 0400, stats_dentry_dir, &nss_top_main, &nss_wifi_mesh_decap_stats_ops);
-	if (!stats_file) {
-		nss_warning("Failed to create qca-nss-drv/stats/wifi_mesh/decap_stats file\n");
-		goto fail;
-	}
-
-	stats_file = debugfs_create_file("path_stats", 0400, stats_dentry_dir, &nss_top_main, &nss_wifi_mesh_path_stats_ops);
-	if (!stats_file) {
-		nss_warning("Failed to create qca-nss-drv/stats/wifi_mesh/path_stats file\n");
-		goto fail;
-	}
-
-	stats_file = debugfs_create_file("proxy_path_stats", 0400, stats_dentry_dir, &nss_top_main, &nss_wifi_mesh_proxy_path_stats_ops);
-	if (!stats_file) {
-		nss_warning("Failed to create qca-nss-drv/stats/wifi_mesh/proxy_path_stats file\n");
-		goto fail;
-	}
-	stats_file = debugfs_create_file("exception_stats", 0400, stats_dentry_dir, &nss_top_main, &nss_wifi_mesh_exception_stats_ops);
-	if (!stats_file) {
-		nss_warning("Failed to create qca-nss-drv/stats/wifi_mesh/exception_stats file\n");
-		goto fail;
-	}
-	return stats_dentry_dir;
-fail:
-	debugfs_remove_recursive(stats_dentry_dir);
-	return NULL;
-}
-
-/**
- * nss_wifi_mesh_stats_register_notifier()
- *	Registers statistics notifier.
- */
-int nss_wifi_mesh_stats_register_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_register(&nss_wifi_mesh_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_wifi_mesh_stats_register_notifier);
-
-/**
- * nss_wifi_mesh_stats_unregister_notifier()
- *	Deregisters statistics notifier.
- */
-int nss_wifi_mesh_stats_unregister_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_unregister(&nss_wifi_mesh_stats_notifier, nb);
-}
-EXPORT_SYMBOL(nss_wifi_mesh_stats_unregister_notifier);
--- a/nss_wifi_mesh_stats.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- **************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- **************************************************************************
- */
-
-#ifndef __NSS_WIFI_MESH_STATS_H__
-#define __NSS_WIFI_MESH_STATS_H__
-
-/**
- * Array of pointer for NSS Wi-Fi mesh handles.
- * Each handle has per-tunnel statistics based on the interface number which is an index.
- */
-struct nss_wifi_mesh_stats_handle {
-	nss_if_num_t if_num;				/**< Interface number. */
-	uint32_t ifindex;				/**< Netdev index. */
-	uint32_t mesh_idx;				/**< Mesh index.  */
-	struct nss_wifi_mesh_hdl_stats_sync_msg stats;	/**< Stats per-interface number. */
-};
-
-/*
- * Wi-Fi Mesh statistics APIs
- */
-extern void nss_wifi_mesh_update_stats(nss_if_num_t if_num, struct nss_wifi_mesh_stats_sync_msg *mstats);
-extern void nss_wifi_mesh_stats_notify(nss_if_num_t if_num, uint32_t core_id);
-extern struct dentry *nss_wifi_mesh_stats_dentry_create(void);
-extern struct nss_wifi_mesh_stats_handle *nss_wifi_mesh_get_stats_handle(nss_if_num_t if_num);
-extern bool nss_wifi_mesh_stats_handle_alloc(nss_if_num_t if_num, int32_t ifindex);
-extern bool nss_wifi_mesh_stats_handle_free(nss_if_num_t if_num);
-#endif /* __NSS_WIFI_MESH_STATS_H__ */
--- a/nss_wifi_mesh_strings.c
+++ /dev/null
@@ -1,284 +0,0 @@
-/*
- **************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- **************************************************************************
- */
-
-#include "nss_stats.h"
-#include "nss_core.h"
-#include <nss_wifi_mesh.h>
-#include "nss_wifi_mesh_stats.h"
-#include "nss_strings.h"
-#include "nss_wifi_mesh_strings.h"
-
-/*
- * nss_wifi_mesh_strings_encap_stats
- *	Wi-Fi mesh encap statistics string.
- */
-struct nss_stats_info nss_wifi_mesh_strings_encap_stats[NSS_WIFI_MESH_ENCAP_STATS_TYPE_MAX] = {
-	{"rx_packets",			NSS_STATS_TYPE_COMMON},
-	{"rx_bytes",			NSS_STATS_TYPE_COMMON},
-	{"tx_packets",			NSS_STATS_TYPE_COMMON},
-	{"tx_bytes",			NSS_STATS_TYPE_COMMON},
-	{"rx_dropped",			NSS_STATS_TYPE_COMMON},
-	{"expiry_notify_sent",		NSS_STATS_TYPE_SPECIAL},
-	{"mc_count",			NSS_STATS_TYPE_SPECIAL},
-	{"mp_not_found",		NSS_STATS_TYPE_SPECIAL},
-	{"mp_active",			NSS_STATS_TYPE_SPECIAL},
-	{"mpp_not_found",		NSS_STATS_TYPE_SPECIAL},
-	{"mpp_found",			NSS_STATS_TYPE_SPECIAL},
-	{"encap_hdr_fail",		NSS_STATS_TYPE_SPECIAL},
-	{"mp_del_notify_fail",		NSS_STATS_TYPE_SPECIAL},
-	{"link_enqueue",		NSS_STATS_TYPE_SPECIAL},
-	{"link_enq_fail",		NSS_STATS_TYPE_SPECIAL},
-	{"ra_lup_fail",			NSS_STATS_TYPE_SPECIAL},
-	{"dummy_add_count",		NSS_STATS_TYPE_SPECIAL},
-	{"encap_mp_add_notify_fail", 	NSS_STATS_TYPE_SPECIAL},
-	{"dummy_add_fail", 		NSS_STATS_TYPE_SPECIAL},
-	{"dummy_lup_fail", 		NSS_STATS_TYPE_SPECIAL},
-	{"send_to_host_failed",		NSS_STATS_TYPE_SPECIAL},
-	{"sent_to_host",		NSS_STATS_TYPE_SPECIAL},
-	{"expiry_notify_fail",		NSS_STATS_TYPE_SPECIAL},
-	{"no_headroom", 		NSS_STATS_TYPE_SPECIAL},
-	{"path_refresh_sent", 		NSS_STATS_TYPE_SPECIAL},
-	{"linearise_failed", 		NSS_STATS_TYPE_SPECIAL},
-	{"mp_exc_event_rl_dropped",	NSS_STATS_TYPE_SPECIAL}
-};
-
-/*
- * nss_wifi_mesh_encap_strings_read()
- *	Read Wi-Fi mesh encap statistics names.
- */
-static ssize_t nss_wifi_mesh_encap_stats_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_wifi_mesh_strings_encap_stats, NSS_WIFI_MESH_ENCAP_STATS_TYPE_MAX);
-}
-
-/*
- * nss_wifi_mesh_strings_path_stats
- * 	Wi-Fi mesh path statistics string.
- */
-struct nss_stats_info nss_wifi_mesh_strings_path_stats[NSS_WIFI_MESH_PATH_STATS_TYPE_MAX] = {
-	{"alloc_failures",		NSS_STATS_TYPE_SPECIAL},
-	{"error_max_radio_count",	NSS_STATS_TYPE_SPECIAL},
-	{"invalid_interface_failures",	NSS_STATS_TYPE_SPECIAL},
-	{"add_success",			NSS_STATS_TYPE_SPECIAL},
-	{"table_full_errors",		NSS_STATS_TYPE_SPECIAL},
-	{"insert_failures",		NSS_STATS_TYPE_SPECIAL},
-	{"not_found",			NSS_STATS_TYPE_SPECIAL},
-	{"delete_success",		NSS_STATS_TYPE_SPECIAL},
-	{"update_success",		NSS_STATS_TYPE_SPECIAL},
-	{"mesh_path_expired",		NSS_STATS_TYPE_SPECIAL},
-	{"mesh_path_refresh_needed",	NSS_STATS_TYPE_SPECIAL},
-	{"add_requests",		NSS_STATS_TYPE_SPECIAL},
-	{"del_requests",		NSS_STATS_TYPE_SPECIAL},
-	{"update_requests",		NSS_STATS_TYPE_SPECIAL},
-	{"next_hop_updations",		NSS_STATS_TYPE_SPECIAL},
-	{"hop_count_updations",		NSS_STATS_TYPE_SPECIAL},
-	{"flag_updations",		NSS_STATS_TYPE_SPECIAL},
-	{"metric_updations",		NSS_STATS_TYPE_SPECIAL},
-	{"block_mesh_fwd_updations",	NSS_STATS_TYPE_SPECIAL},
-	{"delete_failures",		NSS_STATS_TYPE_SPECIAL},
-	{"mesh_path_dummy_add_failures",NSS_STATS_TYPE_SPECIAL},
-	{"mesh_path_dummy_add_success",	NSS_STATS_TYPE_SPECIAL}
-
-};
-
-/*
- * nss_wifi_mesh_path_strings_read()
- *	Read Wi-Fi mesh path statistics names.
- */
-static ssize_t nss_wifi_mesh_path_stats_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_wifi_mesh_strings_path_stats, NSS_WIFI_MESH_PATH_STATS_TYPE_MAX);
-}
-
-/*
- * nss_wifi_mesh_strings_proxy_path_stats
- * 	Wi-Fi mesh proxy path statistics string.
- */
-struct nss_stats_info nss_wifi_mesh_strings_proxy_path_stats[NSS_WIFI_MESH_PROXY_PATH_STATS_TYPE_MAX] = {
-	{"alloc_failures",				NSS_STATS_TYPE_SPECIAL},
-	{"entry_exist_failures",			NSS_STATS_TYPE_SPECIAL},
-	{"add_success",					NSS_STATS_TYPE_SPECIAL},
-	{"table_full_errors",				NSS_STATS_TYPE_SPECIAL},
-	{"insert_failures",				NSS_STATS_TYPE_SPECIAL},
-	{"not_found",					NSS_STATS_TYPE_SPECIAL},
-	{"unhashed_errors",				NSS_STATS_TYPE_SPECIAL},
-	{"delete_failures",				NSS_STATS_TYPE_SPECIAL},
-	{"delete_success",				NSS_STATS_TYPE_SPECIAL},
-	{"update_success",				NSS_STATS_TYPE_SPECIAL},
-	{"lookup_success",				NSS_STATS_TYPE_SPECIAL},
-	{"add_requests",				NSS_STATS_TYPE_SPECIAL},
-	{"del_requests",				NSS_STATS_TYPE_SPECIAL},
-	{"update_requests",				NSS_STATS_TYPE_SPECIAL},
-	{"mda_updations",				NSS_STATS_TYPE_SPECIAL},
-	{"flag_updations",				NSS_STATS_TYPE_SPECIAL},
-	{"mesh_proxy_path_dummy_lookup_success",	NSS_STATS_TYPE_SPECIAL},
-	{"mesh_proxy_path_dummy_lookup_failures",	NSS_STATS_TYPE_SPECIAL},
-	{"mesh_proxy_path_dummy_add_failures",		NSS_STATS_TYPE_SPECIAL},
-	{"mesh_proxy_path_dummy_add_success",		NSS_STATS_TYPE_SPECIAL}
-};
-
-/*
- * nss_wifi_mesh_proxy_path_strings_read()
- *	Read Wi-Fi mesh proxy path statistics names.
- */
-static ssize_t nss_wifi_mesh_proxy_path_stats_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_wifi_mesh_strings_proxy_path_stats, NSS_WIFI_MESH_PROXY_PATH_STATS_TYPE_MAX);
-}
-
-/*
- * nss_wifi_mesh_strings_decap_stats
- *	Wi-Fi mesh decap statistics string.
- */
-struct nss_stats_info nss_wifi_mesh_strings_decap_stats[NSS_WIFI_MESH_DECAP_STATS_TYPE_MAX] = {
-	{"rx_packets",			NSS_STATS_TYPE_COMMON},
-	{"rx_bytes",			NSS_STATS_TYPE_COMMON},
-	{"tx_packets",			NSS_STATS_TYPE_COMMON},
-	{"tx_bytes",			NSS_STATS_TYPE_COMMON},
-	{"rx_dropped",			NSS_STATS_TYPE_COMMON},
-	{"path_refresh_sent",		NSS_STATS_TYPE_SPECIAL},
-	{"reserved",			NSS_STATS_TYPE_SPECIAL},
-	{"mc_drop",			NSS_STATS_TYPE_DROP},
-	{"ttl_0",			NSS_STATS_TYPE_SPECIAL},
-	{"mpp_lup_fail",		NSS_STATS_TYPE_SPECIAL},
-	{"decap_hdr_fail",		NSS_STATS_TYPE_SPECIAL},
-	{"rx_fwd_fail",			NSS_STATS_TYPE_SPECIAL},
-	{"rx_fwd_success",		NSS_STATS_TYPE_SPECIAL},
-	{"mp_fwd_lookup_fail",		NSS_STATS_TYPE_SPECIAL},
-	{"mp_fwd_inactive",		NSS_STATS_TYPE_SPECIAL},
-	{"nxt_mnode_fwd_success",	NSS_STATS_TYPE_SPECIAL},
-	{"nxt_mnode_fwd_fail",		NSS_STATS_TYPE_SPECIAL},
-	{"mpp_add_fail",		NSS_STATS_TYPE_SPECIAL},
-	{"mpp_add_event2host_fail",	NSS_STATS_TYPE_SPECIAL},
-	{"mpp_upate_fail",		NSS_STATS_TYPE_SPECIAL},
-	{"mpp_update_even2host_fail", 	NSS_STATS_TYPE_SPECIAL},
-	{"mpp_learn2host_fail",		NSS_STATS_TYPE_SPECIAL},
-	{"block_mesh_fwd_packets",	NSS_STATS_TYPE_SPECIAL},
-	{"no_headroom",			NSS_STATS_TYPE_SPECIAL},
-	{"linearise_failed",		NSS_STATS_TYPE_SPECIAL},
-	{"mpp_learn_event_rl_dropped",	NSS_STATS_TYPE_DROP},
-	{"mp_missging_event_rl_dropped", NSS_STATS_TYPE_DROP}
-};
-
-/*
- * nss_wifi_mesh_decap_strings_read()
- *	Read Wi-Fi mesh decap statistics names.
- */
-static ssize_t nss_wifi_mesh_decap_stats_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_wifi_mesh_strings_decap_stats, NSS_WIFI_MESH_DECAP_STATS_TYPE_MAX);
-}
-
-/*
- * nss_wifi_mesh_strings_exception_stats
- *	Wi-Fi mesh exception statistics string.
- */
-struct nss_stats_info nss_wifi_mesh_strings_exception_stats[NSS_WIFI_MESH_EXCEPTION_STATS_TYPE_MAX] = {
-	{"packets_success",		NSS_STATS_TYPE_SPECIAL},
-	{"packets_failure",		NSS_STATS_TYPE_DROP}
-};
-
-/*
- * nss_wifi_mesh_exception_strings_read()
- *	Read Wi-Fi mesh exception statistics names.
- */
-static ssize_t nss_wifi_mesh_exception_stats_strings_read(struct file *fp, char __user *ubuf, size_t sz, loff_t *ppos)
-{
-	return nss_strings_print(ubuf, sz, ppos, nss_wifi_mesh_strings_exception_stats, NSS_WIFI_MESH_EXCEPTION_STATS_TYPE_MAX);
-}
-
-/*
- * nss_wifi_mesh_decap_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(wifi_mesh_decap_stats);
-
-/*
- * nss_wifi_mesh_encap_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(wifi_mesh_encap_stats);
-
-/*
- * nss_wifi_mesh_path_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(wifi_mesh_path_stats);
-
-/*
- * nss_wifi_mesh_proxy_path_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(wifi_mesh_proxy_path_stats);
-
-/*
- * nss_wifi_mesh_exception_strings_ops
- */
-NSS_STRINGS_DECLARE_FILE_OPERATIONS(wifi_mesh_exception_stats);
-
-/*
- * nss_wifi_mesh_strings_dentry_create()
- *	Create Wi-Fi mesh statistics strings debug entry.
- */
-struct dentry *nss_wifi_mesh_strings_dentry_create(void)
-{
-	struct dentry *str_dentry_dir;
-	struct dentry *str_file;
-
-	if (!nss_top_main.strings_dentry) {
-		nss_warning("qca-nss-drv/strings is not present\n");
-		return NULL;
-	}
-
-	str_dentry_dir = debugfs_create_dir("wifi_mesh", nss_top_main.strings_dentry);
-	if (!str_dentry_dir) {
-		nss_warning("Failed to create qca-nss-drv/string/wifi_mesh directory\n");
-		return NULL;
-	}
-
-	str_file = debugfs_create_file("encap_stats", 0400, str_dentry_dir, &nss_top_main, &nss_wifi_mesh_encap_stats_strings_ops);
-	if (!str_file) {
-		nss_warning("Failed to create qca-nss-drv/string/wifi_mesh/encap_stats file\n");
-		goto fail;
-	}
-
-	str_file = debugfs_create_file("decap_stats", 0400, str_dentry_dir, &nss_top_main, &nss_wifi_mesh_decap_stats_strings_ops);
-	if (!str_file) {
-		nss_warning("Failed to create qca-nss-drv/string/wifi_mesh/decap_stats file\n");
-		goto fail;
-	}
-
-	str_file = debugfs_create_file("path_stats", 0400, str_dentry_dir, &nss_top_main, &nss_wifi_mesh_path_stats_strings_ops);
-	if (!str_file) {
-		nss_warning("Failed to create qca-nss-drv/string/wifi_mesh/path_stats file\n");
-		goto fail;
-	}
-
-	str_file = debugfs_create_file("proxy_path_stats", 0400, str_dentry_dir, &nss_top_main, &nss_wifi_mesh_proxy_path_stats_strings_ops);
-	if (!str_file) {
-		nss_warning("Failed to create qca-nss-drv/string/wifi_mesh/proxy_path_stats file\n");
-		goto fail;
-	}
-
-	str_file = debugfs_create_file("exception_stats", 0400, str_dentry_dir, &nss_top_main, &nss_wifi_mesh_exception_stats_strings_ops);
-	if (!str_file) {
-		nss_warning("Failed to create qca-nss-drv/string/wifi_mesh/exception_stats file\n");
-		goto fail;
-	}
-
-	return str_dentry_dir;
-fail:
-	debugfs_remove_recursive(str_dentry_dir);
-	return NULL;
-}
--- a/nss_wifi_mesh_strings.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- **************************************************************************
- * Copyright (c) 2021, The Linux Foundation. All rights reserved.
- *
- * Permission to use, copy, modify, and/or distribute this software for
- * any purpose with or without fee is hereby granted, provided that the
- * above copyright notice and this permission notice appear in all copies.
- *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
- **************************************************************************
- */
-
-#ifndef __NSS_WIFI_MESH_STRINGS_H
-#define __NSS_WIFI_MESH_STRINGS_H
-
-#include "nss_wifi_mesh_stats.h"
-#include "nss_strings.h"
-
-extern struct nss_stats_info nss_wifi_mesh_strings_encap_stats[NSS_WIFI_MESH_ENCAP_STATS_TYPE_MAX];
-extern struct nss_stats_info nss_wifi_mesh_strings_decap_stats[NSS_WIFI_MESH_DECAP_STATS_TYPE_MAX];
-extern struct nss_stats_info nss_wifi_mesh_strings_path_stats[NSS_WIFI_MESH_PATH_STATS_TYPE_MAX];
-extern struct nss_stats_info nss_wifi_mesh_strings_proxy_path_stats[NSS_WIFI_MESH_PROXY_PATH_STATS_TYPE_MAX];
-extern struct nss_stats_info nss_wifi_mesh_strings_exception_stats[NSS_WIFI_MESH_EXCEPTION_STATS_TYPE_MAX];
-extern struct dentry *nss_wifi_mesh_strings_dentry_create(void);
-
-#endif /* __NSS_WIFI_MESH_STRINGS_H */
--- a/nss_wifi_stats.c
+++ b/nss_wifi_stats.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2016-2017, 2019-2021 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2016-2017, 2019-2020 The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -86,8 +86,7 @@ struct nss_stats_info nss_wifi_stats_str
 	{"rx_htt_fetch_cnt"			, NSS_STATS_TYPE_SPECIAL},
 	{"total_tidq_bypass_cnt"		, NSS_STATS_TYPE_SPECIAL},
 	{"global_q_full_cnt"			, NSS_STATS_TYPE_SPECIAL},
-	{"tidq_full_cnt"			, NSS_STATS_TYPE_SPECIAL},
-	{"peer_unauth_rx_pkt_drop"		, NSS_STATS_TYPE_DROP}
+	{"tidq_full_cnt"			, NSS_STATS_TYPE_SPECIAL}
 };
 
 uint64_t nss_wifi_stats[NSS_MAX_WIFI_RADIO_INTERFACES][NSS_WIFI_STATS_MAX]; /* WIFI statistics */
@@ -209,7 +208,6 @@ void nss_wifi_stats_sync(struct nss_ctx_
 	nss_wifi_stats[radio_id][NSS_WIFI_STATS_TOTAL_TIDQ_BYPASS_CNT] += stats->total_tidq_bypass_cnt;
 	nss_wifi_stats[radio_id][NSS_WIFI_STATS_GLOBAL_Q_FULL_CNT] += stats->global_q_full_cnt;
 	nss_wifi_stats[radio_id][NSS_WIFI_STATS_TIDQ_FULL_CNT] += stats->tidq_full_cnt;
-	nss_wifi_stats[radio_id][NSS_WIFI_STATS_UNATH_RX_PKT_DROP] += stats->peer_unauth_rx_pkt_drop;
 
 	spin_unlock_bh(&nss_top->stats_lock);
 }
--- a/nss_wifi_stats.h
+++ b/nss_wifi_stats.h
@@ -50,7 +50,6 @@ enum nss_wifi_stats_types {
 	NSS_WIFI_STATS_TOTAL_TIDQ_BYPASS_CNT,
 	NSS_WIFI_STATS_GLOBAL_Q_FULL_CNT,
 	NSS_WIFI_STATS_TIDQ_FULL_CNT,
-	NSS_WIFI_STATS_UNATH_RX_PKT_DROP,
 	NSS_WIFI_STATS_MAX,
 };
 
--- a/nss_wifi_vdev.c
+++ b/nss_wifi_vdev.c
@@ -199,16 +199,8 @@ EXPORT_SYMBOL(nss_wifi_vdev_tx_msg_ext);
  */
 nss_tx_status_t nss_wifi_vdev_tx_buf(struct nss_ctx_instance *nss_ctx, struct sk_buff *os_buf, uint32_t if_num)
 {
-	enum nss_dynamic_interface_type if_type;
-
 	BUG_ON(((if_num < NSS_DYNAMIC_IF_START) || (if_num >= (NSS_DYNAMIC_IF_START + NSS_MAX_DYNAMIC_INTERFACES))));
 
-	if_type = nss_dynamic_interface_get_type(nss_ctx, if_num);
-	if (if_type != NSS_DYNAMIC_INTERFACE_TYPE_VAP) {
-		nss_warning("%px: non vap %d packet tx not allowed", nss_ctx, if_num);
-		return NSS_TX_FAILURE_NOT_SUPPORTED;
-	}
-
 	return nss_core_send_packet(nss_ctx, os_buf, if_num, H2N_BIT_FLAG_BUFFER_REUSABLE);
 }
 EXPORT_SYMBOL(nss_wifi_vdev_tx_buf);
--- a/nss_wifili.c
+++ b/nss_wifili.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -20,56 +20,6 @@
 #include "nss_wifili_strings.h"
 
 #define NSS_WIFILI_TX_TIMEOUT 1000 /* Millisecond to jiffies*/
-#define NSS_WIFILI_INVALID_SCHEME_ID  -1
-#define NSS_WIFILI_THREAD_SCHEME_ENTRY_MAX  4 /* Maximum number of thread scheme entries. */
-#define NSS_WIFILI_EXTERNAL_INTERFACE_MAX 2 /* Maximum external I/F supported */
-
-/*
- * NSS external interface number table
- */
-nss_if_num_t nss_wifili_external_tbl[NSS_WIFILI_EXTERNAL_INTERFACE_MAX] =
-	{NSS_WIFILI_EXTERNAL_INTERFACE0, NSS_WIFILI_EXTERNAL_INTERFACE1};
-
-/*
- * nss_wifili_thread_scheme_entry
- *	Details of thread scheme.
- */
-struct nss_wifili_thread_scheme_entry {
-	int32_t radio_ifnum;		/* Radio interface number. */
-	uint32_t radio_priority;	/* Priority of radio. */
-	uint32_t scheme_priority;	/* Priority of scheme. */
-	uint8_t scheme_index;		/* Scheme index allocated to radio. */
-	bool allocated;			/* Flag to check if scheme is allocated. */
-};
-
-/*
- * nss_wifili_thread_scheme_db
- *	Wifili thread scheme database.
- */
-struct nss_wifili_thread_scheme_db {
-	spinlock_t lock;	/* Lock to protect from simultaneous access. */
-	uint32_t radio_count;	/* Radio counter. */
-	struct nss_wifili_thread_scheme_entry nwtse[NSS_WIFILI_THREAD_SCHEME_ENTRY_MAX];
-				/* Metadata for each of scheme. */
-};
-
-/*
- * nss_wifili_external_if_state_tbl
- *	External interface state table
- */
-struct nss_wifili_external_if_state_tbl {
-	nss_if_num_t ifnum;
-	bool in_use;
-};
-
-/*
- * nss_wifili_external_if_info
- *	Wifili external interface info
- */
-struct nss_wifili_external_if_info {
-	spinlock_t lock;
-	struct nss_wifili_external_if_state_tbl state_tbl[NSS_WIFILI_EXTERNAL_INTERFACE_MAX];
-} nss_wifi_eif_info;
 
 /*
  * nss_wifili_pvt
@@ -84,11 +34,6 @@ static struct nss_wifili_pvt {
 } wifili_pvt;
 
 /*
- * Scheme to radio mapping database
- */
-static struct nss_wifili_thread_scheme_db ts_db[NSS_MAX_CORES];
-
-/*
  * nss_wifili_handler()
  *	Handle NSS -> HLOS messages for wifi
  */
@@ -105,8 +50,11 @@ static void nss_wifili_handler(struct ns
 	 */
 	BUG_ON((nss_is_dynamic_interface(ncm->interface))
 		|| ((ncm->interface != NSS_WIFILI_INTERNAL_INTERFACE)
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,0))
 		&& (ncm->interface != NSS_WIFILI_EXTERNAL_INTERFACE0)
-		&& (ncm->interface != NSS_WIFILI_EXTERNAL_INTERFACE1)));
+		&& (ncm->interface != NSS_WIFILI_EXTERNAL_INTERFACE1)
+#endif
+		));
 
 	/*
 	 * Trace messages.
@@ -122,9 +70,7 @@ static void nss_wifili_handler(struct ns
 	}
 
 	if ((nss_cmn_get_msg_len(ncm) > sizeof(struct nss_wifili_msg)) &&
-		ntm->cm.type != NSS_WIFILI_PEER_EXT_STATS_MSG &&
-		ntm->cm.type != NSS_WIFILI_ASTENTRY_SYNC_MSG &&
-		ntm->cm.type != NSS_WIFILI_MECENTRY_SYNC_MSG) {
+		ntm->cm.type != NSS_WIFILI_PEER_EXT_STATS_MSG) {
 		nss_warning("%px: Length of message is greater than required: %d", nss_ctx, nss_cmn_get_msg_len(ncm));
 		return;
 	}
@@ -229,8 +175,13 @@ nss_tx_status_t nss_wifili_tx_msg(struct
 	 * The interface number shall be one of the wifili soc interfaces
 	 */
 	if ((ncm->interface != NSS_WIFILI_INTERNAL_INTERFACE)
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,0))
 		&& (ncm->interface != NSS_WIFILI_EXTERNAL_INTERFACE0)
-		&& (ncm->interface != NSS_WIFILI_EXTERNAL_INTERFACE1)) {
+		&& (ncm->interface != NSS_WIFILI_EXTERNAL_INTERFACE1))
+#else
+	)
+#endif
+	{
 		nss_warning("%px: tx request for interface that is not a wifili: %d", nss_ctx, ncm->interface);
 		return NSS_TX_FAILURE;
 	}
@@ -284,261 +235,31 @@ struct nss_ctx_instance *nss_wifili_get_
 EXPORT_SYMBOL(nss_wifili_get_context);
 
 /*
- * nss_wifili_release_external_if()
- *	Release the external interface.
- */
-void nss_wifili_release_external_if(nss_if_num_t ifnum)
-{
-	uint32_t idx;
-
-	spin_lock_bh(&nss_wifi_eif_info.lock);
-	for (idx = 0; idx < NSS_WIFILI_EXTERNAL_INTERFACE_MAX; idx++) {
-		if (nss_wifi_eif_info.state_tbl[idx].ifnum != ifnum) {
-			continue;
-		}
-
-		if (!nss_wifi_eif_info.state_tbl[idx].in_use) {
-			spin_unlock_bh(&nss_wifi_eif_info.lock);
-			nss_warning("%px: I/F num:%d is not in use\n", &nss_wifi_eif_info, ifnum);
-			return;
-		}
-
-		nss_wifi_eif_info.state_tbl[idx].in_use = false;
-		break;
-	}
-
-	spin_unlock_bh(&nss_wifi_eif_info.lock);
-
-	if (idx == NSS_WIFILI_EXTERNAL_INTERFACE_MAX) {
-		nss_warning("%px: Trying to release invalid ifnum:%d\n", &nss_wifi_eif_info, ifnum);
-	}
-}
-EXPORT_SYMBOL(nss_wifili_release_external_if);
-
-/*
  * nss_get_available_wifili_external_if()
  *	Check and return the available external interface
  */
-nss_if_num_t nss_get_available_wifili_external_if(void)
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,0))
+uint32_t nss_get_available_wifili_external_if(void)
 {
-	nss_if_num_t ifnum = -1;
-	uint32_t idx;
-
+	struct nss_ctx_instance *nss_ctx = (struct nss_ctx_instance *)&nss_top_main.nss[nss_top_main.wifi_handler_id];
 	/*
 	 * Check if the external interface is registered.
 	 * Return the interface number if not registered.
 	 */
-	spin_lock_bh(&nss_wifi_eif_info.lock);
-	for (idx = 0; idx < NSS_WIFILI_EXTERNAL_INTERFACE_MAX; idx++) {
-		if (nss_wifi_eif_info.state_tbl[idx].in_use) {
-			continue;
-		}
-
-		nss_wifi_eif_info.state_tbl[idx].in_use = true;
-		ifnum = nss_wifi_eif_info.state_tbl[idx].ifnum;
-		break;
+	if (!(nss_ctx->subsys_dp_register[NSS_WIFILI_EXTERNAL_INTERFACE0].ndev)) {
+		return NSS_WIFILI_EXTERNAL_INTERFACE0;
 	}
 
-	spin_unlock_bh(&nss_wifi_eif_info.lock);
-
-	BUG_ON(idx == NSS_WIFILI_EXTERNAL_INTERFACE_MAX);
-	return ifnum;
-}
-EXPORT_SYMBOL(nss_get_available_wifili_external_if);
-
-/*
- * nss_wifili_get_radio_num()
- *     Get NSS wifili radio count.
- *
- * Wi-Fi host driver needs to know the current radio count
- * to extract the radio priority from ini file.
- */
-uint32_t nss_wifili_get_radio_num(struct nss_ctx_instance *nss_ctx)
-{
-	uint8_t core_id;
-	uint32_t radio_count;
-
-	nss_assert(nss_ctx);
-	nss_assert(nss_ctx->id < nss_top_main.num_nss);
-
-	core_id = nss_ctx->id;
-
-	spin_lock_bh(&ts_db[core_id].lock);
-	radio_count = ts_db[core_id].radio_count;
-	spin_unlock_bh(&ts_db[core_id].lock);
-
-	return radio_count;
-}
-EXPORT_SYMBOL(nss_wifili_get_radio_num);
-
-/*
- * nss_wifili_thread_scheme_alloc()
- *	Allocate NSS worker thread scheme index.
- *
- * API does search on scheme database and returns scheme index based on
- * priority of radio and free entry available.
- * Wi-Fi driver fetches radio priority from ini file and calls this API
- * to get the scheme index based on radio priority.
- *
- */
-uint8_t nss_wifili_thread_scheme_alloc(struct nss_ctx_instance *nss_ctx,
-					int32_t radio_ifnum,
-					enum nss_wifili_thread_scheme_priority radio_priority)
-{
-	uint8_t i;
-	uint8_t scheme_idx;
-	uint8_t core_id;
-	uint8_t next_avail_entry_idx = NSS_WIFILI_THREAD_SCHEME_ENTRY_MAX;
-
-	nss_assert(nss_ctx);
-	nss_assert(nss_ctx->id < nss_top_main.num_nss);
-
-	core_id = nss_ctx->id;
-
-	/*
-	 * Iterate through scheme database and allocate
-	 * scheme_id matching the priority requested.
-	 */
-	spin_lock_bh(&ts_db[core_id].lock);
-	for (i = 0; i < NSS_WIFILI_THREAD_SCHEME_ENTRY_MAX; i++) {
-		if (ts_db[core_id].nwtse[i].allocated) {
-			continue;
-		}
-
-		if (radio_priority ==
-				ts_db[core_id].nwtse[i].scheme_priority) {
-			ts_db[core_id].nwtse[i].radio_ifnum = radio_ifnum;
-			ts_db[core_id].nwtse[i].radio_priority = radio_priority;
-			ts_db[core_id].nwtse[i].allocated = true;
-			ts_db[core_id].radio_count++;
-			scheme_idx = ts_db[core_id].nwtse[i].scheme_index;
-			spin_unlock_bh(&ts_db[core_id].lock);
-
-			nss_info("%px: Allocated scheme index:%d radio_ifnum:%d",
-					nss_ctx,
-					scheme_idx,
-					radio_ifnum);
-
-			return scheme_idx;
-		}
-
-		next_avail_entry_idx = i;
-	}
-
-	/*
-	 * When radio priority does not match any of scheme entry priority
-	 * and database has unallocated entries, provide available unallocated entry.
-	 * This prevents any catastrophic failure during attach of Wi-Fi radio.
-	 */
-	if (next_avail_entry_idx != NSS_WIFILI_THREAD_SCHEME_ENTRY_MAX) {
-
-		ts_db[core_id].nwtse[next_avail_entry_idx].radio_ifnum = radio_ifnum;
-		ts_db[core_id].nwtse[next_avail_entry_idx].radio_priority = radio_priority;
-		ts_db[core_id].nwtse[next_avail_entry_idx].allocated = true;
-		ts_db[core_id].radio_count++;
-		scheme_idx = ts_db[core_id].nwtse[next_avail_entry_idx].scheme_index;
-		spin_unlock_bh(&ts_db[core_id].lock);
-
-		nss_info("%px: Priority did not match for radio_ifnum:%d, allocated a next available scheme:%d",
-				nss_ctx,
-				radio_ifnum,
-				scheme_idx);
-
-		return scheme_idx;
+	if (!(nss_ctx->subsys_dp_register[NSS_WIFILI_EXTERNAL_INTERFACE1].ndev)) {
+		return NSS_WIFILI_EXTERNAL_INTERFACE1;
 	}
-	spin_unlock_bh(&ts_db[core_id].lock);
 
-	nss_warning("%px: Could not find scheme - radio_ifnum:%d radio_map:%d\n",
-			nss_ctx,
-			radio_ifnum,
-			radio_priority);
+	nss_warning("%px: No available external intefaces\n", nss_ctx);
 
-	return NSS_WIFILI_INVALID_SCHEME_ID;
+	return NSS_MAX_NET_INTERFACES;
 }
-EXPORT_SYMBOL(nss_wifili_thread_scheme_alloc);
-
-/*
- * nss_wifili_thread_scheme_dealloc()
- *	Reset thread scheme metadata.
- */
-void nss_wifili_thread_scheme_dealloc(struct nss_ctx_instance *nss_ctx,
-					int32_t radio_ifnum)
-{
-	uint32_t id;
-	uint8_t core_id;
-
-	nss_assert(nss_ctx);
-	nss_assert(nss_ctx->id < nss_top_main.num_nss);
-
-	core_id = nss_ctx->id;
-
-	/*
-	 * Radio count cannot be zero here.
-	 */
-	nss_assert(ts_db[core_id].radio_count);
-
-	spin_lock_bh(&ts_db[core_id].lock);
-	for (id = 0; id < NSS_WIFILI_THREAD_SCHEME_ENTRY_MAX; id++) {
-		if (ts_db[core_id].nwtse[id].radio_ifnum != radio_ifnum) {
-			continue;
-		}
-
-		ts_db[core_id].nwtse[id].radio_priority = 0;
-		ts_db[core_id].nwtse[id].allocated = false;
-		ts_db[core_id].nwtse[id].radio_ifnum = 0;
-		ts_db[core_id].radio_count--;
-		break;
-	}
-	spin_unlock_bh(&ts_db[core_id].lock);
-
-	if (id == NSS_WIFILI_THREAD_SCHEME_ENTRY_MAX) {
-		nss_warning("%px: Could not find scheme database with radio_ifnum:%d",
-				nss_ctx,
-				radio_ifnum);
-	}
-}
-EXPORT_SYMBOL(nss_wifili_thread_scheme_dealloc);
-
-/*
- * nss_wifili_thread_scheme_db_init()
- *	Initialize thread scheme database.
- */
-void nss_wifili_thread_scheme_db_init(uint8_t core_id)
-{
-	uint32_t id;
-
-	spin_lock_init(&ts_db[core_id].lock);
-
-	/*
-	 * Iterate through scheme database and assign
-	 * scheme_id and priority for each entry
-	 */
-	ts_db[core_id].radio_count = 0;
-	for (id = 0; id < NSS_WIFILI_THREAD_SCHEME_ENTRY_MAX; id++) {
-		ts_db[core_id].nwtse[id].radio_priority = 0;
-		ts_db[core_id].nwtse[id].radio_ifnum = 0;
-		ts_db[core_id].nwtse[id].allocated = false;
-
-		switch (id) {
-		case 0:
-			ts_db[core_id].nwtse[id].scheme_priority = NSS_WIFILI_HIGH_PRIORITY_SCHEME;
-			ts_db[core_id].nwtse[id].scheme_index = NSS_WIFILI_THREAD_SCHEME_ID_0;
-			break;
-		case 1:
-			ts_db[core_id].nwtse[id].scheme_priority = NSS_WIFILI_LOW_PRIORITY_SCHEME;
-			ts_db[core_id].nwtse[id].scheme_index = NSS_WIFILI_THREAD_SCHEME_ID_1;
-			break;
-		case 2:
-		case 3:
-			ts_db[core_id].nwtse[id].scheme_priority = NSS_WIFILI_HIGH_PRIORITY_SCHEME;
-			ts_db[core_id].nwtse[id].scheme_index = NSS_WIFILI_THREAD_SCHEME_ID_2;
-			break;
-		default:
-			nss_warning("Invalid scheme index:%d", id);
-		}
-	}
-}
-
+EXPORT_SYMBOL(nss_get_available_wifili_external_if);
+#endif
 /*
  * nss_wifili_msg_init()
  *	Initialize nss_wifili_msg.
@@ -598,7 +319,6 @@ void nss_unregister_wifili_if(uint32_t i
 			|| (if_num == NSS_WIFILI_EXTERNAL_INTERFACE1));
 
 	nss_core_unregister_subsys_dp(nss_ctx, if_num);
-	nss_wifili_release_external_if(if_num);
 }
 EXPORT_SYMBOL(nss_unregister_wifili_if);
 
@@ -648,25 +368,16 @@ EXPORT_SYMBOL(nss_unregister_wifili_radi
 void nss_wifili_register_handler(void)
 {
 	struct nss_ctx_instance *nss_ctx = (struct nss_ctx_instance *)&nss_top_main.nss[nss_top_main.wifi_handler_id];
-	uint32_t idx;
 
 	nss_info("nss_wifili_register_handler");
 	nss_core_register_handler(nss_ctx, NSS_WIFILI_INTERNAL_INTERFACE, nss_wifili_handler, NULL);
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,0))
 	nss_core_register_handler(nss_ctx, NSS_WIFILI_EXTERNAL_INTERFACE0, nss_wifili_handler, NULL);
 	nss_core_register_handler(nss_ctx, NSS_WIFILI_EXTERNAL_INTERFACE1, nss_wifili_handler, NULL);
-
+#endif
 	nss_wifili_stats_dentry_create();
 	nss_wifili_strings_dentry_create();
 
 	sema_init(&wifili_pvt.sem, 1);
 	init_completion(&wifili_pvt.complete);
-
-	/*
-	 * Intialize the external interfaces info.
-	 */
-	spin_lock_init(&nss_wifi_eif_info.lock);
-	for (idx = 0; idx < NSS_WIFILI_EXTERNAL_INTERFACE_MAX; idx++) {
-		nss_wifi_eif_info.state_tbl[idx].ifnum = nss_wifili_external_tbl[idx];
-		nss_wifi_eif_info.state_tbl[idx].in_use = false;
-	}
 }
--- a/nss_wifili_stats.c
+++ b/nss_wifili_stats.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2017-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
  * above copyright notice and this permission notice appear in all copies.
@@ -37,37 +37,6 @@ ATOMIC_NOTIFIER_HEAD(nss_wifili_stats_no
 struct nss_wifili_soc_stats soc_stats[NSS_WIFILI_MAX_SOC_NUM];
 
 /*
- * nss_wifili_target_type_string()
- * 	Convert Target Type Integer to String
- */
-void nss_wifili_target_type_to_string(uint32_t target_type, char *target_type_str)
-{
-	switch (target_type) {
-
-	case NSS_WIFILI_TARGET_TYPE_QCA8074:
-		snprintf(target_type_str, NSS_WIFILI_SOC_STRING_SIZE_MAX, "IPQ8074 V1");
-		break;
-	case NSS_WIFILI_TARGET_TYPE_QCA8074V2:
-		snprintf(target_type_str, NSS_WIFILI_SOC_STRING_SIZE_MAX, "IPQ8074 V2");
-		break;
-	case NSS_WIFILI_TARGET_TYPE_QCA6018:
-		snprintf(target_type_str, NSS_WIFILI_SOC_STRING_SIZE_MAX, "IPQ6018");
-		break;
-	case NSS_WIFILI_TARGET_TYPE_QCN9000:
-		snprintf(target_type_str, NSS_WIFILI_SOC_STRING_SIZE_MAX, "QCN9000");
-		break;
-	case NSS_WIFILI_TARGET_TYPE_QCA5018:
-		snprintf(target_type_str, NSS_WIFILI_SOC_STRING_SIZE_MAX, "IPQ5018");
-		break;
-	case NSS_WIFILI_TARGET_TYPE_QCN6122:
-		snprintf(target_type_str, NSS_WIFILI_SOC_STRING_SIZE_MAX, "QCN6122");
-		break;
-	default :
-		snprintf(target_type_str, NSS_WIFILI_SOC_STRING_SIZE_MAX, "Unknown");
-        }
-}
-
-/*
  * nss_wifili_stats_read()
  *	Read wifili statistics
  */
@@ -87,7 +56,6 @@ static ssize_t nss_wifili_stats_read(str
 	char *lbuf = NULL;
 	uint32_t soc_idx;
 	struct nss_wifili_stats *stats_wifili = NULL;
-	char pdev_tag[NSS_WIFILI_SOC_STRING_SIZE_MAX];
 
 	/*
 	 * Max number of pdev depends on type of soc (Internal/Attached).
@@ -115,17 +83,12 @@ static ssize_t nss_wifili_stats_read(str
 		return 0;
 	}
 
+	size_wr += nss_stats_banner(lbuf, size_wr, size_al, "wifili", NSS_STATS_SINGLE_CORE);
 
 	for (soc_idx = 0; soc_idx < NSS_WIFILI_MAX_SOC_NUM; soc_idx++) {
-		if (soc_stats[soc_idx].soc_maxpdev == 0) {
-			continue;
-		}
-
-		size_wr += nss_stats_banner(lbuf, size_wr, size_al, soc_stats[soc_idx].soc_type, NSS_STATS_SINGLE_CORE);
 		stats_wifili = &(soc_stats[soc_idx].stats_wifili);
 		for (i = 0; i < soc_stats[soc_idx].soc_maxpdev; i++) {
-			snprintf(pdev_tag, NSS_WIFILI_SOC_STRING_SIZE_MAX, "PDEV %d", i);
-			size_wr += nss_stats_banner(lbuf, size_wr, size_al, pdev_tag, NSS_STATS_SINGLE_CORE);
+
 			spin_lock_bh(&nss_top_main.stats_lock);
 			size_wr += nss_stats_print("wifili", "txrx", i
 					, nss_wifili_strings_stats_txrx
@@ -275,9 +238,6 @@ void nss_wifili_stats_sync(struct nss_ct
 	struct nss_wifili_stats *stats = NULL;
 	struct nss_wifili_device_stats *devstats = &wlsoc_stats->stats;
 	uint32_t index;
-	char target_type_str[NSS_WIFILI_SOC_STRING_SIZE_MAX];
-
-	nss_wifili_target_type_to_string(wlsoc_stats->target_type, target_type_str);
 
 	/*
 	 * Max number of pdev depends on type of soc (Internal/Attached).
@@ -286,20 +246,19 @@ void nss_wifili_stats_sync(struct nss_ct
 	case NSS_WIFILI_INTERNAL_INTERFACE:
 		nwss = &soc_stats[0];
 		nwss->soc_maxpdev = NSS_WIFILI_MAX_PDEV_NUM_MSG;
-		snprintf(nwss->soc_type, NSS_WIFILI_SOC_STRING_SIZE_MAX, "INTERNAL: %s", target_type_str);
 		break;
 
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,0))
 	case NSS_WIFILI_EXTERNAL_INTERFACE0:
 		nwss = &soc_stats[1];
 		nwss->soc_maxpdev = NSS_WIFILI_SOC_ATTACHED_MAX_PDEV_NUM;
-		snprintf(nwss->soc_type, NSS_WIFILI_SOC_STRING_SIZE_MAX, "ATTACH 0: %s", target_type_str);
 		break;
 
 	case NSS_WIFILI_EXTERNAL_INTERFACE1:
 		nwss = &soc_stats[2];
 		nwss->soc_maxpdev = NSS_WIFILI_SOC_ATTACHED_MAX_PDEV_NUM;
-		snprintf(nwss->soc_type, NSS_WIFILI_SOC_STRING_SIZE_MAX, "ATTACH 1: %s", target_type_str);
 		break;
+#endif
 
 	default:
 		nss_warning("%px: Invalid wifili interface\n", nss_ctx);
@@ -402,10 +361,6 @@ void nss_wifili_stats_sync(struct nss_ct
 								devstats->txcomp_stats[index].hw_ring_empty;
 		stats->stats_tx_comp[index][NSS_WIFILI_STATS_TX_DESC_FREE_REAPED] +=
 								devstats->txcomp_stats[index].ring_reaped;
-		stats->stats_tx_comp[index][NSS_WIFILI_STATS_TX_CAPTURE_ENQUEUE] +=
-								devstats->txcomp_stats[index].tx_cap_enqueue_count;
-		stats->stats_tx_comp[index][NSS_WIFILI_STATS_TX_CAPTURE_ENQUEUE_FAIL] +=
-								devstats->txcomp_stats[index].tx_cap_enqueue_fail_count;
 	}
 
 	/*
@@ -505,7 +460,7 @@ void nss_wifili_stats_notify(struct nss_
 	struct nss_wifili_stats_notification *wifili_stats;
 	uint32_t index = 0;
 
-	wifili_stats = kzalloc(sizeof(struct nss_wifili_stats_notification), in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
+	wifili_stats = kzalloc(sizeof(struct nss_wifili_stats_notification), GFP_KERNEL);
 	if (!wifili_stats) {
 		nss_warning("%px: Failed to allocate memory for wifili stats\n", nss_ctx);
 		return;
@@ -517,6 +472,7 @@ void nss_wifili_stats_notify(struct nss_
 		index = 0;
 		break;
 
+#if (NSS_FW_VERSION_CODE > NSS_FW_VERSION(11,0))
 	case NSS_WIFILI_EXTERNAL_INTERFACE0:
 		index = 1;
 		break;
@@ -524,6 +480,7 @@ void nss_wifili_stats_notify(struct nss_
 	case NSS_WIFILI_EXTERNAL_INTERFACE1:
 		index = 2;
 		break;
+#endif
 
 	default:
 		nss_warning("%px: Invalid wifili interface\n", nss_ctx);
--- a/nss_wifili_stats.h
+++ b/nss_wifili_stats.h
@@ -22,13 +22,6 @@
 #ifndef __NSS_WIFILI_STATS_H
 #define __NSS_WIFILI_STATS_H
 
-#define NSS_WIFILI_TARGET_TYPE_QCA8074   20
-#define NSS_WIFILI_TARGET_TYPE_QCA8074V2 24
-#define NSS_WIFILI_TARGET_TYPE_QCA6018   25
-#define NSS_WIFILI_TARGET_TYPE_QCN9000   26
-#define NSS_WIFILI_TARGET_TYPE_QCA5018   29
-#define NSS_WIFILI_TARGET_TYPE_QCN6122   30
-
 #include "nss_core.h"
 #include "nss_wifili_if.h"
 
--- a/nss_wifili_strings.c
+++ b/nss_wifili_strings.c
@@ -1,6 +1,6 @@
 /*
  **************************************************************************
- * Copyright (c) 2019-2021, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2019-2020, The Linux Foundation. All rights reserved.
  *
  * Permission to use, copy, modify, and/or distribute this software for
  * any purpose with or without fee is hereby granted, provided that the
@@ -71,12 +71,10 @@ struct nss_stats_info nss_wifili_strings
  *	wifili tx comp stats
  */
 struct nss_stats_info nss_wifili_strings_stats_tx_comp[NSS_WIFILI_STATS_TX_DESC_FREE_MAX] = {
-	{"tx_desc_free_inv_bufsrc"		, NSS_STATS_TYPE_ERROR},
-	{"tx_desc_free_inv_cookie"		, NSS_STATS_TYPE_SPECIAL},
-	{"tx_desc_free_hw_ring_empty"		, NSS_STATS_TYPE_SPECIAL},
-	{"tx_desc_free_reaped"			, NSS_STATS_TYPE_SPECIAL},
-	{"tx_capture_enqueue_count"		, NSS_STATS_TYPE_SPECIAL},
-	{"tx_capture_enqueue_fail_count"	, NSS_STATS_TYPE_ERROR}
+	{"tx_desc_free_inv_bufsrc"	, NSS_STATS_TYPE_ERROR},
+	{"tx_desc_free_inv_cookie"	, NSS_STATS_TYPE_SPECIAL},
+	{"tx_desc_free_hw_ring_empty"	, NSS_STATS_TYPE_SPECIAL},
+	{"tx_desc_free_reaped"		, NSS_STATS_TYPE_SPECIAL}
 };
 
 /*
